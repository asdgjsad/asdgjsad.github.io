[{"title":"sass实现主题切换","path":"/2024/06/17/78/","content":"需要用到的sass知识点 变量的定义 @mixin混入 @each遍历 实现代码1234567891011121314151617181920212223242526272829$light: ( bg-color: #ffffff);$dark: ( bg-color: #130f40);// 存储主题$themes: ( light: $light, dark: $dark);@mixin theme()&#123; // 遍历当前主题 @each $item in map-keys($themes) &#123; // 获取当前主题的颜色 $current-theme: map-get($themes, $item); // 不同主题使用不同主题颜色 [data-theme=&#x27;#&#123;$item&#125;&#x27;] &amp;&#123; background-color: map-get($current-theme, bg-color); &#125; &#125;&#125;body&#123; @include theme;&#125;","tags":["sass"],"categories":["前端进阶"]},{"title":"GSAP基础知识","path":"/2024/06/16/76/","content":"安装 CDN 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/gsap@3.12/dist/gsap.min.js&quot;&gt;&lt;/script&gt; npm 1npm install gsap 使用1gsap.to(&quot;.box&quot;, &#123;x: 200&#125;) 说明： to\t方法 .box\t类名 x\t水平方向移动的距离 有哪些方法 gsap.to()——这是一种最常用的tween动画，就是让元素从初始状态变化到目标状态 gsap.from()——有点像to方法的逆向变化，就是让元素从目标状态变化到初始状态。 gsap.fromTo()——需要自己定义两个状态的数据，然后从前一个变化到后一个。 gsap.set()——直接设置成想要的状态，没有任何过度与动画效果。本质上就是duration为0的 .to 方法 常用属性 属性 说明 x 水平移动 y 垂直移动 xPercent 水平移动（元素自身百分比） yPercent 垂直移动（元素自身百分比） rotation 旋转 scale 缩放 transformOrigin 设置旋转中心点 duration 动画变化的时长（秒）默认是0.5 delay 动画变化开始前的延迟时长（秒），默认是0.5 repeat 动画的重复次数 yoyo 如果设置为ture，那么动画会在执行完之后再反向执行一次，就像悠悠球的效果，默认是false stagger 是一个时间的设置（秒），如果有多个元素同时要被驱动，那么当这个属性设置了时间的值之后，元素们会被依次逐个驱动，间隔时长就是这个属性设置的时长 ease 动画过渡的运动曲线的设置，默认是”power1.out” onComplete 动画结束时执行的回调函数 Timelines时间线时间线能让我们创建非常容易调节的、很灵活的顺序动画效果。下面就是一个简单的包含着三个tween动画的timeline实例效果。默认情况下，这些动画是依次添加的，他们在变化的时候也是依次执行，而且是一个执行完之后再下一个执行。 1234567// 创建一个Timeline类型的实例let tl = gsap.timeline()// 把tween动画添加到timeline实例上，注意我们在用的是tl.to 而不是gsap.totl.to(&quot;.green&quot;, &#123; x: 600, duration: 2 &#125;);tl.to(&quot;.purple&quot;, &#123; x: 600, duration: 1 &#125;);tl.to(&quot;.orange&quot;, &#123; x: 600, duration: 1 &#125;); 调整执行时间点 12345678910let tl = gsap.timeline()// 绿色方块会在整个时间线开始1秒后进行移动tl.to(&quot;.green&quot;, &#123; x: 600, duration: 2 &#125;, 1);// 紫色方块会和之前一个添加的动画同时开始运动tl.to(&quot;.purple&quot;, &#123; x: 600, duration: 1 &#125;, &quot;&lt;&quot;);// 橘色方块会在之前所有动画都结束一秒后再开始运动tl.to(&quot;.orange&quot;, &#123; x: 600, duration: 1 &#125;, &quot;+=1&quot;); 特殊属性 Special Properties Timelines可以设置的动画属性和tween动画绝大部分是一样的，比如像repeat和delay，可以让你轻松的设定整个顺序动画的动画属性 12345let tl = gsap.timeline(&#123;repeat: -1, repeatDelay: 1, yoyo: true&#125;)tl.to(&quot;.green&quot;, &#123; rotation: 360 &#125;);tl.to(&quot;.purple&quot;, &#123; rotation: 360 &#125;);tl.to(&quot;.orange&quot;, &#123; rotation: 360 &#125;); 时间线的默认设置 如果你发现自己总是一遍又一遍的写同一个属性，那么你可以使用 defaults来进行设置。任何添加到时间线上的defaults的属性，都会被添加到这个时间线上的tween动画继承，像是通过to(),from()和fromTo()方式添加到时间线上的动画效果都是有这个继承效果的。利用这个方式可以让你的代码更简洁一些。 123456var tl = gsap.timeline(&#123; defaults: &#123; duration: 1 &#125; &#125;);//这样每个动画都是1秒的时长，不用重复写了tl.to(&quot;.color1&quot;, &#123; x: 200 &#125;)tl.to(&quot;.color2&quot;, &#123; x: 200, scale: 0.2 &#125;)tl.to(&quot;.color3&quot;, &#123; x: 200, scale: 2, y: 20 &#125;); 控制动画通过一个变量保存对Tween或者Timeline实例的引用 1let tween = gsap.to(&quot;.color1&quot;, &#123; duration: 10, x: 700 &#125;); 暂停动画：tween.pause() 继续动画：tween.resume() 反向变化：tween.reverse() 切换至动画1s时候的状态：tween.seek(1) 切换至动画1&#x2F;4时候的状态：tween.progress(1/4) 让动画速度变为原来的0.5倍：tween.timeScale(0.5) 销毁tween实例：tween.kill() 动画事件onStart：动画开始时触发 12345gsap.to(&quot;.color1&quot;, &#123;x:300,duration:3,onStart:event&#125;)function event()&#123;\tconsole.log(&#x27;触发&#x27;)&#125; onComplete：动画结束时触发 onUpdate：只要动画运行，每一帧都会触发（元素有属性变化时） onRepeat：每次动画重复时触发 onReverseComplete：当动画反向执行后运动到变化起始点时触发","tags":["GSAP"],"categories":["前端进阶"]},{"title":"GSAP插件介绍","path":"/2024/06/16/77/","content":"ScrollTrigger 一个可以将元素动画效果与浏览器滚动条关联起来的插件 引入依赖 1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/ScrollTrigger.min.js&quot;&gt;&lt;/script&gt; 使用 1234567891011gsap.registerPlugin(ScrollTrigger) // 注册插件gsap.to(&#x27;.box&#x27;, &#123; scrollTrigger: &#123; trigger: &#x27;.box&#x27;, // 在哪些元素上触发动画 scrub: true, // 将指定元素与滚动条进行关联 pin: true, // 固定元素 start: &quot;center center&quot; // 元素播放动画时在可视窗口的位置 &#125;, x: 500, ease: &quot;none&quot;&#125;);","tags":["GSAP"],"categories":["前端进阶"]},{"title":"three.js添加gui参数调试工具","path":"/2024/06/15/75/","content":"安装依赖1npm install --save dat.gui 在vue中使用123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div id=&quot;canvas&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import dat from &quot;dat.gui&quot; // 创建gui调试面板 // 创建控制对象 const controlData = &#123; color: &quot;#2f3542&quot; &#125; // 创建实例 const gui = new dat.GUI() const folder = gui.addFolder(&quot;参数调试&quot;) // 颜色选择器 folder.addColor(controlData, &quot;color&quot;) // 添加id选择器，方便后续进行样式控制 folder.domElement.id = &quot;gui&quot; folder.open() onMounted(()=&gt;&#123; // 将gui面板元素放入app中 document.getElementById(&quot;canvas&quot;).appendChild(folder.domElement) // 基础材质 const material = new THREE.MeshBasicMaterial(&#123; color: controlData.color &#125;) // 在动画函数中进行 function animate(time) &#123; // 调试颜色 mesh.material.color = new THREE.Color(controlData.color) &#125; &#125;)&lt;/script&gt;","tags":["three.js"],"categories":["前端进阶"]},{"title":"three.js添加轨道控制器","path":"/2024/06/14/73/","content":"注意这个轨道控制器，three这个库并没有，需要大家自己找，这里我就直接把轨道控制器的代码粘过来了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507import &#123;\tEventDispatcher,\tMOUSE,\tQuaternion,\tSpherical,\tTOUCH,\tVector2,\tVector3,\tPlane,\tRay,\tMathUtils&#125; from &#x27;three&#x27;;// OrbitControls performs orbiting, dollying (zooming), and panning.// Unlike TrackballControls, it maintains the &quot;up&quot; direction object.up (+Y by default).//// Orbit - left mouse / touch: one-finger move// Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish// Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger moveconst _changeEvent = &#123; type: &#x27;change&#x27; &#125;;const _startEvent = &#123; type: &#x27;start&#x27; &#125;;const _endEvent = &#123; type: &#x27;end&#x27; &#125;;const _ray = new Ray();const _plane = new Plane();const TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );class OrbitControls extends EventDispatcher &#123;\tconstructor( object, domElement ) &#123; super(); this.object = object; this.domElement = domElement; this.domElement.style.touchAction = &#x27;none&#x27;; // disable touch scroll // Set to false to disable this control this.enabled = true; // &quot;target&quot; sets the location of focus, where the object orbits around this.target = new Vector3(); // Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect this.cursor = new Vector3(); // How far you can dolly in and out ( PerspectiveCamera only ) this.minDistance = 0; this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only ) this.minZoom = 0; this.maxZoom = Infinity; // Limit camera target within a spherical area around the cursor this.minTargetRadius = 0; this.maxTargetRadius = Infinity; // How far you can orbit vertically, upper and lower limits. // Range is 0 to Math.PI radians. this.minPolarAngle = 0; // radians this.maxPolarAngle = Math.PI; // radians // How far you can orbit horizontally, upper and lower limits. // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min &lt; 2 PI ) this.minAzimuthAngle = - Infinity; // radians this.maxAzimuthAngle = Infinity; // radians // Set to true to enable damping (inertia) // If damping is enabled, you must call controls.update() in your animation loop this.enableDamping = false; this.dampingFactor = 0.05; // This option actually enables dollying in and out; left as &quot;zoom&quot; for backwards compatibility. // Set to false to disable zooming this.enableZoom = true; this.zoomSpeed = 1.0; // Set to false to disable rotating this.enableRotate = true; this.rotateSpeed = 1.0; // Set to false to disable panning this.enablePan = true; this.panSpeed = 1.0; this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push this.zoomToCursor = false; // Set to true to automatically rotate around the target // If auto-rotate is enabled, you must call controls.update() in your animation loop this.autoRotate = false; this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60 // The four arrow keys this.keys = &#123; LEFT: &#x27;ArrowLeft&#x27;, UP: &#x27;ArrowUp&#x27;, RIGHT: &#x27;ArrowRight&#x27;, BOTTOM: &#x27;ArrowDown&#x27; &#125;; // Mouse buttons this.mouseButtons = &#123; LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN &#125;; // Touch fingers this.touches = &#123; ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN &#125;; // for reset this.target0 = this.target.clone(); this.position0 = this.object.position.clone(); this.zoom0 = this.object.zoom; // the target DOM element for key events this._domElementKeyEvents = null; // // public methods // this.getPolarAngle = function () &#123; return spherical.phi; &#125;; this.getAzimuthalAngle = function () &#123; return spherical.theta; &#125;; this.getDistance = function () &#123; return this.object.position.distanceTo( this.target ); &#125;; this.listenToKeyEvents = function ( domElement ) &#123; domElement.addEventListener( &#x27;keydown&#x27;, onKeyDown ); this._domElementKeyEvents = domElement; &#125;; this.stopListenToKeyEvents = function () &#123; this._domElementKeyEvents.removeEventListener( &#x27;keydown&#x27;, onKeyDown ); this._domElementKeyEvents = null; &#125;; this.saveState = function () &#123; scope.target0.copy( scope.target ); scope.position0.copy( scope.object.position ); scope.zoom0 = scope.object.zoom; &#125;; this.reset = function () &#123; scope.target.copy( scope.target0 ); scope.object.position.copy( scope.position0 ); scope.object.zoom = scope.zoom0; scope.object.updateProjectionMatrix(); scope.dispatchEvent( _changeEvent ); scope.update(); state = STATE.NONE; &#125;; // this method is exposed, but perhaps it would be better if we can make it private... this.update = function () &#123; const offset = new Vector3(); // so camera.up is the orbit axis const quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) ); const quatInverse = quat.clone().invert(); const lastPosition = new Vector3(); const lastQuaternion = new Quaternion(); const lastTargetPosition = new Vector3(); const twoPI = 2 * Math.PI; return function update( deltaTime = null ) &#123; const position = scope.object.position; offset.copy( position ).sub( scope.target ); // rotate offset to &quot;y-axis-is-up&quot; space offset.applyQuaternion( quat ); // angle from z-axis around y-axis spherical.setFromVector3( offset ); if ( scope.autoRotate &amp;&amp; state === STATE.NONE ) &#123; rotateLeft( getAutoRotationAngle( deltaTime ) ); &#125; if ( scope.enableDamping ) &#123; spherical.theta += sphericalDelta.theta * scope.dampingFactor; spherical.phi += sphericalDelta.phi * scope.dampingFactor; &#125; else &#123; spherical.theta += sphericalDelta.theta; spherical.phi += sphericalDelta.phi; &#125; // restrict theta to be between desired limits let min = scope.minAzimuthAngle; let max = scope.maxAzimuthAngle; if ( isFinite( min ) &amp;&amp; isFinite( max ) ) &#123; if ( min &lt; - Math.PI ) min += twoPI; else if ( min &gt; Math.PI ) min -= twoPI; if ( max &lt; - Math.PI ) max += twoPI; else if ( max &gt; Math.PI ) max -= twoPI; if ( min &lt;= max ) &#123; spherical.theta = Math.max( min, Math.min( max, spherical.theta ) ); &#125; else &#123; spherical.theta = ( spherical.theta &gt; ( min + max ) / 2 ) ? Math.max( min, spherical.theta ) : Math.min( max, spherical.theta ); &#125; &#125; // restrict phi to be between desired limits spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) ); spherical.makeSafe(); // move target to panned location if ( scope.enableDamping === true ) &#123; scope.target.addScaledVector( panOffset, scope.dampingFactor ); &#125; else &#123; scope.target.add( panOffset ); &#125; // Limit the target distance from the cursor to create a sphere around the center of interest scope.target.sub( scope.cursor ); scope.target.clampLength( scope.minTargetRadius, scope.maxTargetRadius ); scope.target.add( scope.cursor ); // adjust the camera position based on zoom only if we&#x27;re not zooming to the cursor or if it&#x27;s an ortho camera // we adjust zoom later in these cases if ( scope.zoomToCursor &amp;&amp; performCursorZoom || scope.object.isOrthographicCamera ) &#123; spherical.radius = clampDistance( spherical.radius ); &#125; else &#123; spherical.radius = clampDistance( spherical.radius * scale ); &#125; offset.setFromSpherical( spherical ); // rotate offset back to &quot;camera-up-vector-is-up&quot; space offset.applyQuaternion( quatInverse ); position.copy( scope.target ).add( offset ); scope.object.lookAt( scope.target ); if ( scope.enableDamping === true ) &#123; sphericalDelta.theta *= ( 1 - scope.dampingFactor ); sphericalDelta.phi *= ( 1 - scope.dampingFactor ); panOffset.multiplyScalar( 1 - scope.dampingFactor ); &#125; else &#123; sphericalDelta.set( 0, 0, 0 ); panOffset.set( 0, 0, 0 ); &#125; // adjust camera position let zoomChanged = false; if ( scope.zoomToCursor &amp;&amp; performCursorZoom ) &#123; let newRadius = null; if ( scope.object.isPerspectiveCamera ) &#123; // move the camera down the pointer ray // this method avoids floating point error const prevRadius = offset.length(); newRadius = clampDistance( prevRadius * scale ); const radiusDelta = prevRadius - newRadius; scope.object.position.addScaledVector( dollyDirection, radiusDelta ); scope.object.updateMatrixWorld(); &#125; else if ( scope.object.isOrthographicCamera ) &#123; // adjust the ortho camera position based on zoom changes const mouseBefore = new Vector3( mouse.x, mouse.y, 0 ); mouseBefore.unproject( scope.object ); scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) ); scope.object.updateProjectionMatrix(); zoomChanged = true; const mouseAfter = new Vector3( mouse.x, mouse.y, 0 ); mouseAfter.unproject( scope.object ); scope.object.position.sub( mouseAfter ).add( mouseBefore ); scope.object.updateMatrixWorld(); newRadius = offset.length(); &#125; else &#123; console.warn( &#x27;WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.&#x27; ); scope.zoomToCursor = false; &#125; // handle the placement of the target if ( newRadius !== null ) &#123; if ( this.screenSpacePanning ) &#123; // position the orbit target in front of the new camera position scope.target.set( 0, 0, - 1 ) .transformDirection( scope.object.matrix ) .multiplyScalar( newRadius ) .add( scope.object.position ); &#125; else &#123; // get the ray and translation plane to compute target _ray.origin.copy( scope.object.position ); _ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix ); // if the camera is 20 degrees above the horizon then don&#x27;t adjust the focus target to avoid // extremely large values if ( Math.abs( scope.object.up.dot( _ray.direction ) ) &lt; TILT_LIMIT ) &#123; object.lookAt( scope.target ); &#125; else &#123; _plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target ); _ray.intersectPlane( _plane, scope.target ); &#125; &#125; &#125; &#125; else if ( scope.object.isOrthographicCamera ) &#123; zoomChanged = scale !== 1; if ( zoomChanged ) &#123; scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) ); scope.object.updateProjectionMatrix(); &#125; &#125; scale = 1; performCursorZoom = false; // update condition is: // min(camera displacement, camera rotation in radians)^2 &gt; EPS // using small-angle approximation cos(x/2) = 1 - x^2 / 8 if ( zoomChanged || lastPosition.distanceToSquared( scope.object.position ) &gt; EPS || 8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) &gt; EPS || lastTargetPosition.distanceToSquared( scope.target ) &gt; 0 ) &#123; scope.dispatchEvent( _changeEvent ); lastPosition.copy( scope.object.position ); lastQuaternion.copy( scope.object.quaternion ); lastTargetPosition.copy( scope.target ); return true; &#125; return false; &#125;; &#125;(); this.dispose = function () &#123; scope.domElement.removeEventListener( &#x27;contextmenu&#x27;, onContextMenu ); scope.domElement.removeEventListener( &#x27;pointerdown&#x27;, onPointerDown ); scope.domElement.removeEventListener( &#x27;pointercancel&#x27;, onPointerUp ); scope.domElement.removeEventListener( &#x27;wheel&#x27;, onMouseWheel ); scope.domElement.removeEventListener( &#x27;pointermove&#x27;, onPointerMove ); scope.domElement.removeEventListener( &#x27;pointerup&#x27;, onPointerUp ); if ( scope._domElementKeyEvents !== null ) &#123; scope._domElementKeyEvents.removeEventListener( &#x27;keydown&#x27;, onKeyDown ); scope._domElementKeyEvents = null; &#125; //scope.dispatchEvent( &#123; type: &#x27;dispose&#x27; &#125; ); // should this be added here? &#125;; // // internals // const scope = this; const STATE = &#123; NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 &#125;; let state = STATE.NONE; const EPS = 0.000001; // current position in spherical coordinates const spherical = new Spherical(); const sphericalDelta = new Spherical(); let scale = 1; const panOffset = new Vector3(); const rotateStart = new Vector2(); const rotateEnd = new Vector2(); const rotateDelta = new Vector2(); const panStart = new Vector2(); const panEnd = new Vector2(); const panDelta = new Vector2(); const dollyStart = new Vector2(); const dollyEnd = new Vector2(); const dollyDelta = new Vector2(); const dollyDirection = new Vector3(); const mouse = new Vector2(); let performCursorZoom = false; const pointers = []; const pointerPositions = &#123;&#125;; let controlActive = false; function getAutoRotationAngle( deltaTime ) &#123; if ( deltaTime !== null ) &#123; return ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime; &#125; else &#123; return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed; &#125; &#125; function getZoomScale( delta ) &#123; const normalizedDelta = Math.abs( delta * 0.01 ); return Math.pow( 0.95, scope.zoomSpeed * normalizedDelta ); &#125; function rotateLeft( angle ) &#123; sphericalDelta.theta -= angle; &#125; function rotateUp( angle ) &#123; sphericalDelta.phi -= angle; &#125; const panLeft = function () &#123; const v = new Vector3(); return function panLeft( distance, objectMatrix ) &#123; v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix v.multiplyScalar( - distance ); panOffset.add( v ); &#125;; &#125;(); const panUp = function () &#123; const v = new Vector3(); return function panUp( distance, objectMatrix ) &#123; if ( scope.screenSpacePanning === true ) &#123; v.setFromMatrixColumn( objectMatrix, 1 ); &#125; else &#123; v.setFromMatrixColumn( objectMatrix, 0 ); v.crossVectors( scope.object.up, v ); &#125; v.multiplyScalar( distance ); panOffset.add( v ); &#125;; &#125;(); // deltaX and deltaY are in pixels; right and down are positive const pan = function () &#123; const offset = new Vector3(); return function pan( deltaX, deltaY ) &#123; const element = scope.domElement; if ( scope.object.isPerspectiveCamera ) &#123; // perspective const position = scope.object.position; offset.copy( position ).sub( scope.target ); let targetDistance = offset.length(); // half of the fov is center to top of screen targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 ); // we use only clientHeight here so aspect ratio does not distort speed panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix ); panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix ); &#125; else if ( scope.object.isOrthographicCamera ) &#123; // orthographic panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix ); panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix ); &#125; else &#123; // camera neither orthographic nor perspective console.warn( &#x27;WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.&#x27; ); scope.enablePan = false; &#125; &#125;; &#125;(); function dollyOut( dollyScale ) &#123; if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) &#123; scale /= dollyScale; &#125; else &#123; console.warn( &#x27;WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.&#x27; ); scope.enableZoom = false; &#125; &#125; function dollyIn( dollyScale ) &#123; if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) &#123; scale *= dollyScale; &#125; else &#123; console.warn( &#x27;WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.&#x27; ); scope.enableZoom = false; &#125; &#125; function updateZoomParameters( x, y ) &#123; if ( ! scope.zoomToCursor ) &#123; return; &#125; performCursorZoom = true; const rect = scope.domElement.getBoundingClientRect(); const dx = x - rect.left; const dy = y - rect.top; const w = rect.width; const h = rect.height; mouse.x = ( dx / w ) * 2 - 1; mouse.y = - ( dy / h ) * 2 + 1; dollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize(); &#125; function clampDistance( dist ) &#123; return Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) ); &#125; // // event callbacks - update the object state // function handleMouseDownRotate( event ) &#123; rotateStart.set( event.clientX, event.clientY ); &#125; function handleMouseDownDolly( event ) &#123; updateZoomParameters( event.clientX, event.clientX ); dollyStart.set( event.clientX, event.clientY ); &#125; function handleMouseDownPan( event ) &#123; panStart.set( event.clientX, event.clientY ); &#125; function handleMouseMoveRotate( event ) &#123; rotateEnd.set( event.clientX, event.clientY ); rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); const element = scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); scope.update(); &#125; function handleMouseMoveDolly( event ) &#123; dollyEnd.set( event.clientX, event.clientY ); dollyDelta.subVectors( dollyEnd, dollyStart ); if ( dollyDelta.y &gt; 0 ) &#123; dollyOut( getZoomScale( dollyDelta.y ) ); &#125; else if ( dollyDelta.y &lt; 0 ) &#123; dollyIn( getZoomScale( dollyDelta.y ) ); &#125; dollyStart.copy( dollyEnd ); scope.update(); &#125; function handleMouseMovePan( event ) &#123; panEnd.set( event.clientX, event.clientY ); panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); scope.update(); &#125; function handleMouseWheel( event ) &#123; updateZoomParameters( event.clientX, event.clientY ); if ( event.deltaY &lt; 0 ) &#123; dollyIn( getZoomScale( event.deltaY ) ); &#125; else if ( event.deltaY &gt; 0 ) &#123; dollyOut( getZoomScale( event.deltaY ) ); &#125; scope.update(); &#125; function handleKeyDown( event ) &#123; let needsUpdate = false; switch ( event.code ) &#123; case scope.keys.UP: if ( event.ctrlKey || event.metaKey || event.shiftKey ) &#123; rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight ); &#125; else &#123; pan( 0, scope.keyPanSpeed ); &#125; needsUpdate = true; break; case scope.keys.BOTTOM: if ( event.ctrlKey || event.metaKey || event.shiftKey ) &#123; rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight ); &#125; else &#123; pan( 0, - scope.keyPanSpeed ); &#125; needsUpdate = true; break; case scope.keys.LEFT: if ( event.ctrlKey || event.metaKey || event.shiftKey ) &#123; rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight ); &#125; else &#123; pan( scope.keyPanSpeed, 0 ); &#125; needsUpdate = true; break; case scope.keys.RIGHT: if ( event.ctrlKey || event.metaKey || event.shiftKey ) &#123; rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight ); &#125; else &#123; pan( - scope.keyPanSpeed, 0 ); &#125; needsUpdate = true; break; &#125; if ( needsUpdate ) &#123; // prevent the browser from scrolling on cursor keys event.preventDefault(); scope.update(); &#125; &#125; function handleTouchStartRotate( event ) &#123; if ( pointers.length === 1 ) &#123; rotateStart.set( event.pageX, event.pageY ); &#125; else &#123; const position = getSecondPointerPosition( event ); const x = 0.5 * ( event.pageX + position.x ); const y = 0.5 * ( event.pageY + position.y ); rotateStart.set( x, y ); &#125; &#125; function handleTouchStartPan( event ) &#123; if ( pointers.length === 1 ) &#123; panStart.set( event.pageX, event.pageY ); &#125; else &#123; const position = getSecondPointerPosition( event ); const x = 0.5 * ( event.pageX + position.x ); const y = 0.5 * ( event.pageY + position.y ); panStart.set( x, y ); &#125; &#125; function handleTouchStartDolly( event ) &#123; const position = getSecondPointerPosition( event ); const dx = event.pageX - position.x; const dy = event.pageY - position.y; const distance = Math.sqrt( dx * dx + dy * dy ); dollyStart.set( 0, distance ); &#125; function handleTouchStartDollyPan( event ) &#123; if ( scope.enableZoom ) handleTouchStartDolly( event ); if ( scope.enablePan ) handleTouchStartPan( event ); &#125; function handleTouchStartDollyRotate( event ) &#123; if ( scope.enableZoom ) handleTouchStartDolly( event ); if ( scope.enableRotate ) handleTouchStartRotate( event ); &#125; function handleTouchMoveRotate( event ) &#123; if ( pointers.length == 1 ) &#123; rotateEnd.set( event.pageX, event.pageY ); &#125; else &#123; const position = getSecondPointerPosition( event ); const x = 0.5 * ( event.pageX + position.x ); const y = 0.5 * ( event.pageY + position.y ); rotateEnd.set( x, y ); &#125; rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); const element = scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); &#125; function handleTouchMovePan( event ) &#123; if ( pointers.length === 1 ) &#123; panEnd.set( event.pageX, event.pageY ); &#125; else &#123; const position = getSecondPointerPosition( event ); const x = 0.5 * ( event.pageX + position.x ); const y = 0.5 * ( event.pageY + position.y ); panEnd.set( x, y ); &#125; panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); &#125; function handleTouchMoveDolly( event ) &#123; const position = getSecondPointerPosition( event ); const dx = event.pageX - position.x; const dy = event.pageY - position.y; const distance = Math.sqrt( dx * dx + dy * dy ); dollyEnd.set( 0, distance ); dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) ); dollyOut( dollyDelta.y ); dollyStart.copy( dollyEnd ); const centerX = ( event.pageX + position.x ) * 0.5; const centerY = ( event.pageY + position.y ) * 0.5; updateZoomParameters( centerX, centerY ); &#125; function handleTouchMoveDollyPan( event ) &#123; if ( scope.enableZoom ) handleTouchMoveDolly( event ); if ( scope.enablePan ) handleTouchMovePan( event ); &#125; function handleTouchMoveDollyRotate( event ) &#123; if ( scope.enableZoom ) handleTouchMoveDolly( event ); if ( scope.enableRotate ) handleTouchMoveRotate( event ); &#125; // // event handlers - FSM: listen for events and reset state // function onPointerDown( event ) &#123; if ( scope.enabled === false ) return; if ( pointers.length === 0 ) &#123; scope.domElement.setPointerCapture( event.pointerId ); scope.domElement.addEventListener( &#x27;pointermove&#x27;, onPointerMove ); scope.domElement.addEventListener( &#x27;pointerup&#x27;, onPointerUp ); &#125; // addPointer( event ); if ( event.pointerType === &#x27;touch&#x27; ) &#123; onTouchStart( event ); &#125; else &#123; onMouseDown( event ); &#125; &#125; function onPointerMove( event ) &#123; if ( scope.enabled === false ) return; if ( event.pointerType === &#x27;touch&#x27; ) &#123; onTouchMove( event ); &#125; else &#123; onMouseMove( event ); &#125; &#125; function onPointerUp( event ) &#123; removePointer( event ); switch ( pointers.length ) &#123; case 0: scope.domElement.releasePointerCapture( event.pointerId ); scope.domElement.removeEventListener( &#x27;pointermove&#x27;, onPointerMove ); scope.domElement.removeEventListener( &#x27;pointerup&#x27;, onPointerUp ); scope.dispatchEvent( _endEvent ); state = STATE.NONE; break; case 1: const pointerId = pointers[ 0 ]; const position = pointerPositions[ pointerId ]; // minimal placeholder event - allows state correction on pointer-up onTouchStart( &#123; pointerId: pointerId, pageX: position.x, pageY: position.y &#125; ); break; &#125; &#125; function onMouseDown( event ) &#123; let mouseAction; switch ( event.button ) &#123; case 0: mouseAction = scope.mouseButtons.LEFT; break; case 1: mouseAction = scope.mouseButtons.MIDDLE; break; case 2: mouseAction = scope.mouseButtons.RIGHT; break; default: mouseAction = - 1; &#125; switch ( mouseAction ) &#123; case MOUSE.DOLLY: if ( scope.enableZoom === false ) return; handleMouseDownDolly( event ); state = STATE.DOLLY; break; case MOUSE.ROTATE: if ( event.ctrlKey || event.metaKey || event.shiftKey ) &#123; if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; &#125; else &#123; if ( scope.enableRotate === false ) return; handleMouseDownRotate( event ); state = STATE.ROTATE; &#125; break; case MOUSE.PAN: if ( event.ctrlKey || event.metaKey || event.shiftKey ) &#123; if ( scope.enableRotate === false ) return; handleMouseDownRotate( event ); state = STATE.ROTATE; &#125; else &#123; if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; &#125; break; default: state = STATE.NONE; &#125; if ( state !== STATE.NONE ) &#123; scope.dispatchEvent( _startEvent ); &#125; &#125; function onMouseMove( event ) &#123; switch ( state ) &#123; case STATE.ROTATE: if ( scope.enableRotate === false ) return; handleMouseMoveRotate( event ); break; case STATE.DOLLY: if ( scope.enableZoom === false ) return; handleMouseMoveDolly( event ); break; case STATE.PAN: if ( scope.enablePan === false ) return; handleMouseMovePan( event ); break; &#125; &#125; function onMouseWheel( event ) &#123; if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return; event.preventDefault(); scope.dispatchEvent( _startEvent ); handleMouseWheel( customWheelEvent( event ) ); scope.dispatchEvent( _endEvent ); &#125; function customWheelEvent( event ) &#123; const mode = event.deltaMode; // minimal wheel event altered to meet delta-zoom demand const newEvent = &#123; clientX: event.clientX, clientY: event.clientY, deltaY: event.deltaY, &#125;; switch ( mode ) &#123; case 1: // LINE_MODE newEvent.deltaY *= 16; break; case 2: // PAGE_MODE newEvent.deltaY *= 100; break; &#125; // detect if event was triggered by pinching if ( event.ctrlKey &amp;&amp; ! controlActive ) &#123; newEvent.deltaY *= 10; &#125; return newEvent; &#125; function interceptControlDown( event ) &#123; if ( event.key === &#x27;Control&#x27; ) &#123; controlActive = true; const document = scope.domElement.getRootNode(); // offscreen canvas compatibility document.addEventListener( &#x27;keyup&#x27;, interceptControlUp, &#123; passive: true, capture: true &#125; ); &#125; &#125; function interceptControlUp( event ) &#123; if ( event.key === &#x27;Control&#x27; ) &#123; controlActive = false; const document = scope.domElement.getRootNode(); // offscreen canvas compatibility document.removeEventListener( &#x27;keyup&#x27;, interceptControlUp, &#123; passive: true, capture: true &#125; ); &#125; &#125; function onKeyDown( event ) &#123; if ( scope.enabled === false || scope.enablePan === false ) return; handleKeyDown( event ); &#125; function onTouchStart( event ) &#123; trackPointer( event ); switch ( pointers.length ) &#123; case 1: switch ( scope.touches.ONE ) &#123; case TOUCH.ROTATE: if ( scope.enableRotate === false ) return; handleTouchStartRotate( event ); state = STATE.TOUCH_ROTATE; break; case TOUCH.PAN: if ( scope.enablePan === false ) return; handleTouchStartPan( event ); state = STATE.TOUCH_PAN; break; default: state = STATE.NONE; &#125; break; case 2: switch ( scope.touches.TWO ) &#123; case TOUCH.DOLLY_PAN: if ( scope.enableZoom === false &amp;&amp; scope.enablePan === false ) return; handleTouchStartDollyPan( event ); state = STATE.TOUCH_DOLLY_PAN; break; case TOUCH.DOLLY_ROTATE: if ( scope.enableZoom === false &amp;&amp; scope.enableRotate === false ) return; handleTouchStartDollyRotate( event ); state = STATE.TOUCH_DOLLY_ROTATE; break; default: state = STATE.NONE; &#125; break; default: state = STATE.NONE; &#125; if ( state !== STATE.NONE ) &#123; scope.dispatchEvent( _startEvent ); &#125; &#125; function onTouchMove( event ) &#123; trackPointer( event ); switch ( state ) &#123; case STATE.TOUCH_ROTATE: if ( scope.enableRotate === false ) return; handleTouchMoveRotate( event ); scope.update(); break; case STATE.TOUCH_PAN: if ( scope.enablePan === false ) return; handleTouchMovePan( event ); scope.update(); break; case STATE.TOUCH_DOLLY_PAN: if ( scope.enableZoom === false &amp;&amp; scope.enablePan === false ) return; handleTouchMoveDollyPan( event ); scope.update(); break; case STATE.TOUCH_DOLLY_ROTATE: if ( scope.enableZoom === false &amp;&amp; scope.enableRotate === false ) return; handleTouchMoveDollyRotate( event ); scope.update(); break; default: state = STATE.NONE; &#125; &#125; function onContextMenu( event ) &#123; if ( scope.enabled === false ) return; event.preventDefault(); &#125; function addPointer( event ) &#123; pointers.push( event.pointerId ); &#125; function removePointer( event ) &#123; delete pointerPositions[ event.pointerId ]; for ( let i = 0; i &lt; pointers.length; i ++ ) &#123; if ( pointers[ i ] == event.pointerId ) &#123; pointers.splice( i, 1 ); return; &#125; &#125; &#125; function trackPointer( event ) &#123; let position = pointerPositions[ event.pointerId ]; if ( position === undefined ) &#123; position = new Vector2(); pointerPositions[ event.pointerId ] = position; &#125; position.set( event.pageX, event.pageY ); &#125; function getSecondPointerPosition( event ) &#123; const pointerId = ( event.pointerId === pointers[ 0 ] ) ? pointers[ 1 ] : pointers[ 0 ]; return pointerPositions[ pointerId ]; &#125; // scope.domElement.addEventListener( &#x27;contextmenu&#x27;, onContextMenu ); scope.domElement.addEventListener( &#x27;pointerdown&#x27;, onPointerDown ); scope.domElement.addEventListener( &#x27;pointercancel&#x27;, onPointerUp ); scope.domElement.addEventListener( &#x27;wheel&#x27;, onMouseWheel, &#123; passive: false &#125; ); const document = scope.domElement.getRootNode(); // offscreen canvas compatibility document.addEventListener( &#x27;keydown&#x27;, interceptControlDown, &#123; passive: true, capture: true &#125; ); // force an update at start this.update();\t&#125;&#125;export &#123; OrbitControls &#125;; 实现 引入 1import &#123; OrbitControls &#125; from &#x27;@/assets/js/OrbitControls.js&#x27; 添加轨道控制器 1const controls = new OrbitControls( camera, renderer.domElement ); 在动画函数中使用 123456789function animate( time) &#123; mesh.rotation.x = time / 2000; mesh.rotation.y = time / 1000; controls.update() renderer.render( scene, camera ); &#125; 添加阻尼 12controls.enableDamping = truecontrols.dampingFactor = 0.01 自动旋转 12controls.autoRotate = truecontrols.autoRotateSpeed = 1.2","tags":["three.js"],"categories":["前端进阶"]},{"title":"three.js常见知识点","path":"/2024/06/14/74/","content":"添加三维坐标123const axesHelper = new THREE.AxesHelper(5)axesHelper.position.y = 1scene.add(axesHelper) 修改背景颜色1scene.background = new THREE.Color(&quot;#9aa7b1&quot;) 雾12// 第一个参数是雾的颜色，第二个是雾的最小距离，第三个是雾的最大距离scene.fog = new THREE.Fog(&quot;#f5f3f2&quot;, 10, 15) 添加背景图片素材网站：Poly Haven 素材分割：HDRI to CubeMap (matheowis.github.io) 注意：必须使用正方形图片才能生效!!! 1234567// 创建一个立方体纹理,左右上下前后const cubeTexture = new THREE.CubeTextureLoader().setPath(&#x27;/textures/&#x27;).load([ &quot;px.png&quot;, &quot;nx.png&quot;, &quot;py.png&quot;, &quot;ny.png&quot;, &quot;pz.png&quot;, &quot;nz.png&quot;])scene.background = cubeTexture 材质贴图123456// 创建一个纹理const texture = new THREE.TextureLoader().load(&quot;/star.jpg&quot;)// 基础材质const material = new THREE.MeshBasicMaterial(&#123;\tmap: texture&#125;) 环境贴图123456789// 创建一个立方体纹理,左右上下前后const cubeTexture = new THREE.CubeTextureLoader().setPath(&#x27;/textures/&#x27;).load([ &quot;px.png&quot;, &quot;nx.png&quot;, &quot;py.png&quot;, &quot;ny.png&quot;, &quot;pz.png&quot;, &quot;nz.png&quot;])const material = new THREE.MeshBasicMaterial(&#123;\tenvMap: cubeTexture&#125;) 将物体变为线框材质1material.wireframe = true BufferGeometry自定义几何体 第一种方式 12345678910const geometry = new THREE.BufferGeometry()const float32Array = new Float32Array([ 0,0,1, 1,0,1, 1,1,1, 1,1,1, 0,1,1, 0,0,1])geometry.setAttribute(&quot;position&quot;,new THREE.BufferAttribute(float32Array,3)) 预览： 第二种方式 前面那种方式发现在绘制点的时候，会有一些重复的点，可以采用索引的方式进行绘制 123456789101112131415const geometry = new THREE.BufferGeometry()const float32Array = new Float32Array([ 0,0,1, 1,0,1, 1,1,1, // 1,1,1, 0,1,1, // 0,0,1])geometry.setAttribute(&quot;position&quot;,new THREE.BufferAttribute(float32Array,3))// 创建一个索引const indexs = new Uint16Array([ 0,1,2,2,3,0])geometry.index = new THREE.BufferAttribute(indexs,1) 自定义uv坐标如果你想要显示纹理图片的某一个部分，而不是全部显示，就可以考虑使用这个 123456789// 定义uv像素的取值范围 左上 右上 左下 右下const uv = new Float32Array([ 0.5,1, 1,1, 0.5,0, 1,0])geometry.attributes.uv = new THREE.BufferAttribute(uv,2) 环境光源与点光源预览： 添加环境光源 123// 颜色，光照强度const light = new THREE.AmbientLight(&quot;#ecf0f1&quot;,1)scene.add(light) 添加点光源 123const pointLight = new THREE.PointLight(&quot;#ffffff&quot;,100,100)pointLight.position.set(5,5,5)scene.add(pointLight) 设置阴影效果 正方体的设置： 1234// 物体接受光源mesh.receiveShadow = true// 物体投射光源mesh.castShadow = true 地面的设置： 1meshfloor.receiveShadow = true 点光源的设置： 1pointLight.castShadow = true 渲染器的设置： 1renderer.shadowMap.enabled=true 全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;template&gt; &lt;div id=&quot;canvas&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;js&quot;&gt;import * as THREE from &#x27;three&#x27;;import &#123; onMounted &#125; from &quot;vue&quot;// 引入轨道控制器import &#123; OrbitControls &#125; from &#x27;@/assets/js/OrbitControls.js&#x27;const width = document.documentElement.clientWidthconst height = document.documentElement.clientHeight// 创建3d场景const scene = new THREE.Scene()// 创建3维坐标const axesHelper = new THREE.AxesHelper(5)scene.add(axesHelper)// 创建相机const camera = new THREE.PerspectiveCamera(60, 2, 0.1, 500)camera.position.z = 7camera.position.y = 3// 创建正方体const geometry = new THREE.BoxGeometry(1,1,1)// 创建地面const geometryFloor = new THREE.PlaneGeometry(10,10)// 添加灯光效果// 环境光const light = new THREE.AmbientLight(&quot;#ecf0f1&quot;,1)scene.add(light)// 点光源const pointLight = new THREE.PointLight(&quot;#ffffff&quot;,100,100)pointLight.position.set(5,5,5)pointLight.castShadow = truescene.add(pointLight)// 基础材质const material = new THREE.MeshPhongMaterial(&#123; color: &quot;#54a0ff&quot;, // 灯光打到物体上的高亮程度，越高的值越闪亮 shininess: 500&#125;)// 基础材质const materialFloor = new THREE.MeshPhongMaterial(&#123; color: &quot;#bdc3c7&quot;&#125;)// 网格const mesh = new THREE.Mesh(geometry, material)const meshfloor = new THREE.Mesh(geometryFloor, materialFloor)mesh.position.set(0, 0.5, 0)// 物体接受光源mesh.receiveShadow = true// 物体投射光源mesh.castShadow = truemeshfloor.rotation.x -= Math.PI / 2meshfloor.receiveShadow = truescene.add(mesh)scene.add(meshfloor)// 创建渲染器const renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125;)// 调整渲染器大小renderer.setSize(width, height)// 阴影投射renderer.shadowMap.enabled=trueonMounted(() =&gt; &#123; // 添加动画 renderer.setAnimationLoop(animate) document.querySelector(&#x27;#canvas&#x27;).appendChild(renderer.domElement) // 添加轨道控制器 const controls = new OrbitControls(camera, renderer.domElement); // 动画函数 function animate(time) &#123; // mesh.rotation.x = time / 2000; // mesh.rotation.y = time / 1000; controls.update() renderer.render(scene, camera); &#125;&#125;)// 添加网格地面// const gridHelper = new THREE.GridHelper(10, 10)// scene.add(gridHelper)// 进行渲染renderer.render(scene, camera)&lt;/script&gt;&lt;style&gt;&lt;/style&gt;","tags":["three.js"],"categories":["前端进阶"]},{"title":"使用docker镜像nginx进行项目部署","path":"/2024/06/13/71/","content":"准备阶段 准备任意一个项目，或者直接一个html文件 下载docker，自行前往官网进行下载 可以提前了解一下docker的数据卷挂载，可以将宿主机文件与docker容器中的文件进行一个同步，方便对nginx进行配置与日志查看 这篇教程不适合对docker完全不懂的人，不然你很难理解，甚至难以感受到docker进行项目部署的方便 我这里使用的是windows11操作系统进行演示，虽然docker有可视化窗口，但是我这里主要使用命令的形式教大家进行部署，我这里使用的是react项目 下载nginx1docker pull nginx 我的nginx版本为：1.27.0，不同版本的nginx目录结构可能有所不同 在项目中新建一个目录nginx这个目录下在新建conf，logs目录，用来存放配置文件和日志文件 启动nginx容器1docker run -d -p 80:80 -v D:\\我的项目\\react项目之博客后台系统\\App ginx\\logs:/var/log/nginx -v D:\\我的项目\\react项目之博客后台系统\\App ginx\\conf:/etc/nginx/conf.d -v D:\\我的项目\\react项目之博客后台系统\\App\\dist:/usr/share/nginx/html/dist nginx 此时项目中的conf，logs，dist目录就已经和容器中同步了 在conf目录下新建一个default.conf文件，可以看到容器中也多了一个： 到这里就快成功了 编辑default.conf文件： 1234567891011121314151617181920212223server &#123; listen 80; listen [::]:80; server_name localhost; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html/dist; index index.html index.htm; # 解决路由模式为history报404错误 try_files $uri $uri/ /index.html; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 配置文件修改必需重启容器后才生效哦 1docker restart 容器ID或者容器名 或者可视化界面中： 测试是否成功访问 http://localhost/","tags":["Docker"],"categories":["全栈工程师"]},{"title":"使用three.js创建一个最基础的3d场景","path":"/2024/06/13/72/","content":"效果图 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import * as THREE from &#x27;three&#x27;;const width = document.documentElement.clientWidthconst height = document.documentElement.clientHeight// 创建3d场景const scene = new THREE.Scene()// 创建相机const camera = new THREE.PerspectiveCamera()camera.position.z = 7camera.position.y = 3// 创建立方体const boxGeometry = new THREE.BoxGeometry(0.5,0.5,0.5)// 基础材质const material = new THREE.MeshBasicMaterial(&#123; color: &quot;#70a1ff&quot; &#125;)// 网格const mesh = new THREE.Mesh(boxGeometry,material)mesh.position.set(0, 3, 0)scene.add(mesh)// 创建渲染器const renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125;)// 调整渲染器大小renderer.setSize(width, height)// 添加动画renderer.setAnimationLoop(animate)document.body.appendChild(renderer.domElement)// 添加网格地面const gridHelper = new THREE.GridHelper(10, 10)scene.add(gridHelper)// 进行渲染renderer.render(scene, camera)// 动画函数function animate(time) &#123; mesh.rotation.x = time / 2000; mesh.rotation.y = time / 1000; renderer.render( scene, camera );&#125;","tags":["three.js"],"categories":["前端进阶"]},{"title":"Docker安装mysql","path":"/2024/06/12/69/","content":"要达到的目的 实现mysql安装，并且能让外部进行连接 实现数据卷的挂载，让容器被删除时，数据不会丢失 解决无法插入中文数据，或者中文乱码 1docker pull mysql 启动mysql1docker run -d -p 3306:3306 --privileged=true -v /root/mysql/log:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 查看数据卷是否挂载成功 进入mysql容器1docker exec -it 49aecf50ef9c /bin/bash 基础操作： 外部连接数据库自己下载数据库连接工具，例如：Navicat 查看本机地址 1ip addr 使用navicat连接： 插入中文数据看看发现无法插入中文数据 原因： 查看数据库默认字符集： 1SHOW VARIABLES LIKE &#x27;character_set_%&#x27;; 发现是latin1,而不是utf8 将字符集修改为utf-8格式: 修改配置文件（&#x2F;root&#x2F;mysql&#x2F;conf）： 在&#x2F;root&#x2F;mysql&#x2F;conf 目录下新建一个my.cnf文件使用vim进行编辑： 12345[client]default_character_set=utf8[mysqld]collation_server = utf8_general_cicharacter_set_server = utf8 然后重启mysql容器 1docker restart 容器id/容器名 然后再新建数据库，不能在原有的数据库中测试 再次查看数据库字符集： 发现可以插入中文数据了：","tags":["Docker"],"categories":["全栈工程师"]},{"title":"Dockerfile介绍","path":"/2024/06/12/70/","content":"介绍类似一个构建镜像的清单，docker可以根据这个清单进行镜像的自动化构建 保留字1. FROM指定基础镜像，并且必须是第一条指令 12FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt; 2. MAINTAINER指定作者 1MAINTAINER &lt;name&gt; 3. RUN在构建镜像时需要运行的命令 例如： 12RUN yum -y install vimRUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] # 等价于 RUN ./test.php dev offline 4. CMD容器启动后需要运行的命令 例如： 12CMD echo &quot;hello world&quot;CMD [&quot;catalina.sh&quot;, &quot;run&quot;] 5. ENTRYPOINT容器启动后需要运行的命令，类似于CMD，但是不会被docker run后面的命令覆盖，这些命令参数会被当做参数送给ENTRYPOINT指令指定的程序。 例如： 123456FROM nginx ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参# nginx -c /etc/nginx/nginx.conf 6. ENV在镜像构建时，创建环境变量 例如： 1234ENV MY_PATH /usr/mytest # 使用环境变量WORKDIR $MY_PATH 7. EXPOSE当前容器对外暴露出的端口 例如： 1EXPOSE 80 8. COPY复制本地文件或目录到镜像中 例如： 1COPY 【源路径】【容器路径】 9. ADD将宿主机目录下（或远程文件）的文件拷贝进镜像，且会自动处理URL和解压tar压缩包。 例如： 1ADD https://example.com/file.tar.gz /tmp/ 10. WORKDIR设置工作目录，后续命令将在该目录下执行 例如： 1WORKDIR /app","tags":["Docker"],"categories":["全栈工程师"]},{"title":"Docker常用命令","path":"/2024/06/04/67/","content":"docker 基础命令 启动docker 1systemctl start docker 关闭docker 1systemctl stop docker 重启docker 1systemctl restart docker docker设置随服务启动而自启动 1systemctl enable docker 查看docker 运行状态 1systemctl status docker 如果是在运行中 输入命令后 会看到绿色的active 查看docker 版本号信息 1234docker versiondocker info docker 帮助命令 1docker --help 比如 咱忘记了 拉取命令 不知道可以带哪些参数 咱可以这样使用 1docker pull --help docker 镜像命令 查看自己服务器中docker 镜像列表 1docker images 搜索镜像 12docker search 镜像名docker search --filter=STARS=9000 mysql 搜索 STARS &gt;9000的 mysql 镜像 拉取镜像 不加tag(版本号) 即拉取docker仓库中 该镜像的最新版本latest 加:tag 则是拉取指定版本 12docker pull 镜像名 docker pull 镜像名:tag 比如拉取ubuntu： 删除镜像 删除一个： 1docker rmi -f 镜像名/镜像ID 删除多个 其镜像ID或镜像用用空格隔开即可 1docker rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID 删除全部镜像 -a 意思为显示全部, -q 意思为只显示ID 1docker rmi -f $(docker images -aq) 强制删除镜像 1docker image rm 镜像名称/镜像ID 保存镜像 将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这个镜像 1docker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字 加载镜像 任何装 docker 的地方加载镜像保存文件,使其恢复为一个镜像 1docker load -i 镜像保存文件位置 容器命令 通过镜像运行一个容器 1docker run 镜像名字 查看正在运行的容器 12345678docker ps常用参数：-a :列出当前所有的容器-l :显示最近创建的容器。-n nu：显示最近nu个创建的容器。-q :静默模式，只显示容器编号。 运行容器时的常用参数 -it: 命令交互式 比如运行ubuntu 1docker run -it ubuntu 退出交互： 输入exit：容器也会停止运行 输入ctrl+p+q: 容器不会停止运行 -d: 后台守护式 比如运行redis： 1docker run -d redis 进入正在运行的容器并以命令行交互 12345# 这种方式会打开新的终端，并且可以启动新的进程，用exit退出，不会导致容器的停止docker exec -it 容器ID/容器名称 /bin/bash# 直接进入容器启动命令的终端，不会启动新的进程，用exit退出，会导致容器的停止docker attach 容器ID 比如进入redis： 停止容器 1docker stop 容器ID或者容器名 强制停止容器 1docker kill 容器ID或容器名 启动已停止运行的容器 1docker start 容器ID或者容器名 重启容器 1docker restart 容器ID或者容器名 删除已停止的容器 123456789#删除一个docker rm 容器ID docker rm -f 容器ID #强制删除 #删除多个docker rm -f $(docker ps -a -q)或docker ps -a -q | xargs docker rm 查看容器日志 1docker logs 容器ID 查看容器内运行的进程 1docker top 容器ID 查看容器内部细节 查看其json文件 1docker inspect 容器ID 从容器内拷贝文件到主机上 1234docker cp 容器ID:容器内路径 目的主机路径例如：docker cp 3d26bf46bbb0:/home/ubuntu/a.txt /root/test 导入和导出容器 12docker export 容器ID &gt; 文件名.tarcat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号 挂载数据卷 如何理解 就是宿主机与docker容器之间的文件进行一个同步操作，例如：当我指定某个宿主机目录与docker容器中的某个目录进行数据卷挂载的时候，那么无论是我操作宿主机中的这个目录，还是docker容器中的目录时，他们之间都会进行数据共享，使两者目录的内容保持一致 数据卷的特点 数据卷可在容器之间共享或重用数据 卷中的更改可以直接生效 数据卷中的更改不会包含在镜像的更新中 数据卷的生命周期一直持续到没有容器使用它为止 使用： 首先在宿主机上面创建一个目录tmp，方便后续测试 以数据卷挂载的方式运行一个ubuntu容器 1docker run -it -v /root/tmp:/tmp ubuntu 解释： -v &#x2F;root&#x2F;tmp:&#x2F;tmp：-v就是指定需要进行数据卷挂载，冒号左边的是宿主机目录，右边是docker容器目录 运行成功后应该会看到一个tmp目录, cd进去 创建一个test.txt文件 返回宿主机目录发现在tmp目录下出现了一个test.txt文件 再到宿主机上面创建一个host.txt 然后再查看docker中是否数据进行了同步更新 到这里就完成了宿主机与docker容器中的一个数据同步更新了 自己提交一个镜像我们运行的容器可能在镜像的基础上做了一些修改，有时候我们希望保存起来，封装成一个更新的镜像，这时候我们就需要使用 commit 命令来构建一个新的镜像 1docker commit -m=&quot;提交信息&quot; -a=&quot;作者信息&quot; 容器名/容器ID 提交后的镜像名:Tag 本地镜像发布到阿里云首先登录阿里云，然后进入控制台 然后可以在快捷入口这里添加一个容器镜像服务 点击进去选择个人版或者企业版即可 然后设置密码： 创建命名空间： 接着创建镜像仓库： 最后会给你一个操作指南，跟着做就行","tags":["Docker"],"categories":["全栈工程师"]},{"title":"Centos7安装Docker","path":"/2024/06/03/66/","content":"原文地址在：https://blog.csdn.net/qq_26400011&#x2F;article&#x2F;details&#x2F;113856681 卸载系统上原有的Docker12345678yum remove docker \\&gt; docker-client \\&gt; docker-client-latest \\&gt; docker-common \\&gt; docker-latest \\&gt; docker-latest-logrotate \\&gt; docker-logrotate \\&gt; docker-engine 安装需要的安装包yum-utils1yum install -y yum-utils 设置镜像仓库地址 docker默认的官方仓库地址 123yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo ##此地址为官方的仓库地址，在国内建议不要用 阿里云的镜像仓库地址 123yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装docker相关的引擎 先更新yum软件包索引 12yum makecache fase docker社区、ee企业版 ce为社区版 官方推荐使用ce版，默认安装最新的docker版本，也可以指定版本安装 1yum install docker-ce docker-ce-cli containerd.io 启动docker12systemctl start docker 使用hello-world镜像测试docker12docker run hello-world 卸载docker 卸载依赖 12yum remove docker-ce docker-ce-cli containerd.io 删除资源 12rm -rf /var/lib/docker","tags":["Docker"],"categories":["全栈工程师"]},{"title":"js中判断数据类型的方法","path":"/2024/05/29/65/","content":"typeof这种方法存在缺陷，在js中数组[], 也视为对象{}，所以无法区分数组与对象 1234567let obj = &#123;&#125;let arr = []let str = &#x27;&#x27;console.log(typeof obj) // objectconsole.log(typeof arr) // objectconsole.log(typeof str) // string toString()对于任何对象，obj.proto 指向该对象的原型对象（即构造函数的 prototype 属性所指向的对象） 1234567let obj = &#123;&#125;let arr = []let str = &#x27;&#x27;console.log(obj.__proto__.toString()) // [object Object]console.log(arr.__proto__.toString()) // &#x27;&#x27;console.log(str.__proto__.toString()) // &#x27;&#x27; constructor在JavaScript中，constructor 属性是一个预定义在大多数对象的原型（prototype）上的属性，它指向创建该对象实例的构造函数 1234567let obj = &#123;&#125;let arr = []let str = &#x27;&#x27;console.log(obj.constructor) // ƒ Object() &#123; [native code] &#125;console.log(arr.constructor) // ƒ Array() &#123; [native code] &#125;console.log(str.constructor) // ƒ String() &#123; [native code] &#125;","tags":["js"],"categories":["前端3大件"]},{"title":"js中的微任务与宏任务","path":"/2024/05/28/64/","content":"微任务 Promise callbacks: 包括.then, .catch, 和 .finally的回调函数。 async/await: 当使用await关键字等待一个Promise时，后续的代码作为微任务执行。 MutationObserver: 用于监视DOM树的变化，其回调函数作为微任务执行。 queueMicrotask: 在某些环境中（如Node.js），这是一个直接将函数放入微任务队列的方法。 process.nextTick（Node.js环境）: 虽然不直接属于ES规范中的微任务，但它具有类似的行为，常用于Node.js中立即执行的回调。 宏任务 setTimeout 和 setInterval: 用于延迟或周期性执行代码。 setImmediate（Node.js环境）: 提供了一个比setTimeout(0)更快的执行方式，用于在I&#x2F;O循环的下一次迭代开始时执行。 I/O: 如文件读写等操作通常作为宏任务调度。 UI Rendering: 浏览器中的渲染任务，如对DOM的修改触发的重绘和回流。 Event Loop Iteration: 每次事件循环的迭代本身也可以视为一个宏任务。 requestAnimationFrame: 用于在下一次浏览器重绘之前执行回调，常用于动画和高性能UI更新。 script: 整体的JavaScript脚本执行也是一个宏任务。","tags":["js"],"categories":["前端3大件"]},{"title":"为git配置代理(解决开启科学上网后，push报错问题)","path":"/2024/05/22/63/","content":"本文参考至: 解决挂着Clash的时候git操作push失败的问题-CSDN博客 问题源当开启Clash后，本机网络会被代理，此时可以在 设置-网络-代理 中看到： 失败的原因就是本机开启了代理，而git没有设置代理，导致443端口转发不过去 解决设置代理: 12git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy http://127.0.0.1:7890 取消和查看代理: 12345678910取消代理git config --global --unset http.proxygit config --global --unset https.proxy查看代理git config --global --get http.proxygit config --global --get https.proxygit config --list","tags":["git"],"categories":["前端进阶"]},{"title":"vue3扩展学习","path":"/2024/05/20/62/","content":"createApp()创建一个应用实例。 1function createApp(rootComponent: Component, rootProps?: object): App 第一个参数是根组件。第二个参数可选，它是要传递给根组件的 props。 app.component()如果同时传递一个组件名字符串及其定义，则注册一个全局组件；如果只传递一个名字，则会返回用该名字注册的组件 (如果存在的话)。 1234interface App &#123; component(name: string): Component | undefined component(name: string, component: Component): this&#125; app.directive()如果同时传递一个名字和一个指令定义，则注册一个全局指令；如果只传递一个名字，则会返回用该名字注册的指令 (如果存在的话)。 1234interface App &#123; directive(name: string): Directive | undefined directive(name: string, directive: Directive): this&#125; app.provide()提供一个值，可以在应用中的所有后代组件中注入使用。 app.version获取当前vue的版本号 app.config.errorHandler用于为应用内抛出的未捕获错误指定一个全局处理函数。 123456789interface AppConfig &#123; errorHandler?: ( err: unknown, instance: ComponentPublicInstance | null, // `info` 是一个 Vue 特定的错误信息 // 例如：错误是在哪个生命周期的钩子上抛出的 info: string ) =&gt; void&#125; app.config.warnHandler用于为 Vue 的运行时警告指定一个自定义处理函数。 1234567interface AppConfig &#123; warnHandler?: ( msg: string, instance: ComponentPublicInstance | null, trace: string ) =&gt; void&#125; app.config.globalProperties一个用于注册能够被应用内所有组件实例访问到的全局属性的对象。 这是对 Vue 2 中 Vue.prototype 使用方式的一种替代，此写法在 Vue 3 已经不存在了。与任何全局的东西一样，应该谨慎使用。 如果全局属性与组件自己的属性冲突，组件自己的属性将具有更高的优先级。 1app.config.globalProperties.msg = &#x27;hello&#x27; 选项式中使用 12345export default &#123; mounted() &#123; console.log(this.msg) // &#x27;hello&#x27; &#125;&#125; 组合式中使用 1234import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;;const instance = getCurrentInstance()console.log(instance.appContext.config.globalProperties.msg) isRef()检查某个值是否为 ref。","tags":["vue"],"categories":["前端进阶"]},{"title":"react易忘知识点","path":"/2024/05/20/68/","content":"组件通信1.父传子123456789101112131415161718function Children(props)&#123; return( &lt;div&gt;我是孩子:&#123;props.msg&#125;&lt;/div&gt; )&#125;function App()&#123; const msg = &#x27;传递给孩子的东西&#x27; return( &lt;div&gt; &lt;Children msg=&#123;msg&#125;&gt;&lt;/Children&gt; &lt;/div&gt; )&#125;export default App 2.子传父就是在传递props的时候，传递一个函数 123456789101112131415161718192021222324252627282930import &#123; useEffect &#125; from &quot;react&quot;import &#123; useState &#125; from &quot;react&quot;function Children(props)&#123; const msg = &#x27;传递给父亲的东西&#x27; const &#123;onMsg&#125; = props useEffect(()=&gt;&#123; onMsg(msg) &#125;,[]) return( &lt;div&gt;我是孩子:&lt;/div&gt; )&#125;function App()&#123; let [data, setData] = useState() const msg = (value)=&gt;&#123; setData(value) &#125; return( &lt;div&gt; &lt;Children onMsg=&#123;msg&#125;&gt;&lt;/Children&gt; &lt;h6&gt;&#123;data&#125;&lt;/h6&gt; &lt;/div&gt; )&#125;export default App 3.使用createContext()进行跨级通信12345678910111213141516171819202122232425262728293031323334import &#123; createContext &#125; from &quot;react&quot;import &#123; useContext &#125; from &quot;react&quot;const MsgContext = createContext()function Demo1()&#123; return( &lt;div&gt;demo1 &lt;Demo2&gt;&lt;/Demo2&gt; &lt;/div&gt; )&#125;function Demo2()&#123; const msg = useContext(MsgContext) return( &lt;div&gt;demo2:&#123;msg&#125;&lt;/div&gt; )&#125;function App()&#123; const msg = &quot;我是父组件&quot; return( &lt;div&gt; &lt;MsgContext.Provider value=&#123;msg&#125;&gt; this is App &lt;Demo1&gt;&lt;/Demo1&gt; &lt;/MsgContext.Provider&gt; &lt;/div&gt; )&#125;export default App redux的使用首先安装依赖： 1npm i react-redux @reduxjs/toolkit 创建store文件夹，用于配置redux 创建modules目录，用于存放具体模块，创建index.js文件用于集中导出 例如创建一个counterStore.js用于存放计数信息 123456789101112131415161718192021222324252627import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;const counterStore = createSlice(&#123; name: &quot;counter&quot;, // 初始化state initialState: &#123; count: 0 &#125;, // 修改状态的方法 reducers: &#123; inscrement(state)&#123; state.count++ &#125;, descrement(state)&#123; state.count-- &#125;, &#125;&#125;)// 解构actionsconst &#123;inscrement,descrement&#125; = counterStore.actions// 获取reducerconst reducer = counterStore.reducer// 导出export &#123;inscrement,descrement&#125;export default reducer index.js: 12345678910import &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;;import counterReducer from &quot;./modules/counterStore&quot;const store = configureStore(&#123; reducer: &#123; counter: counterReducer &#125;&#125;)export default store 入口文件main.jsx: 1234567891011121314import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom/client&#x27;import App from &#x27;./App.jsx&#x27;import &#x27;./index.css&#x27;import store from &#x27;./store/index.js&#x27;import &#123; Provider &#125; from &#x27;react-redux&#x27;ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;)).render( &lt;React.StrictMode&gt; &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;,) 使用： 12345678910111213141516171819import &#123; useSelector,useDispatch &#125; from &quot;react-redux&quot;import &#123; inscrement,descrement &#125; from &quot;./store/modules/counterStore&quot;function App()&#123; const &#123;count&#125; = useSelector(state=&gt;state.counter) const dispatch = useDispatch() return( &lt;div&gt; &lt;div&gt;使用redux进行状态管理&lt;/div&gt; &lt;div&gt;当前状态&#123;count&#125;&lt;/div&gt; &lt;button style=&#123;&#123;marginRight:10&#125;&#125; onClick=&#123;()=&gt;dispatch(inscrement())&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;()=&gt;dispatch(descrement())&#125;&gt;-&lt;/button&gt; &lt;/div&gt; )&#125;export default App 路由知识安装依赖： 1npm i react-router-dom 新建一个router目录,再新建一个index.js文件用以配置路由 12345678910111213141516import &#123;createBrowserRouter&#125; from &quot;react-router-dom&quot;import Home from &quot;../pages/Home&quot;import About from &quot;../pages/About&quot;const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Home/&gt; &#125;, &#123; path: &quot;/about&quot;, element: &lt;About/&gt; &#125;])export default router main.jsx: 1234567891011import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom/client&#x27;import &#x27;./index.css&#x27;import &#123;RouterProvider&#125; from &quot;react-router-dom&quot;import router from &quot;./router&quot;ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;)).render( &lt;React.StrictMode&gt; &lt;RouterProvider router=&#123;router&#125; /&gt; &lt;/React.StrictMode&gt;)","tags":["react"],"categories":["前端进阶"]},{"title":"webpack基础知识","path":"/2024/04/02/61/","content":"需要安装的模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;name&quot;: &quot;webpack&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.23.9&quot;, &quot;@babel/preset-env&quot;: &quot;^7.23.9&quot;, &quot;add-asset-html-webpack-plugin&quot;: &quot;^6.0.0&quot;, &quot;autoprefixer&quot;: &quot;^10.4.17&quot;, &quot;babel-loader&quot;: &quot;^9.1.3&quot;, &quot;css-loader&quot;: &quot;^6.10.0&quot;, &quot;css-minimizer-webpack-plugin&quot;: &quot;^6.0.0&quot;, &quot;csv-loader&quot;: &quot;^3.0.5&quot;, &quot;dart-sass&quot;: &quot;^1.25.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^5.6.0&quot;, &quot;imports-loader&quot;: &quot;^5.0.0&quot;, &quot;json5&quot;: &quot;^2.2.3&quot;, &quot;mini-css-extract-plugin&quot;: &quot;^2.8.0&quot;, &quot;postcss-loader&quot;: &quot;^8.1.0&quot;, &quot;sass-loader&quot;: &quot;^14.1.0&quot;, &quot;style-loader&quot;: &quot;^3.3.4&quot;, &quot;terser-webpack-plugin&quot;: &quot;^5.3.10&quot;, &quot;toml&quot;: &quot;^3.0.0&quot;, &quot;ts-loader&quot;: &quot;^9.5.1&quot;, &quot;typescript&quot;: &quot;^5.3.3&quot;, &quot;webpack&quot;: &quot;^5.90.0&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^4.10.1&quot;, &quot;webpack-cli&quot;: &quot;^5.1.4&quot;, &quot;webpack-dev-server&quot;: &quot;^4.15.1&quot;, &quot;webpack-merge&quot;: &quot;^5.10.0&quot;, &quot;xml-loader&quot;: &quot;^1.2.1&quot;, &quot;yaml&quot;: &quot;^2.3.4&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;lodash&quot;: &quot;^4.17.21&quot;, &quot;rgb-random-lazychild&quot;: &quot;^1.0.2&quot; &#125;, &quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot; ]&#125; 基本命令打包：npx webpack 服务器启动：npx webpack-dev-server 基本配置webpack的配置文件为：webpack.config.js 123456789101112131415161718192021222324252627282930const path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry: &#x27;./src/index.js&#x27;, //以哪个文件为主 output: &#123; // filename: &#x27;[name].[contenthash].js&#x27;, filename: &#x27;index.js&#x27;, path: path.resolve(__dirname, &#x27;./dist&#x27;), //绝对路径 clean: true, //清理上次打包的文件 &#125;, mode: &#x27;development&#x27;, // 指定运行模式为开发模式 devtool: &#x27;eval-cheap-module-source-map&#x27;, plugins:[ new HtmlWebpackPlugin(&#123; template: &#x27;./index.html&#x27;, filename: &#x27;app.html&#x27;, inject: &#x27;body&#x27; //在body里面生成script标签 &#125;) ], // 配置热更新服务器 devServer: &#123; static: &#x27;./dist&#x27; &#125;,&#125; 静态资源处理1.处理图片文件asset&#x2F;resource: 12345678910111213module: &#123; rules: [ &#123; //处理图片文件 test: /\\.png$/, type: &#x27;asset/resource&#x27;, //类型 // 路径 generator: &#123; filename: &#x27;images/[contenthash][ext]&#x27; &#125; &#125; ]&#125; asset&#x2F;inline: 123456789module: &#123; rules: [ &#123; //处理图片文件 test: /\\.svg$/, type: &#x27;asset/inline&#x27;, //inline类型,将图片变为base64 &#125; ]&#125; asset: 123456789101112131415module: &#123; rules: [ &#123; //处理图片文件 test: /\\.png$/, type: &#x27;asset&#x27;, //类型：自动选择：默认如果大于8k--&gt;本地资源，否则就是inline类型 // 自定义 parser: &#123; dataUrlCondition: &#123; maxSize: 4 * 1024 * 1024 //如果图片大于4M，那么就作为本地资源，否则就是inline类型 &#125; &#125; &#125; ]&#125; 2.处理纯文本123456789module: &#123; rules: [ &#123; //处文本文件 test: /\\.txt$/, type: &#x27;asset/source&#x27;, //类型 &#125; ]&#125; 3.处理字体文件12345678910111213module: &#123; rules: [ &#123; // 加载字体 test: /\\.(woff|woff2|eot|ttf|otf)$/, type: &#x27;asset/resource&#x27;, // 路径 generator: &#123; filename: &#x27;iconFont/[contenthash][ext]&#x27; &#125; &#125; ]&#125; 4.其它文件的处理12345678910111213141516171819202122232425262728293031323334module: &#123; rules: [ &#123; test: /\\.toml$/, type: &#x27;json&#x27;, // 指定解析器 parser: &#123; parse: toml.parse, &#125; &#125;, &#123; test: /\\.yaml$/, type: &#x27;json&#x27;, parser: &#123; parse: yaml.parse, &#125; &#125;, &#123; test: /\\.json5$/, type: &#x27;json&#x27;, parser: &#123; parse: json5.parse, &#125; &#125;, &#123; test: /\\.csv$/, use: &#x27;csv-loader&#x27; &#125;, &#123; test: /\\.xml$/, use: &#x27;xml-loader&#x27; &#125; ],&#125;, babel-loader这个可以将ES6转ES5 1234567891011121314151617181920// 需要安装的库/** * 1. babel-loader: 用于处理es6语法 * 2. @babel/core: babel核心库 * 3. @babel/preset-env: babel预设库, 一组babel插件集合 */module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;] &#125; &#125; &#125; ]&#125; 代码分离防止引入的第三方库重复导出 内置模块处理： 12345optimization: &#123; splitChunks: &#123; chunks: &#x27;all&#x27; //对所有模块进行分割 &#125;&#125; 使用dependOn: 1234567891011121314module.exports = &#123; // 多个入口文件 entry: &#123; index: &#123; import: &#x27;./src/index.js&#x27;, dependOn: &#x27;comment&#x27; &#125;, another: &#123; import: &#x27;./src/another.js&#x27;, dependOn: &#x27;comment&#x27; &#125;, comment: &#x27;lodash&#x27; &#125;, &#125; 预获取和预加载预获取 prefetch: 在浏览器加载完必要的资源后，空闲时就会去获取可能需要的资源。 预加载 preload: 预先加载当前页面可能需要的资源， 它会与必要资源并行请求。 12345678/* webpackPrefetch: true *//* webpackPreload: true */btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; import(/* webpackPrefetch: true */&#x27;./math&#x27;).then((&#123;add&#125;)=&gt;&#123; console.log(add(4,8)) &#125;)&#125;) 缓存第三方库1234567891011optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &#x27;vendors&#x27;, chunks: &#x27;all&#x27; &#125; &#125; &#125;&#125; 公共路径123456output: &#123; filename: &#x27;index.js&#x27;, path: path.resolve(__dirname, &#x27;./dist&#x27;), //绝对路径 clean: true, //清理上次打包的文件 publicPath: &#x27;http://127.0.0.1:5500/公共路径/dist/&#x27; //设置打包后的文件访问路径&#125;, 动态改变mode123module.exports = (env) =&gt; &#123; mode: env.production ? &#x27;production&#x27; : &#x27;development&#x27;, // 如果要压缩, 则需要生产环境&#125; 配置文件的拆分与合并12345678910111213141516const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;);const configDev = require(&#x27;./webpack.config.dev&#x27;);const configPro = require(&#x27;./webpack.config.pro&#x27;);const configCommon = require(&#x27;./webpack.config.common&#x27;);module.exports = (env) =&gt;&#123; switch(true)&#123; case env.development: return merge(configDev, configCommon); case env.production: return merge(configPro, configCommon); default: return new Error(&#x27;No valid environment&#x27;); &#125;&#125; 路径别名12345resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;) &#125;&#125; 外部扩展1234567externalsType: &quot;script&quot;,externals: &#123; jquery: [ &quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js&quot;, &quot;$&quot; ]&#125; 这样就可以直接使用了： 12import $ from &#x27;jquery&#x27;console.log($) 依赖分析图使用插件：webpack-bundle-analyzer 123456const &#123; BundleAnalyzerPlugin &#125; = require(&#x27;webpack-bundle-analyzer&#x27;) //依赖图插件module.exports = &#123; plugins:[ new BundleAnalyzerPlugin() ],&#125; css的自动兼容123456789101112module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125; ]&#125; css模块化12345678910111213141516module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; modules: true &#125; &#125; ] &#125; ]&#125; 解析sass1234567891011121314module: &#123; rules: [ &#123; // 加载css或者scss文件 test: /\\.(css|scss)$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;,&#123; loader: &#x27;sass-loader&#x27;, options: &#123; implementation: require(&#x27;dart-sass&#x27;) &#125; &#125;] //顺序不能改，，从数组后往前进行加载 &#125; ]&#125; 抽离与压缩css需要生产环境 123456789101112131415161718192021222324252627const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;) //提取cssconst CssMinimizerPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;) //压缩cssmodule.exports = &#123; plugins:[ // 提取css new MiniCssExtractPlugin(&#123; filename: &#x27;styles/[contenthash].css&#x27; //生成的css位置与css文件名字 &#125;) ], module: &#123; rules: [ &#123; // 加载css或者scss文件 test: /\\.(css|scss)$/, use: [MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;,&#123; loader: &#x27;sass-loader&#x27;, options: &#123; implementation: require(&#x27;dart-sass&#x27;) &#125; &#125;] //顺序不能改，，从数组后往前进行加载 &#125; ] &#125;, optimization: &#123; minimizer: [new CssMinimizerPlugin()] //压缩css &#125; &#125; 压缩js需要生产环境 123456789const terserPlugin = require(&#x27;terser-webpack-plugin&#x27;) //压缩jsmodule.exports = &#123; // 我们发现在使用了css压缩后，js不能进行自动压缩了，所以需要自己配置 optimization: &#123; minimizer: [ new terserPlugin() //压缩js ] &#125; &#125; 解析ts12345678module: &#123; rules: [ &#123; test: /\\.ts$/, use: &#x27;ts-loader&#x27; &#125; ]&#125; shimming预置全局变量123456789const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; plugins:[ new webpack.ProvidePlugin(&#123; _: &#x27;lodash&#x27; &#125;) ],&#125; 使用： 1console.log(_.join([1, 2, 3], &#x27;~&#x27;)) 将this指向为window12345678module: &#123; rules: [ &#123; test: /\\.js$/, use: &#x27;imports-loader?wrapper=window&#x27; &#125; ]&#125; 自建小轮子之library因为webpack打包后的文件都是一个自执行函数，在库外部的任何位置都访问不到它，所以需要配置library 12345678910111213module.exports = &#123; // 如果library的type为module时，必须配置 experiments: &#123; outputModule: true &#125;, output: &#123; library: &#123; // type: &quot;umd&quot; type: &quot;module&quot; &#125;, globalObject: &quot;globalThis&quot; //解决在type: &quot;umd&quot;时，self未定义的问题 &#125;,&#125;","tags":["webpack"],"categories":["前端进阶"]},{"title":"sass基础知识","path":"/2024/03/15/60/","content":"sass中的变量12345$color: var(--color, red);.box&#123; color: $color;&#125; 数据类型 数字，1rem、2vh、13、 10px； 字符串，分有引号字符串与无引号字符串，&quot;foo&quot;、 &#39;bar&#39;、baz； 颜色，blue, #04a3f9, rgba(255,0,0,0.5)； 布尔型，true和false； 空值，null是其类型的唯一值。表示缺少值，通常由函数返回以表示缺少结果； 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em,Helvetica,Arial,sans-serif； maps， 相当于 JavaScript的 object，(key1: value1, key2: value2)； 三元运算符if123.test&#123; z-index: if(false, 1, 2);&#125; @if与@else12345678910$select: false;.box&#123; @if $select&#123; color: red; &#125; @else&#123; color: blue; &#125;&#125; @while12345678$value: 5;@while $value &gt; 0&#123; .number#&#123;$value&#125;&#123; z-index: $value; &#125; $value: $value - 1;&#125; @for12345@for $i from 1 to 4&#123; .title#&#123;$i&#125;&#123; height: 100px * $i; &#125;&#125; @each12345678910$sizes: 40px 60px 80px;@each $size in $sizes &#123; .icon-#&#123;$size&#125; &#123; font-size: $size; height: $size; width: $size; &#125;&#125; 编译后 1234567891011121314151617.icon-40px &#123; font-size: 40px; height: 40px; width: 40px;&#125;.icon-60px &#123; font-size: 60px; height: 60px; width: 60px;&#125;.icon-80px &#123; font-size: 80px; height: 80px; width: 80px;&#125; @function1234567@function qiuHe($number1, $number2)&#123; @return $number1 + $number2;&#125;.test&#123; width: qiuHe(210, 200)+&#x27;px&#x27;;&#125; @mixin12345678910111213141516@mixin theme($color: black)&#123; background-color: $color; color: $color;&#125;body&#123; @include theme(red);&#125;// 编译结果/*body &#123; background-color: red; color: red;&#125;*/ @extend123456789101112131415161718192021.box1&#123; width: 100px; height: 100px;&#125;.box2&#123; @extend .box1; color: red;&#125;// 编译结果/*.box1, .box2 &#123; width: 100px; height: 100px;&#125;.box2 &#123; color: red;&#125;*/ 父选择器&amp;123456789.container &#123; a &#123; color: #333; &amp;:hover &#123; text-decoration: underline; color: #f00; &#125; &#125;&#125; 编译后 1234567.container a &#123; color:#333;&#125;.container a:hover &#123; text-decoration:underline; color:#F00;&#125; !default123456$content: &quot;First content&quot;;// 如果$content之前没定义就使用如下的默认值$content: &quot;Second content&quot; !default;#main &#123; content: $content;&#125; 编译后 123#main &#123; content: &quot;First content&quot;;&#125; @at-root跳出嵌套，在多级嵌套时比较常用 12345678910111213141516.box&#123; width: 100px; height: 100px; @at-root&#123; .contanter&#123; color: aquamarine; &#125; .title&#123; font-size: 20px; @at-root .red&#123; color: red; background-color: red; &#125; &#125; &#125;&#125; 编译后 123456789101112131415.box &#123; width: 100px; height: 100px;&#125;.contanter &#123; color: aquamarine;&#125;.title &#123; font-size: 20px;&#125;.red &#123; color: red; background-color: red;&#125; @use 多处导入，存在样式重复加载。 因为没有命名空间，为了避免撞名，不敢使用简写的 classname，因此起名总是需要注意。 没有私有函数的概念，样式完全暴露在使用import的地方，这对ui库不够友好。 假如我现在有一个入口scss文件，然后还有一个common文件夹，里面有3个文件 common/_1.scss 12345$color1: red;.box1&#123; background-color: $color1;&#125; common/_2.scss 12345$color2: yellow;.box2&#123; background-color: $color2;&#125; common/_index.scss 12345678@use &#x27;./1.scss&#x27; as a;@use &#x27;./2.scss&#x27; as b;body&#123; background-color: a.$color1; color: b.$color2;&#125; 入口文件 12345@use &#x27;./common/index&#x27; as all;.test&#123; width: 100px;&#125; 编译后的结果 12345678910111213141516.box1 &#123; background-color: red;&#125;.box2 &#123; background-color: yellow;&#125;body &#123; background-color: red; color: yellow;&#125;.test &#123; width: 100px;&#125; @forward@forward语句可以引入另一个模块的所有变量、mixins和函数，将它们直接作为当前模块的API暴露出去，不会真的在当前模块增加代码。不同于 @use， @forward不能给变量添加命名空间。 common/_1.scss 12345$color1: red;.box1&#123; background-color: $color1;&#125; common/_2.scss 12345$color2: yellow;.box2&#123; background-color: $color2;&#125; common/_index.scss 123456@forward &#x27;./1&#x27;;@forward &#x27;./2&#x27;;body&#123; color: blue;&#125; 入口文件 123456@use &#x27;./common/forword&#x27; as all;.test&#123; color: all.$color2;&#125; 编译后 123456789101112131415.box1 &#123; background-color: red;&#125;.box2 &#123; background-color: yellow;&#125;body &#123; color: blue;&#125;.test &#123; color: yellow;&#125; 内置函数1. colorscss包含很多操作颜色的函数。例如lighten()与 darken()可用于调亮或调暗颜色，opacify()使颜色透明度减少，transparent()使颜色透明度增加，mix()用来混合两种颜色。 1234567891011121314.p1 &#123; // 让颜色变亮 color:scale-color(#5c7a29, $lightness: +30%);&#125; .p2 &#123; // 让颜色变暗 color:scale-color(#5c7a29, $lightness: -15%);&#125; .p3 &#123; // 降低颜色透明度 color:scale-color(#5c7a29, $alpha: -40%);&#125; 2. List123456789$panding: 10px 20px 30px;.box&#123; padding: append($panding, 100px);//追加 z-index: index($panding, 20px);//返回索引 padding: join(10px 20px, 30px 40px);//合并 z-index: length($panding);//返回长度 width: nth($list: $panding, $n: 3);//返回值 padding: set-nth($list: $panding, $n: 2, $value: 2em);&#125; 3. map12345678910111213141516@use &quot;sass:map&quot;;$map1: (width: 90%, height: 100%, color: #fff);$map2: (border: 1px solid red, backgroud-color: #000);$map3: map.merge($map1, $map2); //合并$map4: map.remove($map: $map1, $key:width); //删除$map5: map.set($map1, &quot;width&quot;, 20%); //设置.box&#123; width: map.get($map:$map1 , $key:width ); //获取 content: map.has-key($map: $map1, $key:color ); //是否存在 content: map.keys($map: $map3); //获取所有键 content: map.keys($map: $map4); content: map.values($map5);&#125; 4. math1234567891011121314@use &#x27;sass:math&#x27;;.test&#123; z-index: math.$pi; z-index: math.ceil($number: 4.2);//向上取整 z-index: math.floor($number: 4.2);//向下取整 width: math.max(10px, 8px, 20px);//返回最大值 width: math.min(10px, 8px, 20px);//返回最小值 z-index: math.round($number: 4.4);//四舍五入 z-index: math.abs($number: -2);//绝对值 z-index: math.pow(2, 3);//2的3次方 z-index: math.sqrt(100);//平方根 z-index: math.random();//随机数&#125; 5. string1234567891011@use &#x27;sass:string&#x27;;$str: &#x27;abcdFG&#x27;;.test::after&#123; content: string.quote(helloWorld);//转为字符串 z-index: string.index($str, &#x27;c&#x27;);//返回对应的索引 z-index: string.length($str);//返回字符串长度 content: string.slice($str, 2, 3);//截取字符串 content: string.to-upper-case($str);//转为大写 content: string.to-lower-case($str);//转为小写 content: string.unique-id();//随机生成的不带引号的字符串&#125;","tags":["sass"],"categories":["前端进阶"]},{"title":"js设计模式","path":"/2024/03/10/59/","content":"工厂模式12345678910111213141516171819202122232425262728293031&lt;!-- 工厂模式：根据不同的输入返回不同类的实例，一般用来创建同一类对象。 --&gt; // 饭店方法function restaurant(menu) &#123; switch (menu) &#123; case &#x27;鱼香肉丝&#x27;: return new YuXiangRouSi(); case &#x27;宫保鸡丁&#x27;: return new GongBaoJiDin(); default: throw new Error(&#x27;这个菜本店没有&#x27;); &#125;&#125;;// 鱼香肉丝类 function YuXiangRouSi() &#123; this.type = &#x27;鱼香肉丝&#x27; &#125;;YuXiangRouSi.prototype.eat = function () &#123; console.log(this.type + &#x27; 真香&#x27;);&#125;;// 宫保鸡丁类 function GongBaoJiDin() &#123; this.type = &#x27;宫保鸡丁&#x27; &#125;;GongBaoJiDin.prototype.eat = function () &#123; console.log(this.type + &#x27; 让我想起了外婆做的菜~&#x27;);&#125;;const dish1 = restaurant(&#x27;鱼香肉丝&#x27;);dish1.eat();// 鱼香肉丝 真香const dish2 = restaurant(&#x27;红烧排骨&#x27;);// Error 这个菜本店没有 建造者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 建造者，汽车部件厂家，提供具体零部件的生产class CarBuilder &#123; constructor(&#123; color = &#x27;white&#x27;, weight = 0 &#125;) &#123; this.color = color; this.weight = weight; &#125; // 生产部件，轮胎 buildTyre(type) &#123; const tyre = &#123;&#125; switch (type) &#123; case &#x27;small&#x27;: tyre.tyreType = &#x27;小号轮胎&#x27; tyre.tyreIntro = &#x27;正在使用小号轮胎&#x27; break case &#x27;normal&#x27;: tyre.tyreType = &#x27;中号轮胎&#x27; tyre.tyreIntro = &#x27;正在使用中号轮胎&#x27; break case &#x27;big&#x27;: tyre.tyreType = &#x27;大号轮胎&#x27; tyre.tyreIntro = &#x27;正在使用大号轮胎&#x27; break &#125; this.tyre = tyre; &#125; // 生产部件，发动机 buildEngine(type) &#123; const engine = &#123;&#125; switch (type) &#123; case &#x27;small&#x27;: engine.engineType = &#x27;小马力发动机&#x27; engine.engineIntro = &#x27;正在使用小马力发动机&#x27; break case &#x27;normal&#x27;: engine.engineType = &#x27;中马力发动机&#x27; engine.engineIntro = &#x27;正在使用中马力发动机&#x27; break case &#x27;big&#x27;: engine.engineType = &#x27;大马力发动机&#x27; engine.engineIntro = &#x27;正在使用大马力发动机&#x27; break &#125; this.engine = engine &#125;&#125;;// 指挥者，负责最终汽车产品的装配class BenChiDirector &#123; constructor(tyre, engine, param) &#123; const car = new CarBuilder(param); car.buildTyre(tyre); car.buildEngine(engine); return car; &#125;&#125;;// 获得产品实例const benchi = new BenChiDirector(&#x27;small&#x27;, &#x27;big&#x27;, &#123; color: &#x27;red&#x27;, weight: &#x27;1600kg&#x27; &#125;); 发布订阅模式12345678910111213141516171819202122232425262728293031323334353637383940414243// 发布、订阅中心class PubSub&#123; #list = [] // 订阅 subscribe(sub)&#123; this.#list.push(sub) &#125; // 发布 publish()&#123; this.#list.forEach(item=&gt;&#123; item.update() &#125;) &#125; // 退订 unsubscribe(sub)&#123; this.#list = this.#list.filter(item=&gt;item!==sub) &#125;&#125;// 订阅者class Subscriber&#123; constructor(name)&#123; this.name = name &#125; // 主要逻辑 update()&#123; console.log(this.name) &#125;&#125;// const pubsub = new PubSub()let subscriber1 = new Subscriber(&#x27;xiaoming&#x27;)let subscriber2 = new Subscriber(&#x27;tiechui&#x27;)// 开始订阅pubsub.subscribe(subscriber1)pubsub.subscribe(subscriber2)// 退订// pubsub.unsubscribe(subscriber1)// 当符合情况时，进行发布pubsub.publish() 单例模式1234567891011121314151617class Single&#123; constructor(name, age)&#123; if(!Single.instance)&#123; this.name = name; this.age = age; Single.instance = this; &#125; return Single.instance; &#125;&#125;let a = new Single(&quot;tom&quot;, 18);let b = new Single(&quot;tiechui&quot;, 28);console.log(a)// Single &#123;name: &#x27;tom&#x27;, age: 18&#125;console.log(b)// Single &#123;name: &#x27;tom&#x27;, age: 18&#125; 适配器模式123456789101112131415161718192021222324252627// 将一个类(对象)的接口(方法、属性)转化为用户需要的另一个接口。解决类(对象)之间接口不兼容的问题class TencentMap&#123; show()&#123; console.log(&#x27;开始渲染腾讯地图&#x27;); &#125;&#125;class BaiduMap&#123; display()&#123; console.log(&#x27;开始渲染百度地图&#x27;); &#125;&#125;// 百度的适配器class BaiduAdapator extends BaiduMap&#123; constructor()&#123; super(); &#125; show()&#123; this.display() &#125;&#125;// 只支持腾讯地图，所以要给百度写一个适配器function renderMap(map)&#123; map.show();&#125;renderMap(new TencentMap());renderMap(new BaiduAdapator()); 装饰器模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 // 前置函数Function.prototype.before = function (fn) &#123; var _this = this; return function () &#123; // 先进行前置函数的调用 fn.apply(this, arguments); // 再调用原函数 return _this.apply(_this, arguments); &#125;&#125;// 后置函数Function.prototype.after = function (fn) &#123; var _this = this; return function () &#123; // 先调用原函数 var result = _this.apply(_this, arguments); // 再进行后置函数的调用 fn.apply(this, arguments); return result; &#125;&#125;function test(params) &#123; console.log(params);&#125;var test1 = test.before(function (params) &#123; console.log(&#x27;前置函数&#x27;); params.token = &#x27;ajsbasczxc&#x27;;&#125;);var test2 = test.after(function (params) &#123; console.log(&#x27;后置函数&#x27;); params.date = new Date()&#125;);test1(&#123; name: &#x27;zhe&#x27;&#125;)/*前置函数index.html:32 &#123;name: &#x27;zhe&#x27;, token: &#x27;ajsbasczxc&#x27;&#125;*/test2(&#123; name: &#x27;zhe&#x27;&#125;)/*&#123;name: &#x27;zhe&#x27;&#125;index.html:39 后置函数*/","tags":["js"],"categories":["前端3大件"]},{"title":"vue3基础知识3","path":"/2024/03/02/58/","content":"slot插槽1. 基本插槽组件： 123456&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 使用者： 123456789&lt;template&gt; &lt;div&gt; &lt;Compo1 title=&quot;游戏列表&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in games&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Compo1&gt; &lt;/div&gt;&lt;/template&gt; 2. 具名插槽组件： 123456&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 使用者： 12345678910111213&lt;template&gt; &lt;div&gt; &lt;Compo1 title=&quot;游戏列表&quot; v-slot:content&gt; &lt;ul&gt; &lt;li v-for=&quot;item in games&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Compo1&gt; &lt;Compo1 title=&quot;美食中国&quot; #content&gt; &lt;img :src=&quot;imgUrl&quot; alt=&quot;&quot;&gt; &lt;/Compo1&gt; &lt;/div&gt;&lt;/template&gt; 3. 作用域插槽组件： 123456&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;slot name=&quot;content&quot; :games=&quot;games&quot; :imgUrl=&quot;imgUrl&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 使用者： 123456789101112&lt;template&gt; &lt;div&gt; &lt;Compo1 title=&quot;游戏列表&quot; v-slot:content = &#x27;params&#x27;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in params.games&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Compo1&gt; &lt;Compo1 title=&quot;美食中国&quot; #content = &#x27;params&#x27;&gt; &lt;img :src=&quot;params.imgUrl&quot; alt=&quot;&quot;&gt; &lt;/Compo1&gt; &lt;/div&gt;&lt;/template&gt; 自定义指令1. 局部注册1234567891011121314&lt;template&gt; &lt;div&gt; &lt;input v-focus type=&quot;text&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;const vFocus = &#123; mounted: (el) =&gt; &#123; el.style.height = &#x27;25px&#x27; el.focus() &#125;&#125;&lt;/script&gt; 2. 全局注册可以自定义一个文件夹directives，将所有指令的逻辑都放在这里 比如我新建一个vFocus.ts文件 123456789const vFocus = &#123; mounted: (el) =&gt; &#123; el.style.height = &#x27;25px&#x27; el.style.border = &#x27;1px dashed black&#x27; el.focus() &#125;&#125;export default vFocus main.js 1234567891011// 引入自定义指令import vFocus from &#x27;@/directives/vFocus&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App);//注册自定义指令 app.directive(&#x27;focus&#x27;, vFocus)app.mount(&#x27;#app&#x27;); shallowRef与shallowReactiveref()与reactive()的浅层作用形式，也就是说只对浅层的数据具有响应式 1234567const state = shallowRef(&#123; count: 1 &#125;)// 不会触发更改state.value.count = 2// 会触发更改state.value = &#123; count: 2 &#125; 123456789101112131415const state = shallowReactive(&#123; foo: 1, nested: &#123; bar: 2 &#125;&#125;)// 更改状态自身的属性是响应式的state.foo++// ...但下层嵌套对象不会被转为响应式isReactive(state.nested) // false// 不是响应式的state.nested.bar++ readonly()与shallowReadonly()readonly()只读代理是深层的：对任何嵌套属性的访问都将是只读的。 1234567891011121314const original = reactive(&#123; count: 0 &#125;)const copy = readonly(original)watchEffect(() =&gt; &#123; // 用来做响应性追踪 console.log(copy.count)&#125;)// 更改源属性会触发其依赖的侦听器original.count++// 更改该只读副本将会失败，并会得到一个警告copy.count++ // warning! 和 readonly() 不同，这里没有深层级的转换：只有根层级的属性变为了只读。 123456789101112131415const state = shallowReadonly(&#123; foo: 1, nested: &#123; bar: 2 &#125;&#125;)// 更改状态自身的属性会失败state.foo++// ...但可以更改下层嵌套对象isReadonly(state.nested) // false// 这是可以通过的state.nested.bar++ toRaw()toRaw() 可以返回由 reactive()、readonly()、shallowReactive() 或者 shallowReadonly() 创建的代理对应的原始对象。 1234const foo = &#123;&#125;const reactiveFoo = reactive(foo)console.log(toRaw(reactiveFoo) === foo) // true markRaw()markRaw 将一个对象标记为不可被转为代理。返回该对象本身。(只对reactive生效) 123456const foo = markRaw(&#123;&#125;)console.log(isReactive(reactive(foo))) // false// 也适用于嵌套在其他响应性对象const bar = reactive(&#123; foo &#125;)console.log(isReactive(bar.foo)) // false customRef()创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。 创建一个hooks： 123456789101112131415161718192021222324import &#123; customRef &#125; from &#x27;vue&#x27;export default function (inputInit, delay) &#123; const input = customRef((track, trigger) =&gt; &#123; let timer return &#123; get() &#123; track() //告诉vue数据inputInit很重要，你要对其进行持续关注，一旦其数据变化就去更新 return inputInit &#125;, set(value) &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; inputInit = value trigger() // 通知vue数据变化了 &#125;, delay) &#125; &#125; &#125;) return &#123; input &#125;&#125; 使用者： 123456789101112&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;input&quot;&gt; &lt;div&gt;&#123;&#123; input &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import useCustomRef from &#x27;./hooks/useCustomRef&#x27;;let &#123;input&#125; = useCustomRef(&#x27;666&#x27;, 2000)&lt;/script&gt; Teleport&lt;Teleport&gt; 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。 12345678&lt;button @click=&quot;open = true&quot;&gt;Open Modal&lt;/button&gt;&lt;Teleport to=&quot;body&quot;&gt; &lt;div v-if=&quot;open&quot; class=&quot;modal&quot;&gt; &lt;p&gt;Hello from the modal!&lt;/p&gt; &lt;button @click=&quot;open = false&quot;&gt;Close&lt;/button&gt; &lt;/div&gt;&lt;/Teleport&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"vue3基础知识2","path":"/2024/02/24/57/","content":"编程式路由导航123456789101112import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter()function handleClick(item: any) &#123; router.push(&#123; path: &#x27;/news/details&#x27;, query: &#123; id: item.id, title: item.title &#125;, &#125;)&#125; pinia存储与读取数据存储： 123456789import &#123; defineStore &#125; from &quot;pinia&quot;export const useTagsStore = defineStore(&#x27;tags&#x27;,&#123; state: ()=&gt;&#123; return &#123; dynamicTags : [&#x27;Tag 1&#x27;, &#x27;Tag 2&#x27;, &#x27;Tag 3&#x27;, &#x27;213&#x27;] &#125; &#125;&#125;) 读取： 1234import &#123; useTagsStore &#125; from &#x27;@/store/tags&#x27;const tagsStore = useTagsStore()const dynamicTags = tagsStore.dynamicTags pinia修改数据的2种方式第一种直接修改： 1tagsStore.dynamicTags.splice(tagsStore.dynamicTags.indexOf(tag),1) 第二种（actions） 1234567891011121314import &#123; defineStore &#125; from &quot;pinia&quot;export const useTagsStore = defineStore(&#x27;tags&#x27;,&#123; state: ()=&gt;&#123; return &#123; dynamicTags : [&#x27;Tag 1&#x27;, &#x27;Tag 2&#x27;, &#x27;Tag 3&#x27;] &#125; &#125;, actions: &#123; changeTags(index)&#123; this.dynamicTags.splice(index,1) &#125; &#125;&#125;) 1tagsStore.changeTags(tagsStore.dynamicTags.indexOf(tag)) getters与storeToRefsgetters类似于计算属性，在store中的写法： 12345678910111213141516171819import &#123; defineStore &#125; from &quot;pinia&quot;export const useTagsStore = defineStore(&#x27;tags&#x27;,&#123; state: ()=&gt;&#123; return &#123; dynamicTags : [&#x27;Tag 1&#x27;, &#x27;Tag 2&#x27;, &#x27;Tag 3&#x27;], &#125; &#125;, actions: &#123; changeTags(index)&#123; this.dynamicTags.splice(index,1) &#125; &#125;, getters: &#123; countTags()&#123; return this.dynamicTags.length + &#x27;&#x27; &#125; &#125;&#125;) storeToRefs的使用： 123456789import &#123; useTagsStore &#125; from &#x27;@/store/tags&#x27;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;const tagsStore = useTagsStore()// 这种方式不可取，因为他会把tagsStore中所有的东西都变成ref// let &#123; dynamicTags, countTags &#125; = toRefs(tagsStore)// 推荐这种let &#123; dynamicTags, countTags &#125; = storeToRefs(tagsStore) pinia中的$subscribe$subscribe可以监听数据的更改： 1234567import &#123; useTagsStore &#125; from &#x27;@/store/tags&#x27;const tagsStore = useTagsStore()tagsStore.$subscribe(()=&gt;&#123; console.log(&quot;tagsStore数据发生改变&quot;)&#125;) 组件通信的方式1. props父： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; 我的好朋友是&#123;&#123; a &#125;&#125; &lt;/div&gt; &lt;Compo1 :name1 = &#x27;name&#x27; :getName = &quot;handleName&quot;&gt;&lt;/Compo1&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;import Compo1 from &#x27;@/components/Compo1.vue&#x27;const name = ref(&quot;索隆&quot;)let a = ref(&#x27;&#x27;)function handleName(data)&#123; a.value = data.value&#125;&lt;/script&gt; 子： 123456789101112131415&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; 我的好朋友&#123;&#123; name1 &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;const name = ref(&quot;路飞&quot;)let props = defineProps([&#x27;name1&#x27;,&#x27;getName&#x27;])props.getName(name)&lt;/script&gt; 2. $refs+$parent父： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;Compo1 ref=&quot;a&quot;&gt;&lt;/Compo1&gt; &lt;Compo2 ref=&quot;b&quot;&gt;&lt;/Compo2&gt; &lt;/div&gt; &lt;button @click=&quot;handleClick($refs)&quot;&gt;点击&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo1 from &#x27;@/components/Compo1.vue&#x27;import Compo2 from &#x27;@/components/Compo2.vue&#x27;import &#123;ref, onMounted&#125; from &#x27;vue&#x27;const a = ref()const b = ref()let x = ref(2)let y = ref(10)function handleClick(refs)&#123; console.log(refs.a.title)&#125;onMounted(()=&gt;&#123; console.log(a.value.title)&#125;)defineExpose(&#123;x,y&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 子： 12345678910111213141516171819202122232425&lt;template&gt; &lt;h2&gt; 子组件1 &lt;/h2&gt; &lt;div&gt; &#123;&#123; title &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;handClick($parent)&quot;&gt;获取父组件信息&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;let title = ref(&quot;哈哈哈哈&quot;)let ppp = ref(2)function handClick(parent)&#123; console.log(parent.y)&#125;defineExpose(&#123;title, ppp&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 3. $attrs父： 123456789101112&lt;template&gt; &lt;div&gt; &lt;Compo2 a=&quot;111&quot; b=&quot;222&quot;&gt;&lt;/Compo2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo2 from &#x27;@/components/Compo2.vue&#x27;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 子： 123456789101112131415&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &#123;&#123; $attrs &#125;&#125; // &#123; &quot;a&quot;: &quot;111&quot;, &quot;b&quot;: &quot;222&quot; &#125; &lt;/div&gt; &lt;Compo1 v-bind=&quot;$attrs&quot;&gt;&lt;/Compo1&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import Compo1 from &#x27;./Compo1.vue&#x27;;const name = ref(&quot;索隆&quot;)&lt;/script&gt; 4. defineEmits自定义事件父： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;Compo2 @custom-event=&quot;send&quot;&gt;&lt;/Compo2&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo2 from &#x27;@/components/Compo2.vue&#x27;import &#123;ref&#125; from &#x27;vue&#x27;let name = ref(&#x27;????&#x27;)function send(data)&#123; // console.log(data) name.value = data&#125;&lt;/script&gt; 子： 12345678910111213141516&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;emit(&#x27;custom-event&#x27;, name)&quot;&gt;发送&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;const name = ref(&quot;索隆&quot;)// 自定义事件const emit = defineEmits([&#x27;custom-event&#x27;])&lt;/script&gt; 5. mitt事件总线安装mitt： 1npm install --save mitt 在文件夹utils中新建文件emitter.ts 12345import mitt from &#x27;mitt&#x27;const emitter = mitt()export default emitter 父： 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;Compo2&gt;&lt;/Compo2&gt; &lt;/div&gt; &lt;span&gt;&#123;&#123; name &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo2 from &#x27;@/components/Compo2.vue&#x27;import emitter from &#x27;@/utils/emitter&#x27;import &#123; ref &#125; from &#x27;vue&#x27;let name = ref(&#x27;???&#x27;)emitter.on(&#x27;send&#x27;, (data: any) =&gt; &#123; // console.log(data.value) name.value = data.value&#125;)&lt;/script&gt; 子： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;send&quot;&gt;发送&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import emitter from &#x27;@/utils/emitter&#x27;const name = ref(&quot;索隆&quot;)function send() &#123; emitter.emit(&#x27;send&#x27;, name)&#125;&lt;/script&gt; 6. provide+inject父： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;Compo1&gt;&lt;/Compo1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo1 from &#x27;@/components/Compo1.vue&#x27;import &#123;ref,provide&#125; from &#x27;vue&#x27;let x = ref(2)let y = ref(10)// 向后代提供数据provide(&#x27;x&#x27;,x)provide(&#x27;y&#x27;,y)&lt;/script&gt; 子： 1234567891011121314151617181920&lt;template&gt; &lt;h2&gt; 子组件1 &lt;/h2&gt; &lt;div&gt; &#123;&#123; title &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref,inject&#125; from &#x27;vue&#x27;let title = ref(&quot;哈哈哈哈&quot;)let m = ref(1)// 接收数据let x = inject(&#x27;x&#x27;,m)let y = inject(&#x27;y&#x27;,m)console.log(x.value,y.value)&lt;/script&gt; 7. v-model我们都知道在input标签上使用v-model，那么如果要想用在组件上，该怎么做呢？ 父： 12345678910111213&lt;template&gt; &lt;div&gt; &lt;Compo2 v-model=&quot;text&quot;&gt;&lt;/Compo2&gt; &#123;&#123; text &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo2 from &#x27;@/components/Compo2.vue&#x27;import &#123; ref &#125; from &#x27;vue&#x27;let text = ref(&#x27;asd&#x27;)&lt;/script&gt; 子： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;!-- 传统写法 --&gt; &lt;!-- &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emit(&#x27;update:modelValue&#x27;, (&lt;HTMLInputElement&gt;$event.target).value)&quot;&gt; --&gt; &lt;!-- 新型写法 --&gt; &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;change&quot;&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;const name = ref(&quot;索隆&quot;)// 传统写法// defineProps([&#x27;modelValue&#x27;])// const emit = defineEmits([&#x27;update:modelValue&#x27;])// 3.4+推荐写法const model = defineModel()function change(e)&#123; model.value = e.target.value&#125;&lt;/script&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"vue3基础知识1","path":"/2024/02/23/56/","content":"toRef与toRefs使用它，消费者组件可以解构&#x2F;展开返回的对象而不会失去响应性： 123456789101112131415import &#123; reactive,toRefs,toRef &#125; from &#x27;vue&#x27;const person = reactive(&#123; name: &#x27;张三&#x27;, age: 18&#125;)const cityObj = reactive(&#123; name: &#x27;北京&#x27;, id: &#x27;asdasxzc&#x27;&#125;)// 消费者组件可以解构/展开返回的对象而不会失去响应性let &#123; name, age &#125; = toRefs(person)let city = toRef(cityObj,&#x27;name&#x27;) computed()函数创建一个只读的计算属性 ref： 123456const count = ref(1)const plusOne = computed(() =&gt; count.value + 1)console.log(plusOne.value) // 2plusOne.value++ // 错误 创建一个可写的计算属性 ref： 12345678910const count = ref(1)const plusOne = computed(&#123; get: () =&gt; count.value + 1, set: (val) =&gt; &#123; count.value = val - 1 &#125;&#125;)plusOne.value = 1console.log(count.value) // 0 watch()函数用于声明在数据更改时调用的侦听回调。 **immediate**：在侦听器创建时立即触发回调。第一次调用时，旧值将为 undefined。 **deep**：如果源是对象或数组，则强制深度遍历源，以便在深度变更时触发回调。详见深层侦听器。 **flush**：调整回调的刷新时机。详见回调的触发时机及 watchEffect()。 **onTrack / onTrigger**：调试侦听器的依赖关系。详见侦听器调试。 监听ref数据时： 12345678910111213let person = ref(&#123; name: &quot;张三&quot;, age: 18&#125;)// 默认是不会开启深度监听的，如果需要开启深度监听，需要在watch中传入deep参数// deep: truewatch(person, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal)&#125;, &#123; deep: true&#125;) 监听reactive数据时： 123456789let person = reactive(&#123; name: &quot;张三&quot;, age: 18&#125;)// 默认开启深度监听,并且无法修改watch(person, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue)&#125;) ​\t监听响应式对象中的单个属性 12345678910111213141516171819202122232425const person = reactive(&#123; name: &#x27;张三&#x27;, age: 18, adress: &#123; city: &#x27;北京&#x27;, street: &#x27;北京路&#x27; &#125;&#125;)// 如果要监听某个属性，可以使用getter函数// 1.如果这个属性值是基本类型，只能写成getter函数watch(()=&gt;person.name, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal)&#125;)/* 2.如果这个属性值是对象，如果写成getter函数， 那么就是监听的地址的变换，里面单个属性变化监听不到，但是可以开启deep，进行深度监听 如果不写成函数，那么就是监听里面单个属性的变化，无法监听地址的变换*/watch(()=&gt;person.adress, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal)&#125;) 监听响应式对象中的单个属性: 1234// 如果要监听多个属性，写成数组即可watch([()=&gt;person.name, ()=&gt;person.adress], (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal)&#125;) watchEffect()函数立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。 与watch的区别：watch需要指定数据源进行监听 12345678let height = ref(0)let weight = ref(0)watchEffect(() =&gt; &#123; if(height.value &gt; 5 &amp;&amp; weight.value &gt; 10)&#123; console.log(&quot;发送服务器消息&quot;) &#125;&#125;) ref与dom结构的联动使用选项式 API，引用将被注册在组件的 this.$refs 对象里： 12&lt;!-- 存储为 this.$refs.p --&gt;&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt; 使用组合式 API，引用将存储在与名字匹配的 ref 里： 123456789&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const p = ref()&lt;/script&gt;&lt;template&gt; &lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;&lt;/template&gt; 用于组件时： 1234567891011121314151617// test组件&lt;template&gt; &lt;h2&gt;我是一个组件&lt;/h2&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;let a = ref(0)let b = ref(1)let c = ref(2)defineExpose(&#123;a,b,c&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button @click=&quot;getDom&quot;&gt;获取dom&lt;/button&gt; &lt;test ref=&quot;tes&quot;&gt;&lt;/test&gt;&lt;/template&gt;import test from &#x27;./components/test.vue&#x27;let tes = ref();// 如果想要获取组件里面的变量，需要组件自行导出function getDom() &#123; console.log(tes.value.a); console.log(tes.value.b); console.log(tes.value.c);&#125; defineProps()12345// 类型限制+默认值+是否必传let props = withDefaults(defineProps&lt;&#123;list?:PersonList&#125;&gt;(),&#123; // 默认值 list:()=&gt;[&#123;id:&#x27;asdasdzxc&#x27;,name:&#x27;海尔&#x27;,age:22&#125;]&#125;) 基本路由123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;import Home from &#x27;@/views/Home.vue&#x27;;import News from &#x27;@/views/News.vue&#x27;;import About from &#x27;@/views/About.vue&#x27;;import NewsDetails from &#x27;@/views/NewsDetails.vue&#x27;;const router = createRouter(&#123; history: createWebHistory(), routes: [ &#123; path: &#x27;/home&#x27;, component: Home, &#125;, &#123; path: &#x27;/news&#x27;, component: News, children: [ &#123; path: &#x27;details&#x27;, component: NewsDetails, &#125;, ], &#125;, &#123; path: &#x27;/about&#x27;, component: About, &#125;, // 重定向 &#123; path: &#x27;/:pathMatch(.*)*&#x27;, redirect: to =&gt; &#123; return &#123; path: &#x27;/home&#x27; &#125;; &#125;, &#125;, ]&#125;)export default router; query传参当我点击某个按钮，让它跳转到新闻详情页面时：&#x2F;news&#x2F;details?id&#x3D;${item.id}&amp;title&#x3D;${item.title} 如何接收传的值呢？ 12345678910111213&lt;template&gt; &lt;div&gt; 新闻详情 &lt;ul&gt; &lt;li&gt;&#123;&#123; route.query.id &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; route.query.title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123;useRoute&#125; from &quot;vue-router&quot;;const route = useRoute();&lt;/script&gt; params传参也就是需要这样传参：&#x2F;news&#x2F;details&#x2F;${item.id}&#x2F;${item.title} 此时要怎样接收参数呢？ 改变路由结构： 12345678910&#123; path: &#x27;/news&#x27;, component: News, children: [ &#123; path: &#x27;details/:id/:title&#x27;, component: NewsDetails, &#125;, ],&#125;, 接收： 123456789101112&lt;template&gt; &lt;div&gt; 新闻详情 &lt;ul&gt; &lt;li&gt;&#123;&#123; route.params.id &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; route.params.title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123;useRoute&#125; from &quot;vue-router&quot;;const route = useRoute(); 路由props配置之前所说的query传参和params传参，在接收时感觉比较繁琐，接下来看看路由props配置，告别繁琐 首先改变路由： 123456789101112131415161718&#123; path: &#x27;/news&#x27;, component: News, children: [ &#123; path: &#x27;details&#x27;, component: NewsDetails, // 第一种params写法 // props: true, // 第二种query写法 props(route)&#123; return route.query; &#125;, &#125;, ],&#125;, 接收： 123456789101112&lt;template&gt; &lt;div&gt; 新闻详情 &lt;ul&gt; &lt;li&gt;&#123;&#123; id &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;defineProps([&#x27;id&#x27;, &#x27;title&#x27;])&lt;/script&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"md文件的解析、渲染与目录文件读取","path":"/2024/02/10/55/","content":"markdown文件内容的读取使用markdown-it的插件 1npm install markdown-it 123456import MarkdownIt from &quot;markdown-it&quot;import contentMd from &quot;@/article/1.md?raw&quot;const markdownit = new MarkdownIt()console.log(markdownit.render(contentMd)) markdown的渲染markdown-it只能将markdown文件转换为html标签，但是没有css样式，网上有很多插件对其进行美化，推荐一个网站：Themes Gallery — Typora 目录文件读取123456const localeResourceFiles = import.meta.glob(&#x27;@/article/*.md&#x27;, &#123; eager: true, import: &#x27;default&#x27;&#125;)console.log(localeResourceFiles)","tags":["vue"],"categories":["前端进阶"]},{"title":"js基础篇4","path":"/2024/02/01/54/","content":"proxy123456789101112131415161718192021222324 let obj = &#123; name: &#x27;tom&#x27;, &#125; // 使用 proxy 监听 obj 的变化 proxy = new Proxy(obj, &#123; get(target, key) &#123; console.log(`get $&#123;key&#125;`) if (key === &#x27;name&#x27;) &#123; a.innerHTML = target[key] &#125; return target[key] &#125;, set(target, key, value) &#123; console.log(`set $&#123;key&#125; = $&#123;value&#125;`) if (key === &#x27;name&#x27;) &#123; a.innerHTML = value &#125; target[key] = value return true &#125; &#125;)proxy.name// get name Reflect配合proxy12345678910111213let obj = &#123;&#125;let proxy = new Proxy(obj, &#123; get(target, key) &#123; console.log(`get $&#123;Reflect.get(target, key)&#125;`) // return Reflect.get(target, key) return Reflect.get(...arguments) &#125;, set(target, key, value) &#123; console.log(`set $&#123;key&#125; = $&#123;value&#125;`) Reflect.set(...arguments) return true &#125;&#125;) promise相关api一个 Promise 必然处于以下几种状态之一： ​ 1.待定（pending）：初始状态，既没有被兑现，也没有被拒绝。 ​ 2.已兑现（fulfilled）：意味着操作成功完成。 ​ 3.已拒绝（rejected）：意味着操作失败。 ajax函数 123456789101112131415function ajax(str, time, isSuccess) &#123; if (isSuccess)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(str); &#125;, time); &#125;); &#125;else&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(str); &#125;, time); &#125;); &#125;&#125; Promise.all() 等待所有 Promise, 在任意一个 Promise 被拒绝时拒绝 123456 Promise.all([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;)// [&#x27;1&#x27;, &#x27;2&#x27;] Promise.race() 看哪一个 Promise 先被执行完，就执行哪一个 Promise 123456Promise.race([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;)// 1 Promise.any() 当输入的任何 promise 实现时，此返回的 promise 将实现，并具有第一个 fulfillation 值。当所有输入的 promise 都拒绝时（包括传递空可迭代对象时），它会拒绝 123456Promise.any([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err, &#x27;拒绝&#x27;)&#125;)// 2 Promise.allSettled() 无论任何 promise 实现，此返回的 promise 都将实现，并具有一个数组，其中包含每个输入 promise 的状态和值。 12345678910Promise.allSettled([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, false)]).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;)/*[&#123;…&#125;, &#123;…&#125;]0: &#123;status: &#x27;rejected&#x27;, reason: &#x27;1&#x27;&#125;1: &#123;status: &#x27;rejected&#x27;, reason: &#x27;2&#x27;&#125;*/","tags":["js"],"categories":["前端3大件"]},{"title":"MongoDB的安装与使用","path":"/2024/01/10/53/","content":"安装下载官网（社区版）：Download MongoDB Community Server | MongoDB 根据自己的操作系统下载即可 配置环境变量（方便后续的启动）找到系统环境变量的编辑界面 添加自己下载好的mongodb的bin路径即可 最后进行测试，输入mongod，没有报错说明配置成功（这个命令主要用来启动mongodb） 启动mongo服务在启动之前必须配置mongo服务数据存放的文件夹，比如我在mongo安装的目录下，新建了一个db文件夹，用来存放数据库内容：D:\\Database\\MongoDB\\db， 启动方法 1mongod --dbpath D:\\Database\\MongoDB\\db 启动后不能关闭终端，不然会中断mongo的服务 node连接mongoDB 这里用express框架进行演示 1. 模块下载1npm i mongoose 2. 连接建议放在单独的一个文件中，方便管理 12345678910111213const mongoose = require(&#x27;mongoose&#x27;);const dbURL = &#x27;mongodb://127.0.0.1:27017/managerCool&#x27;;// 连接数据库mongoose.connect(dbURL);// 绑定数据库连接监听mongoose.connection.on(&quot;open&quot;, (err) =&gt; &#123; if (err) &#123; cosnole.log(&quot;连接失败...&quot;, err); &#125; else &#123; console.log(&quot;mongodb连接成功&quot;); &#125;&#125;) 在入口文件中进行引入即可 12// 连接数据库require(&#x27;../connect_db/mongo&#x27;) 3. 创建模型（需要连接的表）上述步骤已经成功连接到了具体的数据库了，而大家都知道库中是不是有具体的表，这是mysql的称呼，在mongodb中称为模型，建议将所有的创建模型的文件单独存放到一个文件夹中 比如我要连接introduction的模型 12345678910const mongoose = require(&#x27;mongoose&#x27;)const IntroductionType = &#123; title:String, value:String&#125;const IntroductionModel = mongoose.model(&#x27;introduction&#x27;, new mongoose.Schema(IntroductionType))module.exports = IntroductionModel 查询 比如我要查询introduction中的所有内容 12345678910const IntroductionModel = require(&#x27;../model/IntroductionModel&#x27;)router.get(&#x27;/&#x27;, function (req, res, next) &#123; IntroductionModel.find().then(data=&gt;&#123; console.log(data) &#125;) res.send(&#123; ok: 1 &#125;)&#125;); 修改 注意updateOne里面的第二个字段，对应的是new mongoose.Schema(IntroductionType))里面的字段，如果不对应的话是无法修改的哦 123456789101112router.post(&#x27;/api/change/homeData/:id&#x27;, (req, res)=&gt;&#123; IntroductionModel.updateOne(&#123;_id: req.body._id&#125;,&#123; title: req.body.title, value: req.body.value &#125;).then(result=&gt;&#123; console.log(result) res.send(&#123;ok:1&#125;) &#125;).catch(err=&gt;&#123; console.log(err) res.send(&#123;ok:0&#125;) &#125;)&#125;)","tags":["node"],"categories":["前端进阶"]},{"title":"js基础篇3","path":"/2024/01/02/52/","content":"数组扩展 拆分多维数组flat 123let arr = [1,2,[3,4,[5,6]]]console.log(arr.flat(2))// [1, 2, 3, 4, 5, 6] 数组元素修改fill 12345678 /* fill(value) fill(value, start) fill(value, start, end) */let arr = [1, 2, 3, 4, 5]console.log(arr.fill(10, 2))// [1, 2, 10, 10, 10] 只改变数组其中一个元素with 123let arr = [1, 2, 3, 4, 5]console.log(arr.with(1, 100))// [1, 100, 3, 4, 5] 对象扩展1. 判断一个对象是否存在特定属性12345678910111213let obj = &#123; name: &#x27;xiaoming&#x27;, age: 18&#125;// hasOwnPropertyconsole.log(obj.hasOwnProperty(&#x27;name&#x27;))// inconsole.log(&#x27;name&#x27; in obj)// Reflect.has()console.log(Reflect.has(obj, &#x27;name&#x27;)) 2. Object.assign() 拼接 123456789101112let obj1 = &#123; name: &#x27;John&#x27;, age: 30, city: &#x27;New York&#x27;&#125;let obj2 = &#123; age: 25, country: &#x27;USA&#x27;&#125;let obj3 = Object.assign(obj1, obj2)console.log(obj3)// &#123;name: &#x27;John&#x27;, age: 25, city: &#x27;New York&#x27;, country: &#x27;USA&#x27;&#125; 很多人可能会想到这种方式可不可以用来复制一个对象，我告诉你结果：不完全可以，为什么这样说，大家看如下代码： 1234567891011121314let obj4 = &#123; nameValue: &#x27;xiaoming&#x27;, age: 18, get name() &#123; console.log(&#x27;get name&#x27;) &#125;, set name(value) &#123; console.log(&#x27;set name&#x27;) &#125;&#125;let obj5 = &#123;&#125;let obj6 = Object.assign(obj5, obj4)console.log(obj6)// &#123;nameValue: &#x27;xiaoming&#x27;, age: 18, name: undefined&#125; 当这个对象中有get 或者 set 时就不行了 3. getOwnPropertyDescriptors()返回给定对象的所有自有属性描述符 12345678910111213let obj4 = &#123; nameValue: &#x27;xiaoming&#x27;, age: 18, get name() &#123; console.log(&#x27;get name&#x27;) &#125;, set name(value) &#123; console.log(&#x27;set name&#x27;) &#125;&#125;let obj7 = Object.getOwnPropertyDescriptors(obj4)obj7.name.get()// get name 4. Object.keys()​ 返回一个由给定对象自身的可枚举的字符串键属性名组成的数组。 1234567let obj1 = &#123; name: &#x27;John&#x27;, age: 30, city: &#x27;New York&#x27;&#125;console.log(Object.keys(obj1))// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;] 5. Object.values()​ 返回一个由所有自身属性值的数组，包括不可枚举属性值。 12console.log(Object.values(obj1))// [&#x27;John&#x27;, 30, &#x27;New York&#x27;] 6. Object.entries()​ 返回一个数组，包含给定对象自有的可枚举字符串键属性的键值对。 12345678console.log(Object.entries(obj1))/*[ [&#x27;name&#x27;, &#x27;John&#x27;] [&#x27;age&#x27;, 30] [&#x27;city&#x27;, &#x27;New York&#x27;]\t]*/ 7. Object.create​ 以一个现有对象作为原型，创建一个新对象。 1234567891011121314151617181920212223242526 let obj1 = &#123; nameValue: &#x27;John&#x27;, age: 30, city: &#123; name: &#x27;New York&#x27;, population: 800000 &#125;, get name() &#123; console.log(&#x27;get name&#x27;) return this.nameValue &#125;, set name(value) &#123; console.log(&#x27;set name&#x27;) &#125; &#125; let obj3 = Object.create( Object.getPrototypeOf(obj1), Object.getOwnPropertyDescriptors(obj1), );console.log(obj3)// &#123;nameValue: &#x27;John&#x27;, age: 30, city: &#123;…&#125;&#125;console.log(obj3.name)// get name// John 获取css中的变量123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;简单的背景选择&lt;/title&gt; &lt;style&gt; :root&#123; --color: #000; &#125; body&#123; height: 96vh; background-color: var(--color); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;color&quot; id=&quot;color&quot;&gt; &lt;script&gt; // 获取css中变量的值 const rootColor = getComputedStyle(document.documentElement).getPropertyValue(&#x27;--color&#x27;); let colorSelector = document.querySelector(&#x27;#color&#x27;); colorSelector.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; // 通过改变css变量，改变页面背景色 document.documentElement.style.setProperty(&#x27;--color&#x27;, e.target.value); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; class新增 在属性面前在一个#，就是私有属性 1234567891011121314class Person &#123; static a = 1; // 定义私有属性 #privateName = &#x27;tiechui&#x27; constructor(name, age) &#123; this.name = name; this.age = age; this.privateName = this.#privateName &#125; // 定义一个方法 sayHello() &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); &#125;&#125; 静态代码块，当这个类被定义后，代码块会自动执行 1234567class test&#123; static n = 1 static &#123; console.log(&#x27;静态代码块&#x27;, this.n) &#125;&#125;// 静态代码块 1 异步迭代123456789101112131415161718192021222324252627282930313233function ajax(str, time) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(str); &#125;, time); &#125;);&#125;// 迭代器async function* foo() &#123; yield ajax(&#x27;a&#x27;,1000); yield ajax(&#x27;b&#x27;,1000); yield ajax(&#x27;c&#x27;,1000);&#125;let str = &#x27;&#x27;;let Foo = foo();Foo.next().then(res=&gt;&#123; console.log(res);&#125;)// &#123;value: &#x27;a&#x27;, done: false&#125;async function generate() &#123; for await (var val of foo()) &#123; str = str + val; console.log(val); &#125; console.log(str);&#125;generate();// a// b// c// abc 正则扩展123456789let str = &#x27;今天是2023-12-23&#x27;let reg = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;mounth&gt;\\d&#123;1,2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/let reg1 = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;mounth&gt;\\d&#123;1,2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/dconsole.log(reg.exec(str))// [&#x27;2023-12-23&#x27;, &#x27;2023&#x27;, &#x27;12&#x27;, &#x27;23&#x27;, index: 3, input: &#x27;今天是2023-12-23&#x27;, groups: &#123;…&#125;]console.log(reg1.exec(str))// [&#x27;2023-12-23&#x27;, &#x27;2023&#x27;, &#x27;12&#x27;, &#x27;23&#x27;, index: 3, input: &#x27;今天是2023-12-23&#x27;, groups: &#123;…&#125;, indices: Array(4)] 字符串扩展 includes函数可以判断字符串中是否含有指定字符串 123let str = &quot;helloworld&quot;console.log(str.includes(&quot;h&quot;))// true startsWith和endsWith方法可以判断字符串是否以指定字符串开头或结尾 1234567let str = &quot;hello&quot;console.log(str.startsWith(&quot;h&quot;))// trueconsole.log(str.startsWith(&quot;h&quot;, 1))// falseconsole.log(str.endsWith(&quot;o&quot;))// true 字符串的repeat方法可以重复字符串 123456let str = &quot;hello&quot;console.log(str.repeat(3))// hellohellohelloconsole.log(str.repeat(0)===&#x27;&#x27;)// true 字符串的padStart和padEnd方法可以对字符串进行填充 123456let str = &quot;hello&quot;console.log(str.padStart(10, &quot;world&quot;))// worldhelloconsole.log(str.padEnd(10, &quot;world&quot;))// helloworld at方法（寻找数组内的元素）1234567let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]console.log(arr.at(1))// 2console.log(arr.at(-1))// 10","tags":["js"],"categories":["前端3大件"]},{"title":"js基础篇2","path":"/2023/12/10/51/","content":"获取dom节点尺寸123456var omw=document.querySelector(&#x27;#box&#x27;)// 获取宽高console.log(omw.offsetWidth,omw.offsetHeight)// 获取宽高（不计算边框）console.log(omw.clientWidth,omw.clientHeight) 获取dom节点偏移量1234var a=document.querySelector(&#x27;.box&#x27;)// 获取节点相对于父节点的偏移量（要求父节点要设置position），否则根据整个页面进行计算console.log(a.offsetLeft,a.offsetTop) 获取可视窗口尺寸12345// 包括滚动条console.log(innerWidth,innerHeight)// 不包括滚动条console.log(window.document.documentElement.clientWidth,document.documentElement.clientHeight) 基本事件类型 单击：click 双击：dblclick 右键：contextmenu 鼠标按下：mousedown 鼠标抬起：mouseup 鼠标移动：mousemove 移入（包括子节点）：mouseover 移入（不包括子节点）：mouseenter 移出（包括子节点）：mouseout 移出（不包括子节点）：mouseleave 键盘按下：keydown 键盘抬起：keyup 得到焦点：focus 失去焦点：blur 内容改变：input 前后内容不一致：change 重置：reset 提交：submit 触摸开始：touchstart 触摸结束：touchend 触摸移动：touchmove 常用鼠标事件对象（event）12345678box.onclick = function (evt) &#123; //距离可视窗口的位置 console.log(evt.clientX, evt.clientY) //距离整个页面的位置，不受滚动条影响 console.log(evt.pageX, evt.pageY) //距离自己左上角的位置 console.log(evt.offsetX, evt.offsetY) &#125; 阻止事件传播123ob.onclick=function(evt)&#123; evt.stopPropagation() //阻止这个按钮事件往下传播&#125; 阻止默认行为123456789101112// dom0的方式// document.oncontextmenu=function()&#123;// console.log(&quot;自定义右键菜单&quot;)// return false// &#125;//dom2的方式document.addEventListener(&#x27;contextmenu&#x27;,function(evt)&#123; console.log(&quot;自定义右键菜单&quot;) evt.preventDefault()&#125;) 正则表达式 基本元字符 \\d 数字 \\D 非数字 \\s 空白（空格、缩进、换行） \\S 非空白 \\w 字母、数字或下划线 \\W 非字母、数字或下划线 . 任意内容 \\ 转义字符 边界符 ^ 开头 $ 结尾 限定符 * 0~多次 + 1~多次 ? 0~1 {n} 限定n次,必须连续 {n,} &gt;&#x3D;n {n,m} n~m 特殊符号 ( ) 作为整体 | 或(两边默认为整体) [] 表示里面只要有一个就行 [^abc]表示取反，不是abc其中一个 正则两大特新 懒惰性，解决：使用全局标识符g 贪婪 可以加个？，变成非贪婪 123456var reg1=/\\d&#123;1,4&#125;/ //贪婪var reg2=/\\d&#123;1,4&#125;?/ //非贪婪console.log(reg1.exec(&#x27;ab1234d&#x27;)[0])// 1234console.log(reg2.exec(&#x27;ab1234d&#x27;)[0])// 1 this指向问题 call apply bind call 与 apply都会自动执行函数，区别：传入参数的形式不同 bind不会自动执行函数 1234567891011121314151617181920212223242526obj1=&#123; name:&#x27;obj1&#x27;, getName:function(a,b,c)&#123; console.log(&#x27;getName1&#x27;,this.name) console.log(&#x27;参数&#x27;,a,b,c) &#125;&#125;obj2=&#123; name:&#x27;obj2&#x27;, getName:function()&#123; console.log(&#x27;getName2&#x27;,this.name) &#125;&#125;obj1.getName.call(obj2,1,2,3)// getName1 obj2// 参数 1 2 3obj1.getName.apply(obj2,[1,2,3])// getName1 obj2// 参数 1 2 3var fun= obj1.getName.bind(obj2,1,2,3)fun()// getName1 obj2// 参数 1 2 3 继承 1 123456789101112131415161718192021function Person(name,age)&#123; this.myname=name this.myage=age&#125;Person.prototype.mysay=function()&#123; console.log(&#x27;hello&#x27;,this.myname)&#125;function Student(name,age,grade)&#123; // 继承 Person.apply(this,[name,age]) this.grade=grade&#125;// 原型的继承Student.prototype=new Person()let stu=new Student(&#x27;pig&#x27;,14,100)console.log(stu)// &#123;myname: &#x27;pig&#x27;, myage: 14, grade: 100&#125;stu.mysay()// hello pig 2 123456789101112131415161718192021class Person&#123; constructor(name, age)&#123; this.myname = name this.age = age &#125; mysay()&#123; console.log(&#x27;hello&#x27;,this.myname) &#125;&#125;class Student extends Person&#123; constructor(name, age, grade)&#123; super(name, age) this.grade = grade &#125;&#125;let stu = new Student(&#x27;xz&#x27;,18,99)console.log(stu)// &#123;myname: &#x27;xz&#x27;, age: 18, grade: 99&#125;stu.mysay()// hello xz 数学方法 var num=124.2361234 // 指定保留几位小数,能够四舍五入 console.log(num.toFixed(3)) // 124.236 Math.random() 随机数 Math.round() 四舍五入 Math.ceil() 向上取整 Math.floor() 向下取整 Math.abs() 绝对值 Math.sqrt() 平方根 Math.pow(2,4) 2的4次方 &#x3D; 16 Math.max(10,11,20,1,2,4) 取最大 Math.min(10,11,20,1,2,4) 取最小 Math.PI","tags":["js"],"categories":["前端3大件"]},{"title":"处理yaml文件","path":"/2023/11/27/50/","content":"第一种方法这个很简单直接以import的形式引入，在后面加一个?raw,然后使用yaml模块进行解析即可 123import config from &#x27;@/assets/managerCool.config.yml?raw&#x27;import &#123;parse&#125; from &#x27;yaml&#x27;console.log(parse(config)) 第二种方法1. 转文件对象函数​ 记得安装axios 1234567891011121314import axios from &quot;axios&quot;;async function urlToFile(url:string, fileName:string) &#123; try &#123; const response = await axios.get(url, &#123; responseType: &#x27;blob&#x27; &#125;); return new File([response.data], fileName, &#123; type: response.headers[&#x27;content-type&#x27;] &#125;); &#125; catch (error) &#123; console.error(&#x27;Error fetching image:&#x27;, error); &#125;&#125;export &#123; urlToFile&#125; 2. 读取文件内容函数12345678910111213141516171819202122232425/** * 读取文件的方法，返回Promise对象 * @param file 要读取的文件对象 * @param encoding 文件编码格式，默认为&#x27;utf-8&#x27; */function readFile(file: File, encoding = &#x27;utf-8&#x27;): Promise&lt;string&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 创建FileReader对象 const reader = new FileReader(); // 当文件读取完成后，调用resolve方法返回文件内容 reader.onload = function () &#123; resolve(reader.result as string); &#125;; // 当文件读取出错时，调用reject方法返回错误信息 reader.onerror = function () &#123; reject(reader.error); &#125;; // 以指定的编码格式读取文件内容 reader.readAsText(file, encoding); &#125;);&#125;export &#123; readFile&#125; 3. 解析yaml文件​ 需要安装yaml模块 123import &#123;parse&#125; from &#x27;yaml&#x27;parse(&#x27;文件内容&#x27;) 4. 使用​ const url &#x3D; import.meta.env.VITE_CONFIG_URL;这个是我自己的配置的地址，具体的可以查看vite官网的env配置，其实这里的url就是一个指向yaml文件地址的字符串，你直接写你的yaml文件所在位置就行 123456789101112import &#123;readFile&#125; from &quot;@/tools/readFile.ts&quot;;import &#123;urlToFile&#125; from &quot;@/tools/urlToFile.ts&quot;;import &#123;parse&#125; from &#x27;yaml&#x27;const url = import.meta.env.VITE_CONFIG_URL;const name = &#x27;config.yml&#x27;;urlToFile(url, name).then(file =&gt; &#123; // 使用转换后的File对象 readFile(file as File).then(res=&gt;&#123; console.log(parse(res)) &#125;)&#125;);","tags":["vue"],"categories":["前端进阶"]},{"title":"js基础篇1","path":"/2023/11/20/49/","content":"数组常用方法 注意：前面7种方法会改变原数组 1. push 后面追加元素2. pop 后面删除元素3. unshift 前面追加元素4. shift 前面删除元素5. splice 删除与增加，比如arr.splice(1, 1)、arr.splice(1, 0, &quot;lz&quot;)6. reverse 倒序7. sort 排序： 从小到大 123456var arr1 = [10, 1, 7, 66, 11]arr1.sort(function (a, b) &#123; return a-b&#125;)// [1, 7, 10, 11, 66] 从大到小 123456var arr1 = [10, 1, 7, 66, 11]arr1.sort(function (a, b) &#123; return b-a&#125;)// [66, 11, 10, 7, 1] 8. concat 拼接两个数组9. join 数组转字符串10. slice 截取​ 说明：这个可以用于字符串，也可以用于数组 11. indexOf 查找元素​ 说明: 返回索引 12. forEach 遍历123456var arr = [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;]arr.forEach(function (value, index) &#123; console.log(value)&#125;)// aaa bbb ccc ddd 13. map 映射1234567var arr = [1, 2, 3, 4, 5]var arr1 = arr.map(function (value) &#123; return value * 2&#125;)console.log(arr1)// [2, 4, 6, 8, 10] 14. filter 过滤1234567var arr = [11, 2, 4, 1, 5]var arr1 = arr.filter(function (value) &#123; return value &gt; 4&#125;)console.log(arr1)// [11, 5] 15. every​ 说明：返回布尔值，如果数组里面的每一项都满足条件返回true,否则为false 1234567var arr = [90, 90, 80, 100, 95]var arr1 = arr.every(function (item) &#123; return item &gt;= 90&#125;)console.log(arr1);// false 16. some​ 说明：返回布尔值，只要数组中的有一项满足条件就返回true，否则为false 1234567var arr = [90, 90, 80, 100, 95]var arr1 = arr.some(function (a) &#123; return a &gt;= 100&#125;)console.log(arr1);// true 17. find​ 说明：返回第一个满足条件的数组元素 123456789101112131415161718192021var arr = [ &#123; name: &quot;语文&quot;, grade: 90 &#125;, &#123; name: &quot;数学&quot;, grade: 85 &#125;, &#123; name: &quot;英语&quot;, grade: 100 &#125;,]var arr1 = arr.find(function (item) &#123; return item.grade &gt;= 90&#125;)console.log(arr1)// &#123;name: &#x27;语文&#x27;, grade: 90&#125; 18. reduce​ 说明: 每一次运行 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。 ​ 1234567var arr = [1, 2, 3, 4, 5]var arr1 = arr.reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue&#125;)console.log(arr1);// 15 字符串常用方法1. charAt​ 12345var str = &quot;liuzhe&quot;var str1 = str.charAt(2)console.log(str1)// u 2. charCodeAt​ 12345var str = &quot;liuzhe&quot;var str1 = str.charCodeAt(2)console.log(str1)// 117 3. fromCharCode 获取26个字母​ 1234567var arr = []for (var i = 65; i &lt; 91; i++) &#123; arr.push(String.fromCharCode(i))&#125;console.log(arr)// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;] 4. toLocaleUpperCase &amp;&amp; toLocaleLowerCase 大小写的转换​ 123456var str1 = &quot;ASDasd&quot;, str2 = &quot;ZXCzxc&quot;console.log(str1.toLocaleUpperCase())console.log(str2.toLocaleLowerCase())// ASDASD// zxczxc 5. substr(开始索引，长度) &amp;&amp; substring(开始索引，结束索引) 字符串的截取6. replace 替换7. split 分割 字符串转成数组​ 1234var str = &quot;abcd&quot;console.log(str.split(&quot;&quot;))// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 8. trim 去掉首尾空格​ 12345var str = &quot; abcd &quot;console.log(&quot;|&quot; + str + &quot;|&quot;, &quot;|&quot; + str.trim() + &quot;|&quot;)// | abcd | |abcd| new Date()常用方法 ​ 注意：获取月份时记得加1 12345678910111213141516var date=new Date()console.log(date.getFullYear())//年console.log(date.getMonth()+1)//月console.log(date.getDate())//日console.log(date.getDay())//星期console.log(date.getHours())console.log(date.getMinutes())console.log(date.getSeconds())//时间戳 getTime()console.log(date.getTime())//修改date.setFullYear(2020)console.log(date) 浏览器相关1. 事件1234567891011121314// 页面所有资源加载完成后执行onload=function()&#123; console.log(&quot;加载完成&quot;)&#125; // 窗口大小改变就会执行onresize=function()&#123; console.log(&quot;resize&quot;)&#125;//滚动条滚动就会执行 onscroll=function()&#123; console.log(&quot;scroll&quot;)&#125; 2. 滚动距离window.document.documentElement.scrollTop||window.document.body.scrollTop 3. 回到顶部​ window.scrollTo(0,0) 4. 本地存储​ 1234567891011// 存储localStorage.setItem(&quot;age&quot;,&quot;19&quot;)// 获取localStorage.getItem(&quot;age&quot;)// 移除localStorage.removeItem(&quot;age&quot;)// 清除localStorage.clear() 给dom标签挂标识1. 新建原生属性​ 1234var a=document.getElementById(&quot;box&quot;)a.setAttribute(&quot;name&quot;,&quot;teichui&quot;)// &lt;div id=&quot;box&quot; name=&quot;teichui&quot;&gt;&lt;/div&gt; 2. 获取原生属性的值​ 123console.log(a.getAttribute(&quot;name&quot;))// teichui 3. 移除原生属性​ 1a.removeAttribute(&quot;name&quot;) 4. dataset​ 1234567a.dataset.xiaoming=&quot;111&quot;//&lt;div id=&quot;box&quot; data-xiaoming=&quot;111&quot;&gt;&lt;/div&gt;// 删除delete a.dataset.xiaoming 操作dom类名1. className(可以赋值,不会去重)​ 1234var a=document.querySelector(&quot;#box&quot;)a.className=&quot;box1 box2&quot;// &lt;div id=&quot;box&quot; class=&quot;box1 box2&quot;&gt;&lt;/div&gt; 2. classList(会自动去重)​ 12345//增加 a.classList.add(&quot;box4&quot;)// 移除a.classList.remove(&quot;box2&quot;) 获取指定dom的某个节点​ 123456789101112var a=document.querySelector(&quot;#box&quot;)// 获取所有子节点console.log(a.children)// 获取第一个元素子节点console.log(a.firstElementChild)// 获取上一个兄弟节点console.log(a.previousElementSibling)// 获取下一个兄弟节点console.log(a.nextElementSibling) 操作dom节点12345678910111213141516171819202122232425var a=document.querySelector(&#x27;#aa&#x27;)var b=document.querySelector(&#x27;#bb&#x27;)// 创建节点var odiv=document.createElement(&#x27;div&#x27;)//创建节点odiv.innerHTML=&#x27;我是新的&#x27;// 插入子节点a.appendChild(odiv)// 在谁的前面插入a.insertBefore(odiv,bb)// 删除子节点a.removeChild(bb)// 删除自己以及后代a.remove()// 节点的替换 replaceChild(新的节点，老的节点)// 节点的克隆 cloneNode()// false 不克隆后代// true 克隆后代var clon=a.cloneNode(true)","tags":["js"],"categories":["前端3大件"]},{"title":"文件上传完整流程","path":"/2023/10/01/48/","content":"思维导图 构建前端1. 安装项目1npm create vite@latest 相信大家运行个项目没啥问题吧，这里作者就不多费口舌了 2. 安装ant-design-vue1npm install ant-design-vue@4.x --save 不用安装这个也可以，但是要自己写前端上传代码，没必要，我们就站在巨人肩膀上就行 3. 引入ant-design-vue直接在main.ts中进行全局引入 12345678910import &#x27;./assets/main.css&#x27;import &#x27;ant-design-vue/dist/reset.css&#x27;;import Antd from &#x27;ant-design-vue&#x27;;import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App);app.use(Antd).mount(&#x27;#app&#x27;); 然后直接使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;a-upload v-model:file-list=&quot;fileList&quot; name=&quot;avatar&quot; action=&quot;http://localhost:3000/upload&quot; :headers=&quot;headers&quot; :progress=&quot;progress&quot; @change=&quot;handleChange&quot; &gt; &lt;a-button&gt; &lt;upload-outlined&gt;&lt;/upload-outlined&gt; Click to Upload &lt;/a-button&gt; &lt;/a-upload&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; message &#125; from &#x27;ant-design-vue&#x27;;import &#123; UploadOutlined &#125; from &#x27;@ant-design/icons-vue&#x27;;import &#123; ref &#125; from &#x27;vue&#x27;;import type &#123; UploadChangeParam, UploadProps &#125; from &#x27;ant-design-vue&#x27;;const handleChange = (info: UploadChangeParam) =&gt; &#123; if (info.file.status !== &#x27;uploading&#x27;) &#123; console.log(info.file, info.fileList); &#125; if (info.file.status === &#x27;done&#x27;) &#123; message.success(`$&#123;info.file.name&#125; file uploaded successfully`); &#125; else if (info.file.status === &#x27;error&#x27;) &#123; message.error(`$&#123;info.file.name&#125; file upload failed.`); &#125;&#125;;const fileList = ref([]);const progress: UploadProps[&#x27;progress&#x27;] = &#123; strokeColor: &#123; &#x27;0%&#x27;: &#x27;#108ee9&#x27;, &#x27;100%&#x27;: &#x27;#87d068&#x27;, &#125;, strokeWidth: 3, format: percent =&gt; `$&#123;parseFloat(percent.toFixed(2))&#125;%`, class: &#x27;test&#x27;,&#125;;const headers = &#123; authorization: &#x27;authorization-text&#x27; &#125;;&lt;/script&gt; 需要注意的点 name中的avatar是后端接收文件的字段名 action是具体的后端接口地址 headers中的authorization是前端传给后端的头部信息 详细的信息请查看官网: https://www.antdv.com/components/overview 构建后端1. 安装项目1express myapp 如果没有安装express，可以先安装express 1npm install -g express-generator 2. 安装crypto、multer1npm i crypto multer -S 3. 后端路由1234567891011121314151617181920212223242526272829303132333435var express = require(&#x27;express&#x27;);var router = express.Router();const path = require(&#x27;path&#x27;);const crypto = require(&#x27;crypto&#x27;); // 加密// 引入multerconst multer = require(&#x27;multer&#x27;)// 定义一个生成唯一哈希文件名的函数function generateHashedFilename(req, file, callback) &#123; const hash = crypto.randomBytes(16).toString(&#x27;hex&#x27;); const ext = path.extname(file.originalname); // 获取原始文件扩展名 const filename = `$&#123;hash&#125;$&#123;ext&#125;`; // 将哈希与扩展名拼接成新的文件名 callback(null, filename);&#125;const storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, &#x27;public/images/&#x27;); &#125;, filename: generateHashedFilename,&#125;);const upload = multer(&#123; storage &#125;)/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;index&#x27;, &#123; title: &#x27;Express&#x27; &#125;);&#125;);router.post(&#x27;/upload&#x27;,upload.single(&#x27;avatar&#x27;), function(req, res, next) &#123; res.send(&#x27;恭喜上传成功&#x27;); // console.log(req.file);&#125;);module.exports = router; 说明 cb(null, ‘public&#x2F;images&#x2F;‘); 这个是将文件保存到public&#x2F;images&#x2F;目录下 upload.single(‘avatar’)是前端传过来的avatar字段名，这个字段名在前端的name属性中定义的 4. 解决跨域安装cors 1npm install cors -S 在app.js中添加 12345678var cors = require(&#x27;cors&#x27;);// 解决跨域问题app.use(cors(&#123; origin: &#x27;http://127.0.0.1:5173&#x27;, // 允许指定源进行跨域访问，也可以设置为&#x27;*&#x27;表示任何源 credentials: false, // 如果需要携带cookie，开启此项 allowedHeaders: [&#x27;x-requested-with&#x27;,&#x27;authorization&#x27;] // 允许自定义请求头&#125;)); 说明 origin是前端实际地址 记得放在路由之前，不然会报错 总结这里就只对单文件上传进行简单的讲解，关于文件上传还有很多的逻辑，比如： 文件大小限制 文件类型限制 支持文件夹上传 大文件分片上传 多文件上传等等； 大家可以参考ant-design-vue与multer官网，或者网上找找资料","tags":["node"],"categories":["前端进阶"]},{"title":"解决vite+vue中别名问题","path":"/2023/09/15/47/","content":"创建vite+vue项目1npm create vite@latest 配置别名在vite.config.js中配置别名 12345678910111213import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import path from &#x27;path&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;), &#125;, &#125;,&#125;) 此时的@别名指向的是src目录 解决vscode仍然无法识别别名问题这个问题作者也找了很久，根据网上提示说: 这个问题可能是因为VS Code的JavaScript&#x2F;TypeScript语言服务没有识别到你设置的路径别名 解决方法在你的项目根目录下添加jsconfig.json或tsconfig.json文件（取决于你是用JavaScript还是TypeScript），然后设置路径别名。例如，如果你想要设置@为src目录的别名，可以按照以下方式设置： 123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;]&#125;","tags":["vue"],"categories":["前端进阶"]},{"title":"npm创建vue项目","path":"/2023/09/11/46/","content":"创建vue3项目1npm init vue@latest npm init vue@latest 安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。创建的 vue3 项目是基于 Vite 打包的。","tags":["vue"],"categories":["前端进阶"]},{"title":"主题推荐-stellar","path":"/2023/09/10/45/","content":"预览图 官方文档https://xaoxuu.com/wiki/stellar/ 安装在hexo根目录下执行 1git clone https://github.com/xaoxuu/hexo-theme-stellar.git themes/stellar 运行安装后运行可能会缺少一些模块，可以根据报错，将缺失的模块安装比如我缺少的模块是: hexo-fs hexo-util 执行 1npm install hexo-fs hexo-util -D 增加友链页面 先在hexo根目录执行 1hexo new page friends 修改主题配置文件增加一个导航 12nav_tabs: &#x27;友链&#x27;: /friends/ 新建yml文件，用以存放友链信息在根目录下新建: source&#x2F;_data&#x2F;links&#x2F;ios_developer.yml配置如下 12345- title: 某某某 url: https:// cover: icon: description: 使用找到刚才新建的friends页面, 在其index.md文件中添加如下内容: 1&#123;% friends ios_developer %&#125;","tags":["stellar"],"categories":["魔改"]},{"title":"css中变量的使用","path":"/2023/09/05/44/","content":"前言说来惭愧，最近学习sass后，才发现原来css中也可以写变量，原来自己对css的知识只是冰山一角，接下来我们就来写一个简单的动态改变背景颜色的demo css中如何定义变量123:root&#123; --color: #000; &#125; 如何使用1234body&#123; height: 96vh; background-color: var(--color); &#125; js中获取变量值1const rootColor = getComputedStyle(document.documentElement).getPropertyValue(&#x27;--color&#x27;); js中动态改变变量值1document.documentElement.style.setProperty(&#x27;--color&#x27;, 值); 完整代码12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;简单的背景选择&lt;/title&gt; &lt;style&gt; :root&#123; --color: #000; &#125; body&#123; height: 96vh; background-color: var(--color); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;color&quot; id=&quot;color&quot;&gt; &lt;script&gt; // const rootColor = getComputedStyle(document.documentElement).getPropertyValue(&#x27;--color&#x27;); let colorSelector = document.querySelector(&#x27;#color&#x27;); colorSelector.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; // 通过改变css变量，改变页面背景色 document.documentElement.style.setProperty(&#x27;--color&#x27;, e.target.value); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 或许css才是最神秘的语言","tags":["css"],"categories":["前端3大件"]},{"title":"在vscode中的使用sass插件","path":"/2023/09/02/43/","content":"介绍Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。官网: https://sass-lang.com/ 在vscode中安装安装插件: Live Sass Compiler此插件可以直接将sass文件转为css文件官方文档: https://github.com/ritwickdey/vscode-live-sass-compiler?tab=readme-ov-file 安装后需要进行配置 点击扩展设置 编辑json文件 我的配置如下（仅供参考） 12345678910111213141516171819202122232425262728293031&#123; &quot;liveSassCompile.settings.formats&quot;:[ // This is Default. &#123; /* 1.nested: 嵌套模式 2.compact: 紧凑模式 3.expanded: 展开模式 4.compressed: 压缩模式 */ &quot;format&quot;: &quot;expanded&quot;, &quot;extensionName&quot;: &quot;.css&quot;, &quot;savePath&quot;: &quot;~/./css&quot; &#125;, ], // 排除目录 &quot;liveSassCompile.settings.excludeList&quot;: [ &quot;**/node_modules/**&quot;, &quot;.vscode/**&quot; ], // 是否添加兼容前缀 &quot;liveSassCompile.settings.autoprefix&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot; ], // 控制资源管理器是否应在通过回收站删除文件时要求确认。 &quot;explorer.confirmDelete&quot;: false, // 是否生成.map文件 &quot;liveSassCompile.settings.generateMap&quot;: false&#125; 如何使用安装成功后，会在vscode的下方出现watch Sass，点击后就会对你目前的sass文件进行监听，自动生成css文件","tags":["sass"],"categories":["前端进阶"]},{"title":"js扩展API","path":"/2023/08/28/42/","content":"数组方法 拆分多维数组flat 123let arr = [1,2,[3,4,[5,6]]]console.log(arr.flat(2))// [1,2,3,4,5,6] 数组元素修改fill 123let arr = [1, 2, 3, 4, 5]console.log(arr.fill(10, 2))// [1, 2, 10, 10, 10] 只改变数组其中一个元素with 123let arr = [1, 2, 3, 4, 5]console.log(arr.with(1, 100))//[1, 100, 3, 4, 5] 数值方法 Math.trunc() 方法会将数字的小数部分去掉，只保留整数部分 123let a = 123.9999console.log(Math.trunc(a))// 123 Math.sign() 函数返回一个数字的符号，指示数字是正数，负数还是零 123456console.log(Math.sign(99))// 1console.log(Math.sign(-3))// -1console.log(Math.sign(0))// 0 字符串方法 startsWith和endsWith方法可以判断字符串是否以指定字符串开头或结尾 1234567let str = &quot;hello&quot;console.log(str.startsWith(&quot;h&quot;))// trueconsole.log(str.startsWith(&quot;h&quot;, 1))// falseconsole.log(str.endsWith(&quot;o&quot;))// true 字符串的repeat方法可以重复字符串 123let str = &quot;hello&quot;console.log(str.repeat(3))// hellohellohello 字符串的padStart和padEnd方法可以对字符串进行填充 12345let str = &quot;hello&quot;console.log(str.padStart(10, &quot;world&quot;))// worldhelloconsole.log(str.padEnd(10, &quot;world&quot;))// helloworld at函数用于访问数组 12345let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]console.log(arr.at(1))// 2console.log(arr.at(-1))// 10 generator函数生成器函数可以暂停执行，下次调用时继续执行 12345678910function *generator() &#123; yield &#x27;aaa&#x27;; yield &#x27;bbb&#x27;; &#125; let a = generator(); for(let item of generator())&#123; console.log(item); &#125;// aaa// bbb ReflectReflect对象提供了一组静态方法，用于操作对象的属性和方法 Reflect.has判断对象是否存在某个属性 123456let obj = &#123; name: &#x27;xiaoming&#x27;, age: 18 &#125;console.log(Reflect.has(obj, &#x27;name&#x27;))// true Reflect.ownKeys()返回这个对象自身的属性 12console.log(Reflect.ownKeys(obj))// [ &#x27;name&#x27;, &#x27;age&#x27; ] Reflect.defineProperty()为对象添加一个属性，并且可以进行配置 12345678Reflect.defineProperty(obj, &#x27;height&#x27;, &#123; value: 170, writable: true, enumerable: true, configurable: true &#125;)console.log(obj)// &#123; name: &#x27;xiaoming&#x27;, age: 18, height: 170 &#125; Reflect.set()为对象直接添加一个属性 123Reflect.set(obj, &#x27;weight&#x27;, 70)console.log(obj)// &#123;name: &#x27;xiaoming&#x27;, age: 18, weight: 70&#125; Reflect与Proxy联合使用 12345678910let obj = &#123;&#125;let proxy = new Proxy(obj, &#123; get(target, key) &#123; return Reflect.get(...arguments) &#125;, set(target, key, value) &#123; Reflect.set(...arguments) return true &#125; &#125;) matchAll()方法返回一个迭代器，该迭代器包含了检索字符串与正则表达式进行匹配的所有结果 123456789101112let str = ` &lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt; &lt;/ul&gt; `let reg = /&lt;li&gt;(?&lt;content&gt;.*)&lt;\\/li&gt;/gfor(var item of str.matchAll(reg))&#123; console.log(item)&#125; Promise集合一个 Promise 必然处于以下几种状态之一：1.待定（pending）：初始状态，既没有被兑现，也没有被拒绝。2.已兑现（fulfilled）：意味着操作成功完成。3.已拒绝（rejected）：意味着操作失败。 123456789101112131415function ajax(str, time, isSuccess) &#123; if (isSuccess)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(str); &#125;, time); &#125;); &#125;else&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(str); &#125;, time); &#125;); &#125; &#125; Promise.all()等待所有 Promise, 在任意一个 Promise 被拒绝时拒绝 12345Promise.all([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) Promise.race() 看哪一个 Promise 先被执行完，就执行哪一个 Promise 12345Promise.race([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) Promise.any()当输入的任何 promise 实现时，此返回的 promise 将实现，并具有第一个 fulfillation 值。当所有输入的 promise 都拒绝时（包括传递空可迭代对象时），它会拒绝 12345Promise.any([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err, &#x27;拒绝&#x27;) &#125;) Promise.allSettled() 无论任何 promise 实现，此返回的 promise 都将实现，并具有一个数组，其中包含每个输入 promise 的状态和值。 12345Promise.allSettled([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, false)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;)","tags":["js"],"categories":["前端3大件"]},{"title":"css属性mix-blend-mode介绍","path":"/2023/08/25/41/","content":"介绍mix-blend-mode 是一种 CSS 属性，它定义了一个元素的颜色如何与其父元素的颜色以及兄弟元素的颜色混合。它允许您创建令人惊艳的视觉效果，可以用于创建半透明效果、添加阴影、制作图片蒙版和很多其他效果。 具体属性值 difference将前景色减去背景色的值，并取绝对值。这会导致一个反相的效果。效果如下: multiply将两个颜色的值相乘，得到一个更暗的颜色。这通常用于创建阴影效果。原效果如下: 使用multiply后 screen将两个颜色的值相加，然后减去相乘的值，得到一个更亮的颜色。这通常用于创建高光效果。效果如下: overlay根据背景颜色的亮度来选择颜色混合模式。如果背景颜色较暗，则使用 multiply 模式；如果背景颜色较亮，则使用 screen 模式。 darken将两个颜色的值比较，使用较暗的那个颜色。 lighten将两个颜色的值比较，使用较亮的那个颜色。 color-dodge将前景色分解为 RGB 分量，并将每个分量分别除以（1 减去背景色的对应分量）。然后将每个分量限制在 0 到 1 之间，并使用限制后的前景色作为混合色。 color-burn将前景色分解为 RGB 分量，并将每个分量分别除以背景色的对应分量。然后将每个分量限制在 0 到 1 之间，并使用限制后的前景色作为混合色。 exclusion将前景色和背景色的值相加，然后减去相乘的值的两倍。这通常用于创建反相效果。 hue将前景色的色相（Hue）与背景色的饱和度（Saturation）和亮度（Lightness）混合。这可以用于在不改变亮度和饱和度的情况下改变颜色。 saturation将前景色的饱和度与背景色的色相和亮度混合。这可以用于在不改变颜色的情况下改变饱和度。 color将前景色的色相、饱和度和亮度与背景色混合。这可以用于在改变所有颜色属性的情况下改变前景色的颜色。 luminosity将前景色的亮度与背景色的色相和饱和度混合。这可以用于在不改变颜色的情况下改变亮度。","tags":["css"],"categories":["前端3大件"]},{"title":"uni-app实现app自动检测更新","path":"/2023/08/23/40/","content":"前言在做app项目时，app版本管理是必不可少的，在发布新版本后，应该提醒用户需要更新了此时需要两个功能： 后台进行版本发布与管理（使用uni-app的模板admin即可，需要关联Dcloud的服务空间） 前台检测更新（使用uni-app的插件, https://ext.dcloud.net.cn/plugin?id=4542） 后台 在HBuilder里面新建一个项目（模板为uni-admin）： 运行项目到浏览器 登录即可（没有先注册） 在系统管理中找到应用管理 新增一个应用成功后即可发布版本，首先得进行云打包，每次发布都会让你上传apk资源包的，并且每次上传的版本号要比上次大 前台检测更新 插件引入, https://ext.dcloud.net.cn/plugin?id=4542 添加路径在pages.json文件，添加一个更新页面 12345678910111213141516&#123;\t&quot;path&quot;: &quot;uni_modules/uni-upgrade-center-app/pages/upgrade-popup&quot;,\t&quot;style&quot;: &#123; &quot;disableScroll&quot;: true, &quot;app-plus&quot;: &#123; &quot;backgroundColorTop&quot;: &quot;transparent&quot;, &quot;background&quot;: &quot;transparent&quot;, &quot;titleNView&quot;: false, &quot;scrollIndicator&quot;: false, &quot;popGesture&quot;: &quot;none&quot;, &quot;animationType&quot;: &quot;fade-in&quot;, &quot;animationDuration&quot;: 200 &#125;\t&#125;&#125; 添加更新代码(建议在App.vue中引入) 1import checkUpdate from &#x27;uni_modules/uni-upgrade-center-app/utils/check-update.ts&#x27; 在生命周期函数中调用此函数 1checkUpdate()","tags":["uni-app"],"categories":["前端进阶"]},{"title":"vue(原生js)事件委托与参数同时使用","path":"/2023/08/19/39/","content":"事件委托的作用在孩子节点需要绑定多个点击事件的时候，可以直接使用事件委托，将点击事件绑定到父节点，利用事件委托就可以知道自己点击的孩子节点是谁了 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../库/vue2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot; @click=&quot;test&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#box&#x27;, methods: &#123; test(event) &#123; console.log(event.target) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 默认在不传参数的时候，在方法定义的第一个参数就是事件委托的对象 vue事件委托与参数同时使用如果需要传参的同时，并且能够使用事件委托对象，可以这样： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../库/vue2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot; @click=&quot;test($event, &#x27;ttt&#x27;)&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#box&#x27;, methods: &#123; test(event, a) &#123; console.log(event.target, a) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原生js事件委托与参数同时使用可以使用闭包，还有其他方法可以在这里发表哦，这也是事件传递参数的一种方式 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;box&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; box.onclick = test(&quot;aaa&quot;) function test(a) &#123; return function (evt) &#123; console.log(evt.target, a) &#125; &#125;&lt;/script&gt;&lt;/html&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"探究css的滤镜效果","path":"/2023/08/15/38/","content":"今天来讲一讲前端的滤镜效果，也就是filter属性 drop-shadow如果我让你对一个图片里面的图形设置阴影，你有什么办法吗？正常来说你可能想到的是box-shadow,给盒子设置一个阴影 1box-shadow: 10px 10px 10px gray; 但是好像没有达到我们预期的效果，那么这里就要用上drop-shadow了不要box-shadow，而是filter 1filter: drop-shadow(10px 10px 10px gray); blur这个值会让像素变得模糊正常来说: 设置blur后（后面还发现了一个神奇的现象，我的margin: 0 auto;好像失效了，但是好像又没有，因为这个盒子还是在屏幕中间的，不知道为什么，好像这个blur会使这个元素的像素点回到最初的状态） 1filter: blur(10px); contrast提高色彩对比度 grayscale变灰，一些纪念日用得上 backdrop-filter正常: 如果我想给他的背景加点模糊效果，怎么做呢?注意这里可不能用filter了而是得用到我们的backdrop-filter这个可以模糊自身后面的像素 1backdrop-filter: blur(10px);","tags":["css"],"categories":["前端3大件"]},{"title":"主题推荐-anzhiyu","path":"/2023/08/10/37/","content":"预览图 官方文档https://docs.anheyu.com/ 下载1git clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu 安装 pug 和 stylus 渲染插件1npm install hexo-renderer-pug hexo-renderer-stylus --save","tags":["anzhiyu"],"categories":["魔改"]},{"title":"maupassant的基本配置","path":"/2023/08/05/36/","content":"新增标签页面 在hexo根目录下执行 1hexo new page tags 会发现在source文件夹下多了一个tags文件夹, 点进去找到index.md文件，添加如下配置即可 12345---title: tagsdate: 2023-10-13 23:11:26layout: tagcloud--- 添加一个导航找到主题配置文件的_config.yml文件, 找到menu属性: 12345678910111213menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: tags directory: tags/ icon: fa-tag - page: about directory: about/ icon: fa-user 添加网站图标将favicon.ico放到hexo的根目录source文件夹下即可，推荐像素为32*32, 不会立即生效 增加搜索功能 安装插件 1npm install hexo-generator-search 添加代码至hexo下面的_config.yml文件 1234search: path: search.xml field: post content: true 修改主题下的_config.yml文件 1self_search: true 清除多余的搜索框做到这里你会发现你的页面多了一个搜索输入框，我来教你解决找到主题文件下的source&#x2F;js&#x2F;search.js添加脚本 12const searchInput = document.querySelector(&#x27;.widget input&#x27;)searchInput.style.display = &#x27;none&#x27;","tags":["maupassant"],"categories":["魔改"]},{"title":"主题推荐-maupassant","path":"/2023/08/03/35/","content":"今天给大家推荐一款非常好看的主题，预览如下 下载主题首先在自己的hexo博客项目的根目录下执行 1git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant 安装渲染器12npm install hexo-renderer-sass --savenpm install hexo-renderer-jade --save 修改_config.yml1theme: maupassant 运行查看效果1hexo s","tags":["maupassant"],"categories":["魔改"]},{"title":"uni-app中的省市区选择组件","path":"/2023/08/02/34/","content":"找到省市区选择组件的资源包因为uni-app中不支持npm安装后直接导入，所以我们必须先找到这个组件 uni-app中提供了这个组件资源，我们打开Hbuilder，新建一个uni-app的模板项目，如下： 创建完成后找到这个组件，如下： 将其复制到自己的uni-app项目中 配置可参考：https://github.com/MPComponent/mpvue-citypicker 我的配置（仅供参考） 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt;\t&lt;view class=&quot;&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;city&quot; style=&quot;border: 1px solid black;&quot;&gt; &lt;button @tap=&quot;showCityPicker&quot;&gt;选择城市&lt;/button&gt; &lt;mpvue-city-picker ref=&quot;mpvueCityPicker&quot; :pickerValueDefault=&quot;pickerValueDefault&quot; @onChange=&quot;onChange&quot; @onCancel=&quot;onCancel&quot; @onConfirm=&quot;onConfirm&quot;&gt;&lt;/mpvue-city-picker&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\timport mpvueCityPicker from &#x27;@/components/mpvue-citypicker/mpvueCityPicker.vue&#x27;;\texport default &#123; data() &#123; return &#123; pickerValueDefault: [0, 0, 1], city: &#x27;请选择...&#x27; &#125;; &#125;, components: &#123; mpvueCityPicker &#125;, methods: &#123; showCityPicker() &#123; this.$refs.mpvueCityPicker.show(); &#125;, onChange(e) &#123; console.log(e); &#125;, onCancel(e) &#123; console.log(e); &#125;, onConfirm(e) &#123; this.city = e.label &#125; &#125;\t&#125;;&lt;/script&gt;","tags":["uni-app"],"categories":["前端进阶"]},{"title":"chart.js的使用","path":"/2023/07/27/33/","content":"先导之前使用canvaJS已经写过了一个统计页面，但是我觉得样式不够好看，于是又去找图表框架，发现chart.js还挺好看，这里就不说怎么创建一个统计页面了，我不可能所有文章都从最最最基础的讲起的，作者也开始摆烂咯，哈哈哈哈！！！（主要是写教程没经济来源） 找到教程教程：Chart.js · GitBook (bootcss.com) 本教程会使用到webpack, 不知道什么是webpack的，可以先去看一下，官网在：webpack，用于解决模块化导入问题。我觉得很多小伙伴是不是卡在这里了呢？看到这里你是不是觉得很懵，为什么能直接在自己博客的目录下安装chart.js, 然后直接引用，哈哈哈哈，hexo可不支持模块化哦！，看以后会不会支持吧，反正不管怎样都要使用webpack去打包，生成一个可用的js文件 安装webpack在一个空文件夹中 1npm i webpack 1npm i webpack-cli 安装chart.js1npm i chart.js 新建一个src目录在此目录新建main.js, 主要用于写chart.js的配置内容如下： 1234567891011121314151617181920212223242526272829303132333435363738import Chart from &quot;chart.js/auto&quot;;var ctx = document.getElementById(&quot;myChart&quot;).getContext(&#x27;2d&#x27;);var myChart = new Chart(ctx, &#123; type: &#x27;bar&#x27;, data: &#123; labels: [&quot;Red&quot;, &quot;Blue&quot;, &quot;Yellow&quot;, &quot;Green&quot;, &quot;Purple&quot;, &quot;Orange&quot;], datasets: [&#123; label: &#x27;# of Votes&#x27;, data: [12, 19, 3, 5, 2, 3], backgroundColor: [ &#x27;rgba(255, 99, 132, 0.2)&#x27;, &#x27;rgba(54, 162, 235, 0.2)&#x27;, &#x27;rgba(255, 206, 86, 0.2)&#x27;, &#x27;rgba(75, 192, 192, 0.2)&#x27;, &#x27;rgba(153, 102, 255, 0.2)&#x27;, &#x27;rgba(255, 159, 64, 0.2)&#x27; ], borderColor: [ &#x27;rgba(255,99,132,1)&#x27;, &#x27;rgba(54, 162, 235, 1)&#x27;, &#x27;rgba(255, 206, 86, 1)&#x27;, &#x27;rgba(75, 192, 192, 1)&#x27;, &#x27;rgba(153, 102, 255, 1)&#x27;, &#x27;rgba(255, 159, 64, 1)&#x27; ], borderWidth: 1 &#125;] &#125;, options: &#123; scales: &#123; yAxes: [&#123; ticks: &#123; beginAtZero:true &#125; &#125;] &#125; &#125;&#125;); 注意chart.js的引用：import Chart from “chart.js&#x2F;auto”; 配置webpack的打包信息新建文件webpack.config.js 12345678910const path = require(&#x27;path&#x27;);module.exports = &#123; mode: &#x27;development&#x27;, entry: &#x27;./src/main.js&#x27;, // 项目的入口文件路径 output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27; // 构建后的文件路径和文件名 &#125;&#125;; 执行命令： 1npx webpack 执行后生成一个dist文件夹 创建html页面1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;myChart&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用浏览器打开应该就成功了 最后在根据我之前的那篇文章：增加一个统计模块 | Lazychild&#39;s Blog，可以获取本地的一些数据，将图表的数据与博客数据关联起来，最后将自己生成的js文件与html页面移植到自己的博客项目中即可","tags":["butterfly"],"categories":["魔改"]},{"title":"LeanCloud云数据库基本操作","path":"/2023/07/23/32/","content":"官网LeanCloud: 在这里你可以注册leanCloud的账号，并且创建你的应用，即数据库 下面将以vue2案例向大家介绍如何使用leanCloud进行数据的储存, 带大家写一个最常用的登录验证的例子吧 创建一个最简单的vue2项目吧1vue create 项目名称 之前有介绍， 这里就不详细说明了 创建好后，建立两个页面，一个登录页面，还有一个登录跳转后的页面 先自己将路由写好， 能够访问这两个页面即可 下载必要的模块npm install leancloud-storage 在登录页面引入模块并初始化1234567const AV = require(&quot;leancloud-storage&quot;);// 初始化 LeanCloudAV.init(&#123; appId: &quot;你的应用的appId&quot;, appKey: &quot;你的应用的appKey&quot;, serverURL: &quot;https://ysyeflyc.lc-cn-n1-shared.com&quot;,&#125;); 用户的登录验证 123456// 用户登录AV.User.logIn(username, password).then(function(user) &#123; // 登录成功，跳转页面&#125;).catch(function(error) &#123; // 登录失败&#125;); vue2的路由守卫的书写，防止用户未登录就能访问登录后的页面 1234567891011121314beforeEnter: (to, from, next) =&gt; &#123; var token = localStorage.getItem(&#x27;AV/YsYeflyCpiGJrcfPnYM80d43-gzGzoHsz/currentUser&#x27;) var tokenObj = JSON.parse(token) AV.User.become(tokenObj?._sessionToken) .then(function (user) &#123; // token 验证成功，user 是验证后返回的用户对象 next() &#125;) .catch(function (error) &#123; // token 验证失败 location.href = &quot;http://xiao-zhe-is-not-lazy.gitee.io/chou/#/login&quot; &#125;); &#125; 用户属性的更改，将awordNumber改为0 1234567891011var currentUser = AV.User.current(); currentUser.set(&quot;awordNumber&quot;, 0); currentUser .save() .then(function (updatedUser) &#123; // 更新成功 console.log(&quot;更新成功&quot;); &#125;) .catch(function (error) &#123; // 更新失败 &#125;); 我的项目页面展示我主要是写了一个抽奖的项目，一个用户登录后只能抽一次奖 登录界面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221&lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;cover&quot; v-if=&quot;isShow&quot;&gt;登录失败&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- span标签作为背景的圆形图案 --&gt; &lt;div class=&quot;bg&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;text&quot;&gt; 云亦音乐 &lt;span style=&quot; font-size: 12px; line-height: 50px; margin-left: 5px; color: gray; &quot; &gt;周年庆抽奖活动火热进行中!&lt;/span &gt; &lt;/div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;账号&quot; id=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; id=&quot;password&quot; /&gt; &lt;input type=&quot;text&quot; placeholder=&quot;验证码&quot; id=&quot;code&quot; /&gt; &lt;div class=&quot;code&quot;&gt; &lt;div&gt;验证码:&lt;/div&gt; &lt;div&gt;&#123;&#123; code &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;button @click=&quot;btn&quot;&gt;→&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import codeFun from &#x27;@/assets/code&#x27;const AV = require(&quot;leancloud-storage&quot;);// 初始化 LeanCloudAV.init(&#123; appId: &quot;隐藏&quot;, appKey: &quot;隐藏&quot;, serverURL: &quot;https://ysyeflyc.lc-cn-n1-shared.com&quot;,&#125;);export default &#123; data() &#123; return &#123; isShow: false, code: &quot;1234&quot;, timer: null, &#125;; &#125;, created()&#123; this.code = codeFun() &#125;, methods: &#123; btn() &#123; clearTimeout(this.timer); if (code.value == this.code) &#123; AV.User.logIn(username.value, password.value) .then((user) =&gt; &#123; // 登录成功 this.$router.push(&quot;/chou&quot;); &#125;) .catch(() =&gt; &#123; // 登录失败（可能是密码错误） this.isShow = true; this.timer = setTimeout(() =&gt; &#123; this.isShow = false; &#125;, 2000); &#125;); &#125; else &#123; this.code = codeFun() this.isShow = true; this.timer = setTimeout(() =&gt; &#123; this.isShow = false; &#125;, 2000); &#125; &#125;, &#125;,&#125;;&lt;/script&gt; &lt;style scoped&gt;.box &#123; background-color: rgba(0, 0, 0); margin: 0; padding: 0; width: 100%; height: 100%; position: absolute; z-index: -2;&#125;.container &#123; width: 80vw; height: 65vh; margin: 20vh auto; background-color: rgba(255, 255, 255, 0.1); border-radius: 20px; position: relative; box-shadow: inset 1px 1px 6px rgba(255, 255, 255, 0.3), 2px 2px 15px rgba(0, 0, 0, 0.5);&#125;input &#123; background: transparent; outline: none; border: none; border-bottom: 1px solid #666; width: 80%; height: 45px; font-size: 18px; margin-left: 30px; margin-top: 40px; color: white;&#125;.text &#123; display: inline-block; font-size: 26px; margin-left: 34px; margin-top: 50px; color: #eee;&#125;button &#123; border: none; width: 70px; height: 70px; border-radius: 50%; font-weight: bold; font-size: 26px; margin-top: 60px; margin-left: calc(50% - 35px); cursor: pointer; background-color: rgba(255, 255, 255, 0.1); color: white; text-align: center; box-shadow: 0 2px 10px #111;&#125;button:hover &#123; color: greenyellow; background-color: rgba(255, 255, 255, 0.2);&#125;span &#123; position: absolute; border-radius: 50%; box-shadow: 1px 1px 50px #000; z-index: -1;&#125;.bg &#123; width: 100%; height: 100%; position: absolute; z-index: -1; animation: am2 ease-out 1s;&#125;.bg span:nth-child(1) &#123; width: 80px; height: 80px; top: -30px; left: -30px; background-color: purple; animation: am1 ease-in-out 3s infinite alternate;&#125;.bg span:nth-child(2) &#123; width: 40px; height: 40px; top: 40px; right: 40px; background-color: orange; animation: am1 ease-in-out 4s infinite alternate-reverse;&#125;.bg span:nth-child(3) &#123; width: 120px; height: 120px; bottom: -60px; right: -25px; background-color: cyan; animation: am1 ease-in-out 2.5s 0.5s infinite alternate;&#125;/* 动画 */@keyframes am1 &#123; 0% &#123; transform: translateY(0); &#125; 100% &#123; transform: translateY(-30px); &#125;&#125;@keyframes am2 &#123; 0% &#123; transform: scale(0, 0) rotateZ(60deg); &#125; 100% &#123; transform: scale(1, 1) rotateZ(0); &#125;&#125;.cover &#123; width: 90vw; position: absolute; top: 10vh; left: 5vw; text-align: center; opacity: 0.9; color: #e10b0b; border-radius: 20px;&#125;/* 验证码 */.code &#123; color: #c2a3a3; display: flex; margin-left: 10%; margin-top: 10px;&#125;.code div:nth-child(2) &#123; width: 70px; height: 30px; text-align: center; line-height: 30px; margin-left: 10px; background-color: #353743; border: 1px solid white; font-size: 20px; border-radius: 3px;&#125;&lt;/style&gt; 登录页面需要引用的js（验证码的生成）123456789let codeFun = () =&gt; &#123; var code1 = String(Math.floor(Math.random() * 10)) var code2 = String(Math.floor(Math.random() * 10)) var code3 = String(Math.floor(Math.random() * 10)) var code4 = String(Math.floor(Math.random() * 10)) return code1 + code2 + code3 + code4&#125;export default codeFun 抽奖页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;template&gt; &lt;div @click=&quot;btn2()&quot; class=&quot;box&quot;&gt; &lt;audio src=&quot;@/assets/music.mp3&quot; autoplay&gt;&lt;/audio&gt; &lt;!-- 抽中奖品后的遮罩层 --&gt; &lt;div class=&quot;cover&quot; v-if=&quot;isShow&quot;&gt; &#123;&#123; selectedPrize?.name &#125;&#125; &lt;span&gt;恭喜你获得：&#123;&#123; selectedPrize?.describe &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;button @click.once=&quot;btn&quot;&gt;抽奖&lt;/button&gt; &lt;div&gt;剩余的抽奖次数: &#123;&#123; currentUser?.attributes.awordNumber &#125;&#125;&lt;/div&gt; &lt;footer&gt; &lt;h3&gt;奖品详情：&lt;/h3&gt; &lt;div v-for=&quot;(data, index) in prizes&quot; :key=&quot;index&quot;&gt; &lt;span&gt; &#123;&#123; data.name &#125;&#125; : &lt;/span&gt; &lt;span&gt;&#123;&#123; data.describe &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const AV = require(&quot;leancloud-storage&quot;);// 声明 classconst Todo = AV.Object.extend(&quot;Todo&quot;);// 构建对象const todo = new Todo();export default &#123; data() &#123; return &#123; prizes: [ &#123; name: &quot;一等奖&quot;, describe: &quot;免费体验课&quot;, probability: 0 &#125;, &#123; name: &quot;二等奖&quot;, describe: &quot;尤克里里一个&quot;, probability: 0 &#125;, &#123; name: &quot;三等奖&quot;, describe: &quot;小玩具一个&quot;, probability: 0.05 &#125;, &#123; name: &quot;四等奖&quot;, describe: &quot;免费来撸猫&quot;, probability: 0.15 &#125;, &#123; name: &quot;鼓励奖&quot;, describe: &quot;抱抱&quot;, probability: 1 &#125;, ], selectedPrize: null, isShow: false, currentUser: null, &#125;; &#125;, created() &#123; this.currentUser = AV.User.current(); &#125;, methods: &#123; btn(event) &#123; if (this.currentUser.attributes.awordNumber === 0) &#123; alert(&quot;抽奖次数已用完&quot;); return; &#125; this.isRote = true; this.currentUser.attributes.awordNumber -= 1; // 生成一个随机的概率值 var randomProbability = Math.random(); for (var i = 0; i &lt; this.prizes.length; i++) &#123; var prize = this.prizes[i]; if (randomProbability &lt; prize.probability) &#123; this.selectedPrize = prize; // 为属性赋值 todo.set(this.currentUser.attributes.username, prize.describe); break; &#125; else &#123; this.selectedPrize = &#123; name: &quot;空&quot;, describe: &quot;什么都没有&quot; &#125;; &#125; &#125; // 更新后台 this.currentUser.set( &quot;awordNumber&quot;, this.currentUser.attributes.awordNumber ); this.currentUser .save() .then(function (updatedUser) &#123; // 更新成功 console.log(&quot;更新成功&quot;); &#125;) .catch(function (error) &#123; // 更新失败 console.log(&quot;更新失败&quot;); &#125;); // 用户奖品的数据储存 // 将对象保存到云端 todo.save().then( (todo) =&gt; &#123; // 成功保存之后，执行其他逻辑 console.log(`奖品数据保存成功`); &#125;, (error) =&gt; &#123; // 异常处理 console.log(`奖品数据保存失败`); &#125; ); this.isShow = true; // 阻止冒泡 event.stopPropagation(); &#125;, btn2() &#123; this.isShow = false; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.box &#123; height: 100vh; background: no-repeat url(&quot;@/assets/bg.png&quot;); background-size: cover;&#125;button &#123; border: none; width: 70px; height: 70px; border-radius: 50%; font-weight: bold; font-size: 26px; margin-top: 60px; margin-left: calc(50% - 35px); cursor: pointer; background-color: rgba(255, 255, 255, 0.1); text-align: center; box-shadow: 0 2px 10px #111;&#125;.item &#123; width: 80px; height: 80px; background-color: rgba(0, 0, 0, 0.8); margin: 20px; color: #fff; line-height: 80px; text-align: center; border-radius: 10px; font-size: 14px;&#125;.cover &#123; width: 90vw; height: 30vh; position: absolute; top: 35vh; left: 5vw; text-align: center; line-height: 30vh; background-color: black; opacity: 0.9; color: #eee; border-radius: 20px;&#125;footer &#123; width: 100%; position: absolute; left: 0; bottom: 0; font-size: 15px; background-color: rgba(0, 0, 0, 0.4); color: white; font-size: 30px;&#125;footer span &#123; margin-bottom: 5px;&#125;@keyframes am1 &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125;&lt;/style&gt;","tags":["LeanCloud"]},{"title":"Aseprite汉化教程","path":"/2023/07/19/31/","content":"推荐一个好用的像素画制作软件官网：https://www.aseprite.org/ 汉化包与主题包下载在网上找了好久，才找到，于是直接上传到云仓库了，防止丢失，嘻嘻https://gitee.com/xiao-zhe-is-not-lazy/aseprite Aseprite汉化与主题修改 打开下载好的软件，找到左上角，点击Edit 将最下面的File type改为All files： 找到下载好的汉化包与主题包，增加即可 然后会发现多了种语言和主题： 将语言改为中文（将这里的en修改为sChinese）： 到了这一步会发现字体模糊，需要配置主题才可以 修改主题： 点击调整缩放：","tags":["Aseprite"],"categories":["游戏制作"]},{"title":"解决安装Godot时未授权","path":"/2023/07/16/30/","content":"最近对像素类游戏产生了极大的兴趣，感觉玩的不是很过瘾（主要是好多游戏都收费），于是我打算去自己动手制作一款像素类游戏找了很多游戏引擎，搜到最多的就是Unity和Godot，经过一番思考，我打算学习Godot 首先我喜欢Godot的编辑页面， 给人一种简约美 个人认为Godot容易上手 至于游戏的各种素材的制作， 也就是美术和音频，我打算慢慢积累，毕竟游戏制作我认为素材的制作最重要，也最难，目前是打算制作一款像素风格类的生存游戏 于是开始安装Godot找到官网https://godotengine.org/后，开始下载，速度很慢，但这不是大问题，大概下了一半左右，上面提示说未授权， 我真的很懵逼， 刚开始我以为是Godot需要收费，后面去搜索， 发现Godot是一款完全免费的软件，于是去找发现是本地安全策略的问题， 于是去看大佬们的解决办法， 这里@https://blog.csdn.net/weixin_60526471&#x2F;article&#x2F;details&#x2F;126105622 作者就是看这篇文章解决的， 为了防止文章丢失， 作者这里就记录一下 1. 新建一个txt文件，内容如下 123456@echo offpushd &quot;%~dp0&quot;dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txtdir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txtfor /f %%i in (&#x27;findstr /i . List.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;C:\\Windows\\servicing\\Packages\\%%i&quot;pause 2. 将txt文件的后缀改为.cmd, 然后右键以管理员身份打开，等待.cmd文件运行完成，就可以成功开启组策略了3. 同时按【WIN键+R键】，打开cmd命令窗口，输入gpedit.msc，这时候点击【确定】按钮，或按回车键(Enter)就可以打开本地策略组的内容了，4. 本地组策略编辑器找到之后就是调整一下设置了 。找到计算机配置 → windows管理 → 安全设置 → 本地策略 → 安全选项 → 用户控制：以管理员批准模式运行所有管理员 → 双击进入，设置为已禁用状态即可。重启电脑即可正常下载软件了。","tags":["Godot"],"categories":["游戏制作"]},{"title":"使用nvm对node进行版本管理","path":"/2023/07/15/29/","content":"下载nvm地址在https://github.com/coreybutler/nvm-windows/releases 下载后在任意终端执行, 看是否安装成功 1nvm -v 不成功的，可以先将已经安装的node卸载掉 nvm常用命令 安装指定版本: 1nvm install 版本号 列出远程服务器上所有的可用版本： 1nvm ls available 在不同版本间进行切换(已经安装了) 1nvm use 版本号 查看本地安装了的node版本 1nvm ls","tags":["node"],"categories":["前端进阶"]},{"title":"ws模块实现聊天的一些基本功能","path":"/2023/07/10/28/","content":"本篇文章难度较大哦，小伙伴们👀️本文要讲解的代码作者已上传至云仓库：https://gitee.com/xiao-zhe-is-not-lazy/chat学习本篇文章之前记得先去看:1.登录鉴权——JWT(前后端分离) | Lazychild&#39;s Blog2. 初始ws模块 | Lazychild&#39;s Blog 先写好一个基本的登录鉴权功能之前文章写过了，小伙伴们自己去看看吧👀️ 前端一共有两个界面： 登录界面 聊天室界面 到了这一步应该实现前端进行登录，后端进行token校验，成功后跳转至聊天室这个界面（只要跳转就行，后面会讲聊天室界面对于token的校验） 代码展示 登录界面代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;登录&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 const autorization = response.headers.autorization autorization &amp;&amp; localStorage.setItem(&#x27;token&#x27;, autorization) return response &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;聊天室登录界面&lt;/h2&gt; &lt;div&gt;账号：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;/div&gt; &lt;div&gt;密码：&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;登录&lt;/button&gt; &lt;script&gt; btn.onclick = function () &#123; axios.post(&#x27;http://localhost:3000/login&#x27;, &#123; username: username.value, password: password.value &#125;).then(res =&gt; &#123; if (res.data.ok) &#123; location.href = &#x27;/index&#x27; &#125; else &#123; alert(&#x27;账号或密码错误&#x27;) &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 基本的路由代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var express = require(&#x27;express&#x27;);var jwtObj = require(&#x27;../utils/jsonwebtoken&#x27;)const mysql2 = require(&#x27;mysql2&#x27;)var router = express.Router();/* GET home page. */router.get(&#x27;/login&#x27;, function (req, res, next) &#123; res.type(&#x27;html&#x27;); res.render(&#x27;login&#x27;)&#125;)router.get(&#x27;/index&#x27;, function (req, res, next) &#123; res.type(&#x27;html&#x27;); res.render(&#x27;index&#x27;)&#125;)let mony, namerouter.post(&#x27;/login&#x27;, async function (req, res) &#123; a = &#x27;users&#x27; // 创建连接池 const config = handleConfig() const promisePool = mysql2.createPool(config).promise() let users = await promisePool.query(`SELECT * FROM $&#123;a&#125; WHERE name=&#x27;$&#123;req.body.username&#125;&#x27; AND password=&#x27;$&#123;req.body.password&#125;&#x27;`) //sql语句 if (users[0].length) &#123; mony = users[0][0].mony name = users[0][0].name // 将token放在header中 const token = jwtObj.sign(&#123; name, mony &#125;, &#x27;1h&#x27;) res.header(&#x27;Autorization&#x27;, token) res.send(&#123; ok: 1 &#125;) &#125; else &#123; res.send(&#123; ok: 0 &#125;) &#125;&#125;)module.exports = router;// 连接数据库的基本配置function handleConfig() &#123; return &#123; host: &#x27;localhost&#x27;, port: 3306, user: &quot;root&quot;, password: &quot;&quot;, database: &quot;maizuo&quot;, connectLimit: 1 &#125;&#125; token加密&#x2F;解密代码 1234567891011121314151617181920const &#123; json &#125; = require(&#x27;express&#x27;)const jwt = require(&#x27;jsonwebtoken&#x27;)const key = &#x27;maizuoc312asdpkj&#x27; //秘钥const obj=&#123; // 加密 sign: function(data,time)&#123; const token=jwt.sign(data, key, &#123; expiresIn: time &#125;) return token &#125;, verify: function(token)&#123; try &#123; return jwt.verify(token, key) &#125; catch (error) &#123; return false &#125; &#125;&#125;module.exports=obj 各种依赖包记得下载 依赖包展示（package.json文件） 12345678910111213141516171819&#123; &quot;name&quot;: &quot;nodeapp2-jwt&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node ./bin/www&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;cookie-parser&quot;: &quot;~1.4.4&quot;, &quot;debug&quot;: &quot;~2.6.9&quot;, &quot;ejs&quot;: &quot;~2.6.1&quot;, &quot;express&quot;: &quot;~4.16.1&quot;, &quot;http-errors&quot;: &quot;~1.6.3&quot;, &quot;jsonwebtoken&quot;: &quot;^9.0.0&quot;, &quot;morgan&quot;: &quot;~1.9.1&quot;, &quot;mysql2&quot;: &quot;^3.3.3&quot;, &quot;ws&quot;: &quot;^8.13.0&quot; &#125;&#125; 进入主题ws模块大家之前应该就使用过了吧，这里主要是与之前的登录鉴权实现一些聊天的基本功能，比如群聊，单聊等，站长这里只讲功能，页面的美化得靠大家，直接代码展示node服务端ws代码展示(建议新建一个文件独立写ws的代码，容易维护)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const WebSocket = require(&quot;ws&quot;)const &#123; WebSocketServer &#125; = require(&quot;ws&quot;)const JWT = require(&#x27;../utils/jsonwebtoken&#x27;)const wss = new WebSocketServer(&#123; port: 8080 &#125;);wss.on(&#x27;connection&#x27;, function connection(ws, req) &#123; ws.on(&#x27;error&#x27;, console.error); // 验证token const payload = JWT.verify(req.url.split(&#x27;=&#x27;)[1]) if (payload) &#123; ws.user = payload // 通知在线用户的人数 sendAll() &#125; else &#123; ws.send(createMessage(WebSocketType.Error, null, &quot;登录已过期&quot;)) &#125; ws.on(&#x27;message&#x27;, function message(data, isBinary) &#123; // 解析前端发送过来的消息进行判断 const msgObj = JSON.parse(data) // 判断，进行逻辑处理 switch (msgObj.type) &#123; case WebSocketType.groupList: break; case WebSocketType.groupChat: wss.clients.forEach(function each(client) &#123; if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123; client.send(data, &#123; binary: isBinary &#125;); &#125; &#125;); break; case WebSocketType.singleChat: wss.clients.forEach(function each(client) &#123; if (client.user.name == msgObj.to &amp;&amp; client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123; client.send(data, &#123; binary: isBinary &#125;); &#125; &#125;); break; &#125; &#125;) // 当服务器断开时触发 ws.on(&#x27;close&#x27;, () =&gt; &#123; wss.clients.delete(ws.user) sendAll() &#125;)&#125;);const WebSocketType = &#123; Error: 0, groupList: 1, //在线人数 groupChat: 2, //群聊 singleChat: 3 //单聊&#125;function createMessage(type, user, data) &#123; return JSON.stringify(&#123; type, user, data &#125;)&#125;// 给所有的在线用户实时发送当前的用户列表function sendAll() &#123; wss.clients.forEach(function each(client) &#123; if (client.readyState === WebSocket.OPEN) &#123; client.send(createMessage(WebSocketType.groupList, null, JSON.stringify(Array.from(wss.clients).map(item =&gt; item.user)))) &#125; &#125;);&#125; 前端聊天室代码展示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;聊天室&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;聊天室&lt;/h1&gt; &lt;input type=&quot;text&quot; class=&quot;message&quot;&gt; &lt;select name=&quot;&quot; id=&quot;onlineUsers&quot;&gt;&lt;/select&gt; &lt;button id=&quot;btn&quot;&gt;发送&lt;/button&gt; &lt;script&gt; // to字段主要是在单聊时，知道要发给谁 function createMessage(type, data, to) &#123; return JSON.stringify(&#123; type, data, to &#125;) &#125; let btn = document.querySelector(&#x27;#btn&#x27;) let message = document.querySelector(&#x27;.message&#x27;) let onlineUsers = document.querySelector(&#x27;#onlineUsers&#x27;) const WebSocketType = &#123; Error: 0, groupList: 1, //在线人数 groupChat: 2, //群聊 singleChat: 3 //单聊 &#125; const ws = new WebSocket(`ws://localhost:8080?token=$&#123;localStorage.getItem(&#x27;token&#x27;)&#125;`) ws.onopen = () =&gt; &#123; console.log(&quot;服务器已连接&quot;) &#125; ws.onmessage = (msgObj) =&gt; &#123; // 解析后端传过来的值，进行判断 let dataObj = JSON.parse(msgObj.data) switch (dataObj.type) &#123; case WebSocketType.Error: location.href = &#x27;/login&#x27; break; case WebSocketType.groupList: // 获取用户列表 onlineUsers.innerHTML =&#x27;&lt;option value=&quot;all&quot;&gt;群发&lt;/option&gt;&#x27; + JSON.parse(dataObj.data).map(item =&gt;`&lt;option value=&quot;$&#123;item.name&#125;&quot;&gt;$&#123;item.name&#125;&lt;/option&gt;`) break; //群聊 case WebSocketType.groupChat: console.log(&#x27;群聊&#x27;, dataObj) break; //单聊 case WebSocketType.singleChat: console.log(&#x27;单聊&#x27;, dataObj) break; &#125; // 发送消息 btn.onclick = function () &#123; if (onlineUsers.value == &#x27;all&#x27;) &#123; // 群发 ws.send(createMessage(WebSocketType.groupChat, message.value)) &#125;else&#123; // 单聊 ws.send(createMessage(WebSocketType.singleChat, message.value, onlineUsers.value)) &#125; &#125; &#125; ws.onerror = () =&gt; &#123; console.log(&quot;error&quot;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 能够看到这里的小伙伴给自己鼓鼓掌吧，未来的前端是你们的🎉️","tags":["node"],"categories":["前端进阶"]},{"title":"闲聊篇","path":"/2023/07/06/27/","content":"7月6日，下班后有感：很想说说我以前喜欢过的女生 谈谈初中她是我的同桌，额，准确来说是我的初三的同桌吧，当时老班把我和她安排到同桌的时候，真的开心了好久，她长的不高，脸上有一些雀斑，和我一个姓，当时她成绩特别好，嗯嗯，至少比我好太多了，一般都是班上前几名，我真的对学习好的女生特别有好感，但是我当时用一组词来形容（可能现在也好不到哪去吧）就是：矮、穷、挫，反正不好的标签往我身上贴就行，但是不知道是谁说我喜欢你，搞的全班皆知，除了老班，我的本意哪敢和你说我喜欢你啊，我用脚趾头都能想到，你不可能喜欢我，哎！不记得这个走漏风声的人是谁了，不然在这里非得骂你几句，当时想着只要不影响你学习，我这一辈子都不会去告诉你我喜欢你的我觉得我同桌当时被我这样的人喜欢一定很痛苦吧，在这里向你道歉了，哈哈哈 谈谈高中高一刚进来的时候，也有过许多漂亮的女同学，但是我好像对爱情的向往再也没有了兴趣😮‍💨😮‍💨，好吧，我骗人的，其实我喜欢过一个女生，她的名字中有一个和我一样，长得不高，鼻子很挺，给人一种明星的感觉，成绩不是很好，但是好像喜欢一个人，真的没有什么标准，就是一瞬间，她的某个动作，或者某个眼神，直击你的心脏，哈哈哈哈，我这样描述，好肉麻，反正我知道她就是我喜欢的女生了，但是表白这种行为，在我这里就好比让我去摘天上的月亮这么难，可能受我原生家庭的影响吧，你别看我平时各种搞笑，其实我的自卑是刻在骨子里的，就是现在，我其实也没有自信，但是可能比以前好了（自我感觉）所以一直没有和她说后来分班了，其实我一直喜欢着她，直到现在毕业，我承认还是会想起她，但是还是没有向她袒露心声可能有些事情错过了就是一辈子，有些人一转身就是永远吧，我只能默默祝福你了呢，哈哈哈哈 谈谈大学好像有点喝醉了。。。头好晕，不写了","tags":["生活闲聊"]},{"title":"初始ws模块","path":"/2023/06/01/26/","content":"websocket协议Webscoket是Web浏览器和服务器之间的一种全双工通信协议 ，其中WebSocket协议由IETF定为标准，WebSocket API由W3C定为标准。 一旦Web客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。 通信过程中，可互相发送JSON、XML、HTML或图片等任意格式的数据。我们将基于这个协议，实现聊天室的功能 下载ws模块1npm i ws node服务端代码1234567891011121314151617const WebSocket = require(&quot;ws&quot;)const &#123; WebSocketServer &#125; = require(&quot;ws&quot;)const wss = new WebSocketServer(&#123; port: 8080 &#125;);wss.on(&#x27;connection&#x27;, function connection(ws) &#123; ws.on(&#x27;error&#x27;, console.error); ws.on(&#x27;message&#x27;, function message(data, isBinary) &#123; wss.clients.forEach(function each(client) &#123; if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123; client.send(data, &#123; binary: isBinary &#125;); &#125; &#125;); &#125;); ws.send(&quot;欢迎进入聊天室&quot;)&#125;); 前端代码12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;聊天室&lt;/h1&gt; &lt;script&gt; var ws = new WebSocket(&quot;ws://localhost:8080&quot;) ws.onopen = ()=&gt;&#123; console.log(&quot;连接成功&quot;) &#125; ws.onmessage = (msgObj)=&gt;&#123; console.log(msgObj.data) &#125; ws.onerror = ()=&gt;&#123; console.log(&quot;error&quot;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 测试打开两个前端页面（客户端），在一个客户端控制台输入ws.send(“hello”) 在另一个客户端的控制台就能收到hello这个消息了， 这里其实已经相当一个群聊功能了，只是聊天的用户都是互相不知道的，接下来作者会使用登录验证，让所有用户能够彼此能够认识 让我们实现私聊功能吧！！","tags":["node"],"categories":["前端进阶"]},{"title":"hexo博客项目部署至vercel","path":"/2023/05/28/25/","content":"部署过程太过于繁琐，作者真的好懒，不想写，这里就大概描述一下我的部署过程吧 注册github账号GitHub 因为作者之前用的都是Gitee，因为vercel的部署不能用Gitee了，所有注册github是必要的，并且作者悄悄的告诉你，github才是真正的源码市场，可以学到很多大佬的源码 下载fastgithub很多人访问github都很难进去，这是当然，毕竟是国外的网站，这里可以自己翻墙，但是大多数翻墙软件都需要money👀️ ，这里就不得不介绍另外一种软件了——fastgithub不多说，用它之后腰不疼，腿也不疼了，哈哈哈哈😄 直接搜索即可下载，网上有使用教程，作者真的很懒，不想多说 修改hexo下面的_config.yml文件因为作者之前用的是Gitee，你如果之前用的是github请省略这个步骤这一步也不想多说，主要是改变了云仓库的地址，直接展示： 1234deploy: type: git repo: 自己仓库的地址 branch: main 注册vercel账号https://vercel.com/ 这里最最最最最好使用github账号登录即可，方便后续代码的上传更新，总而言之，很方便注册成功后点击新建一个项目（不要跟我说新建项目也不会，实在不行请留言给我），之后会出现： 点击import导入自己github的项目即可🎉️最后经过一系列的操作就会成功部署，然后你很开心的打开vercel给你分配的域名发现根本无法访问，哎！！，这里注意vercel给的域名在国内是访问不了的，这里就需要接下来的步骤了 购买域名这里自己随便找个网站购买域名（其实挺麻烦，购买成功后，找到控制台，对域名进行解析，解析@，www这两个即可，这里需要绑定ip地址，可以在vercel的设置域名那里找到（具体的我也忘了，反正可以在vercel中找到👀️ ） vercel的配置创建好项目后点击： 进入后再点击： 这里接着的操作请使用浏览器自带的翻译功能，一步步的配置自己的域名，写起来挺麻烦，但是操作起来挺简单，这里配置成功后需要有一个等待时间他会不断的刷新，然后报错，等等他就好了 最后变成这样你就成功了🎉️ ： 最后一步修改hexo下面的_config.yml文件12url: 自己网站的域名root: / 记得重新上传代码","tags":["hexo"],"categories":["魔改"]},{"title":"留言板模块与文章评论开启","path":"/2023/05/24/24/","content":"注册LeanCloud账号注册LeanCloud账号是为了给评论的数据提供云存储 首先来到LeanCloud的首页:https://www.leancloud.cn/，点击右上角的控制台，按照指引进行注册即可 创建应用注册完成后,进行登录会进入这个页面： 点击创建应用，随后填写一些应用的基本信息后你的应用就创建成功啦🎉️ 创建留言板页面1hexo new page message 修改其目录下的index.md为index.ejs,增添如下内容： 1234567891011121314151617181920212223242526272829---title: 留言板---&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&#x27;//unpkg.com/valine/dist/Valine.min.js&#x27;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Valine(&#123; el: &#x27;#vcomments&#x27;, appId: &#x27;你的AppID&#x27;, appKey: &#x27;你的AppKey&#x27;, placeholder: &#x27;欢迎大家来到lazychild,如果有什么想说的话，请留言给作者哦，作者会尽量快速回复大家的哦😜😜，注意邮箱一定不能写错哦，不然你就收不到作者的回复了&#x27;, avatar: &#x27;wavatar&#x27;, pageSize: 4, requiredFields: [&#x27;mail&#x27;] &#125;)&lt;/script&gt;&lt;/html&gt; AppID与AppKey的设置：创建好LeanCloud应用后，找到左边设置的应用凭证即可找到自己的AppID与AppKey 这里的评论系统使用的是基于基于LeanCloud的快速、简洁且高效的无后端评论系统————Valine，更多的Valine的配置请自主学习，请参考https://valine.js.org/configuration.html👀️ 增加导航栏菜单最后自己在主题配置文件_config.yml中配置即可这是我的： 12345678910menu: 首页: / || icon-shouye2 文章 || icon-xiewenzhang: 归档: /archives/ || icon-guidang 标签: /tags/ || icon-biaoqian 分类: /categories/ || icon-fenlei 统计: /statistics/ || icon-tongjitu 友链: /link/ || icon-LINKS 我的: /about/ || icon-gerenzhongxin_wodediqu 留言板: /message/ || icon-liuyanban icon图标是我自己引入的，你不能照搬哦👀️ ，具体的引入方法请参考菜单栏多色图标 | Lazychild&#39;s Blog (gitee.io)到这里你就已经完成了留言板模块了🎉️ 文章评论功能的开启在此之前小伙伴们肯定已经创建了一个LeanCloud应用了，这里请小伙伴们再创建一个LeanCloud应用，用来存放文章评论 创建成功后，找到主题配置文件_config.yml,修改： 12345678910comments: # Up to two comments system, the first will be shown as default # Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk use: Valine text: true # Display the comment name next to the button # lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport. # If you set it to true, the comment count will be invalid lazyload: true count: true # Display comment count in post&#x27;s top_img card_post_count: true # Display comment count in Home Page 12345678valine: appId: 你的AppID appKey: 你的AppKey avatar: wavatar # gravatar style https://valine.js.org/#/avatar serverURLs: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in) bg: # valine background visitor: false option: bug解决发现了一个bug，发现很多不需要用到评论的地方也有了评论功能，解决办法：在自定义的js文件中增加如下内容： 12345// 删除多余的评论板块// 解决留言板模块2次渲染问题导致评论区出现了2次if(path[2] == &#x27;message&#x27; || path[2] == &#x27;about&#x27; || path[2] == &#x27;tags&#x27; || path[2] == &#x27;categories&#x27; || path[2] == &#x27;statistics&#x27; || path[2] == &#x27;link&#x27;)&#123;\tvar postComment = document.querySelector(&#x27;#post-comment&#x27;) &amp;&amp; postComment.remove()&#125;","tags":["butterfly"],"categories":["魔改"]},{"title":"增加一个统计模块","path":"/2023/05/23/23/","content":"canvasJS的使用这是前端的一个画各种表格的插件，十分好用哦！！官网地址在https://canvasjs.com/ 新建一个js文件123456789101112131415161718// 将文章日期和数量存本地var achivesDate = document.querySelectorAll(&#x27;.card-archive-list-date&#x27;); var achivesDateNumber = document.querySelectorAll(&#x27;.card-archive-list-count&#x27;); var achivesDateArr = []; var achivesDateNumberArr = [];if (achivesDate.length) &#123;\tfor (var i = 0; i &lt; achivesDate.length; i++) &#123; achivesDateArr.push(achivesDate[i].innerHTML); achivesDateNumberArr.push(achivesDateNumber[i].innerHTML) &#125;; localStorage.setItem(&#x27;achivesDateArr&#x27;, achivesDateArr); localStorage.setItem(&#x27;achivesDateNumberArr&#x27;, achivesDateNumberArr)&#125;// 将分类信息存入本地var cardCategoryListCountArr = []var cardCategoryListNameArr = []var cardCategoryListCount = document.querySelectorAll(&#x27;.card-category-list-count&#x27;)var cardCategoryListName = document.querySelectorAll(&#x27;.card-category-list-name&#x27;)if (cardCategoryListCount.length) &#123;\tfor (var i = 0; i &lt; cardCategoryListCount.length; i++) &#123; cardCategoryListCountArr.push(cardCategoryListCount[i].innerHTML) cardCategoryListNameArr.push(cardCategoryListName[i].innerHTML)\t&#125;\tlocalStorage.setItem(&#x27;card-category-list-count&#x27;, cardCategoryListCountArr)\tlocalStorage.setItem(&#x27;card-category-list-name&#x27;, cardCategoryListNameArr)&#125; 记得引入至主题配置文件_config.yml中 新建页面在根目录source目录下新建一个目录statistics，在其下面新建index.ejs文件增加如下内容即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879---title: 统计---&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\t&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\t&lt;title&gt;Document&lt;/title&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.lazychild.fun/js/canvasJS.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;\t&lt;div id=&quot;chartContainer&quot; style=&quot;height: 300px; width: 95%;&quot;&gt;&lt;/div&gt;\t&lt;div id=&quot;chartContainer1&quot; style=&quot;height: 300px; width: 95%;&quot;&gt;&lt;/div&gt;\t&lt;script type=&quot;text/javascript&quot;&gt; // 从本地获取文章数量和日期 var achivesDateArr = localStorage.getItem(&#x27;achivesDateArr&#x27;).split(&#x27;,&#x27;).reverse() var achivesDateNumberArr = localStorage.getItem(&#x27;achivesDateNumberArr&#x27;).split(&#x27;,&#x27;).reverse() var cardCategoryListName = localStorage.getItem(&#x27;card-category-list-name&#x27;).split(&#x27;,&#x27;) var cardCategoryListCount = localStorage.getItem(&#x27;card-category-list-count&#x27;).split(&#x27;,&#x27;) // 文章 var chart = new CanvasJS.Chart(&quot;chartContainer&quot;, &#123; title: &#123; text: &quot;归档&quot; &#125;, data: [ &#123; dataPoints: [] &#125; ] &#125;); let initX = 1 for (var i = 0; i &lt; achivesDateArr.length; i++) &#123; chart.options.data[0].dataPoints.push(&#123; x: initX, y: parseInt(achivesDateNumberArr[i]), label: achivesDateArr[i] &#125;) initX++ &#125; chart.render(); // 分类 var chart1 = new CanvasJS.Chart(&quot;chartContainer1&quot;, &#123; legend: &#123; maxWidth: 350, itemWidth: 120 &#125;, title: &#123; text: &quot;分类&quot; &#125;, data: [ &#123; type: &quot;pie&quot;, showInLegend: true, legendText: &quot;&#123;indexLabel&#125;&quot;, dataPoints: [] &#125; ] &#125;); for (var i = 0; i &lt; cardCategoryListName.length; i++) &#123; chart1.options.data[0].dataPoints.push(&#123; y: parseInt(cardCategoryListCount[i]), indexLabel: cardCategoryListName[i] &#125;) &#125; chart1.render();\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后在增加一个导航栏12menu: 统计: /statistics/ || icon-tongjitu","tags":["butterfly"],"categories":["魔改"]},{"title":"vue项目打包部署至云仓库","path":"/2023/05/21/22/","content":"创建云仓库这里不做过多解释，网上都有教程，作者用的是Gitee创建好后就可以将自己的项目上传了 配置vue.config.js文件1234567module.exports = &#123; publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/仓库根目录的名字&#x27; : &#x27;/&#x27; , productionSourceMap: false,&#125; 修改.gitignore文件删除文件里dist这个字段修改此文件的目的是执行push命令时能上传dist目录， vue项目打包1npm run build 打包成功后会出现一个dist目录 使用git命令上传至云仓库这里还不会的建议先去看看教程 开启Gitee Pages先将远程仓库开源，然后在服务选项那里有一个Gitee Pages点进去开启就行(必须设置为开源哦)记得将部署的目录改成dist","tags":["vue"],"categories":["前端进阶"]},{"title":"Electron与vue的组合","path":"/2023/05/20/21/","content":"本篇文章出自：https://blog.csdn.net/honest1120110/article/details/116643392 创建vue项目1vue create myapp 安装electron环境Electron安装 1npm install electron Vue项目添加Electron-builder打包工具 1vue add electron-builder 提示：如果出现electron安装失败，或者后面使用electron-builder打包时，出现从github down包失败，请设置electron镜像。 1npm config edit 使用该命令会弹出npm的配置文档，将以下类容复制到文件末尾。 12electron_mirror=https://npm.taobao.org/mirrors/electron/electron-builder-binaries_mirror=https://npm.taobao.org/mirrors/electron-builder-binaries/ 测试1npm run electron:serve 运行成功后会自动弹出一个窗口，这就是你的app了，你成功了吗？ 替换客户端图标进入项目路径，查看是否存在vue.config.js同名文件（好像是vue3没有，vue2会有），没有则创建一个空文件。编辑vue.config.js文件 12345678910111213141516171819module.exports = &#123; pluginOptions: &#123; electronBuilder: &#123; builderOptions: &#123; &quot;appId&quot;: &quot;com.example.app&quot;, &quot;productName&quot;: &quot;aDemo&quot;,//项目名，也是生成的安装文件名，即aDemo.exe &quot;copyright&quot;: &quot;Copyright © 2023&quot;,//版权信息 &quot;directories&quot;: &#123; &quot;output&quot;: &quot;./dist&quot;//输出文件路径，之前编译的默认是dist_electron &#125;, &quot;win&quot;: &#123; &quot;icon&quot;: &quot;Demo.ico&quot;//这里注意配好图标路径 &#125; // options placed here will be merged with default configuration and passed to electron-builder &#125; &#125; &#125;&#125; electron-builder的更多配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;build&quot;: &#123; &quot;productName&quot;:&quot;xxxx&quot;, //项目名 这也是生成的exe文件的前缀名 &quot;appId&quot;: &quot;com.xxx.xxxxx&quot;,\t//包名 &quot;copyright&quot;:&quot;xxxx&quot;, //版权信息 &quot;directories&quot;: &#123; //输出文件夹 &quot;output&quot;: &quot;build&quot; &#125;, &quot;nsis&quot;: &#123;\t//nsis相关配置，打包方式为nsis时生效 &quot;oneClick&quot;: false, // 是否一键安装 &quot;allowElevation&quot;: true, // 允许请求提升，如果为false，则用户必须使用提升的权限重新启动安装程序。 &quot;allowToChangeInstallationDirectory&quot;: true, // 允许修改安装目录 &quot;installerIcon&quot;: &quot;./build/icons/aaa.ico&quot;, // 安装图标 &quot;uninstallerIcon&quot;: &quot;./build/icons/bbb.ico&quot;, //卸载图标 &quot;installerHeaderIcon&quot;: &quot;./build/icons/aaa.ico&quot;, // 安装时头部图标 &quot;createDesktopShortcut&quot;: true, // 创建桌面图标 &quot;createStartMenuShortcut&quot;: true, // 创建开始菜单图标 &quot;shortcutName&quot;: &quot;xxxx&quot;, // 图标名称 &quot;include&quot;: &quot;build/script/installer.nsh&quot;, // 包含的自定义nsis脚本 &#125;, &quot;publish&quot;: [ &#123; &quot;provider&quot;: &quot;generic&quot;, // 服务器提供商，也可以是GitHub等等 &quot;url&quot;: &quot;http://xxxxx/&quot; // 服务器地址 &#125; ], &quot;win&quot;: &#123; &quot;icon&quot;: &quot;build/icons/aims.ico&quot;, &quot;target&quot;: [ &#123; &quot;target&quot;: &quot;nsis&quot;, //使用nsis打成安装包，&quot;portable&quot;打包成免安装版 &quot;arch&quot;: [ &quot;ia32&quot;, //32位 &quot;x64&quot; //64位 ] &#125; ] &#125;, &quot;mac&quot;: &#123; &quot;icon&quot;: &quot;build/icons/icon.icns&quot; &#125;, &quot;linux&quot;: &#123; &quot;icon&quot;: &quot;build/icons&quot; &#125; &#125; 打包(生成桌面app)1npm run electron:build","tags":["Electron"],"categories":["桌面App"]},{"title":"首页轮播功能的实现","path":"/2023/05/16/20/","content":"本篇文章参考https://akilar.top/posts/8e1264d1/这里只是做个记录 在博客根目录安装插件1npm install hexo-butterfly-swiper --save 更改根目录下的_config.yml1234567891011121314151617## 增加首页的轮播功能# hexo-butterfly-swiper# see https://akilar.top/posts/8e1264d1/swiper: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: all # 应用页面 timemode: date #date/updated layout: # 挂载容器类型 type: id name: recent-posts index: 0 default_descr: 再怎么看我也不知道怎么描述它的啦！ swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css #swiper css依赖 swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js #swiper js依赖 custom_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css # 适配主题样式补丁 custom_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js # swiper初始化方法 增加文章的一个配置项1swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前","tags":["hexo"],"categories":["魔改"]},{"title":"登录鉴权——JWT(前后端分离)","path":"/2023/05/13/19/","content":"本篇文章适合有node基础的同学们哦！这篇文章记录了做的仿卖座电影的一个登录功能我用到的技术 express（基于node的后端） 数据库（我用的是Wampserver64） vue2 （前端） axios mysql2 jsonwebtoken 创建后台项目1express --view=ejs nodeApp 下载依赖1npm i 测试能否成功访问开启本地服务器： 1node ./bin/www 访问http://localhost:3000 创建数据库打开Wampserver64, 如果是绿色则启动成功 后端根目录下载mysql21npm i mysql2 前端下载axios1npm i axios 后端路由1234567891011121314151617181920212223242526272829303132var express = require(&#x27;express&#x27;);const mysql2 = require(&#x27;mysql2&#x27;)var router = express.Router();/* GET home page. */router.post(&#x27;/login&#x27;,async function(req, res)&#123; a=&#x27;users&#x27; // 创建连接池 const config=handleConfig() const promisePool=mysql2.createPool(config).promise() let users=await promisePool.query(`SELECT * FROM $&#123;a&#125; WHERE name=&#x27;$&#123;req.body.username&#125;&#x27; AND password=&#x27;$&#123;req.body.password&#125;&#x27;`) //sql语句 console.log(users[0]) if(users[0].length)&#123; res.send(&#123;ok:1&#125;) &#125;else&#123; res.send(&#123;ok:0&#125;) &#125;&#125;)module.exports = router;// 连接数据库的基本配置function handleConfig()&#123; return&#123; host:&#x27;localhost&#x27;, port:3306, user:&quot;root&quot;, password:&quot;&quot;, database:&quot;maizuo&quot;, connectLimit:1 &#125;&#125; express设置跨域12345678//设置允许跨域访问该服务.app.all(&#x27;*&#x27;, function (req, res, next) &#123; res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;); res.header(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;); next();&#125;); 前端请求代码12345678axios.post(&#x27;http://localhost:3000/login&#x27;,&#123; username:values.username, password:values.password &#125;).then(res=&gt;&#123; console.log(res.data) &#125;).catch(err=&gt;&#123; console.log(err) &#125;) 到这里就完成最基本的登录鉴权了，接下来进入主题 下载jsonwebtoken1npm i jsonwebtoken 导入1const jwt = require(&#x27;jsonwebtoken&#x27;) 创建一个公共js文件此文件用来存放jsonwebtoken的加密与解密函数 1234567891011121314151617181920const &#123; json &#125; = require(&#x27;express&#x27;)const jwt = require(&#x27;jsonwebtoken&#x27;)const key = &#x27;maizuoc312asdpkj&#x27; //秘钥const obj=&#123; // 加密 sign: function(data,time)&#123; const token=jwt.sign(data, key, &#123; expiresIn: time &#125;) return token &#125;, verify: function(token)&#123; try &#123; return jwt.verify(token, key) &#125; catch (error) &#123; return false &#125; &#125;&#125;module.exports=obj 更改express的路由12345678910111213141516171819router.post(&#x27;/login&#x27;,async function(req, res)&#123; a=&#x27;users&#x27; // 创建连接池 const config=handleConfig() const promisePool=mysql2.createPool(config).promise() let users=await promisePool.query(`SELECT * FROM $&#123;a&#125; WHERE name=&#x27;$&#123;req.body.username&#125;&#x27; AND password=&#x27;$&#123;req.body.password&#125;&#x27;`) //sql语句 if(users[0].length)&#123; mony=users[0][0].mony name=users[0][0].name // 将token放在header中 const token=jwtObj.sign(users[0][0],&#x27;1h&#x27;) res.header(&#x27;Autorization&#x27;, token) res.send(&#123; ok:1 &#125;) &#125;else&#123; res.send(&#123;ok:0&#125;) &#125;&#125;) 使用axios拦截器12345678910111213141516171819// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); 到这里会发现可能拿不到自定义头部在设置跨越那里加上 1res.header(&#x27;Access-Control-Expose-Headers&#x27;, &#x27;Autorization&#x27;); 意思就是允许头部信息Autorization的显示 拿到头部并保存本地1234567891011axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 const autorization = response.headers.autorization autorization &amp;&amp; localStorage.setItem(&#x27;token&#x27;,autorization) return response &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); 每次向后端请求都带上token123456789axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 const token=localStorage.getItem(&#x27;token&#x27;) config.headers.Authorization = `Bearer $&#123;token&#125;` return config &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;); 后端进行接收前端发过来的token进行校验1const examineToken = jwtObj.verify(req.headers.authorization.split(&#x27; &#x27;)[1]) 然后就可以对校验的结果进行自己相关的逻辑处理 总结就是前端输入登录账号与密码，后端进行判断，如果成功，就向前端通过header发送token的值前端接收到token后就存在本地，然后每次向后端发送请求时就带上这个token，后端进行校验后返回值给前端，前端根据后端返回的值再进行业务逻辑的一个处理","tags":["node"],"categories":["前端进阶"]},{"title":"登录鉴权——Cookie与Session(适合后台嵌套模板)","path":"/2023/05/12/18/","content":"本篇文章适合有node基础的同学们哦！我用到的技术 express（基于node的后端） json-server 创建项目1express --view=ejs nodeApp 下载依赖1npm i 测试能否成功访问开启本地服务器： 1node ./bin/www 访问http://localhost:3000 创建一个登录界面在views目录下（ejs）代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;卖座后台登录界面：&lt;/h1&gt; &lt;div&gt; &lt;span&gt;用户:&lt;/span&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; id=&quot;mypassword&quot;&gt; &lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn&quot;&gt;login&lt;/button&gt;&lt;/div&gt; &lt;script&gt; btn.onclick = function () &#123; // console.log(username.value,mypassword.value) fetch(&quot;http://localhost:3001/login&quot;, &#123; method: &#x27;POST&#x27;, headers: &#123; &quot;content-type&quot;: &quot;application/json&quot; &#125;, body: JSON.stringify(&#123; username: username.value, password: mypassword.value &#125;) &#125;).then(res =&gt; res.json()).then(res =&gt; &#123; if(res.ok===1)&#123; alert(&quot;登录成功&quot;) location.href = &#x27;http://localhost:3001/index&#x27; &#125;else&#123; alert(&#x27;登录失败&#x27;) &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建一个登录成功后的跳转界面（ejs）创建完后记得写好接口，渲染这个ejs页面 后台路由代码这里使用fetch一直报错，我不知道什么原因，后面使用了axios(好用，爱用，哈哈哈哈！！) 下载json-server1npm i -g json-server 开启json-server服务这里要注意:express项目与json-server的默认端口都是3000,建议修改express的端口（容易改），在bin目录下修改www即可在你的express项目下创建user.jsonuser.json的内容如下： 1234567891011121314&#123; &quot;users&quot;:[ &#123; &quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&quot;123&quot;, &quot;mony&quot;:&quot;567&quot; &#125;, &#123; &quot;username&quot;:&quot;test&quot;, &quot;password&quot;:&quot;1234&quot;, &quot;mony&quot;:&quot;11&quot; &#125; ]&#125; 执行 1json-server --watch user.json 这样你的user.json这个文件就在json-server的监听下了 下载axios(一种请求方式)1npm i axios 123456789101112131415161718192021222324252627var express = require(&#x27;express&#x27;);var axios = require(&#x27;axios&#x27;)var router = express.Router();/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;login&#x27;);&#125;);router.post(&#x27;/login&#x27;,function(req, res, next) &#123; let dataLength axios.get(&quot;http://localhost:3000/users&quot;).then(re=&gt;&#123; dataLength=re.data.length for(var i=0;i&lt;dataLength;i++)&#123; if(re.data[i].username==req.body.username &amp;&amp; re.data[i].password==req.body.password)&#123; res.send(&#123;ok:1&#125;) return &#125; &#125; if(i===dataLength)&#123; res.send(&#123;ok:0&#125;) &#125; &#125;)&#125;)module.exports = router; 这里作者只是讲一下登录鉴权的一个过程，就没有创建数据库了，正常的应该在路由中去获取数据库的内容，验证前端提交用户名与密码是否正确,作者这里就使用json-server模拟了一下后台数据 到这里最简单的一个登录鉴权就已经写完了但是现在好像不登录直接输入后台url地址也能访问，现在就要进入本篇文章的主题了，使用Express中间件 Express-session 安装express-session中间件1npm i express-session 配置app.js文件导入express-session1const session = require(&#x27;express-session&#x27;) 配置session（记得放在express的路由之前）12345678// 设置sessionapp.use(session(&#123; secret: &#x27;asdjlzxco&#x27;, //秘钥 resave: true, //重新设置session后，就会重新开始计算过期时间 saveUninitialized: true, //一开始访问就会生成一个无效的cookie, cookie: &#123; secure: false, maxAge: 1000*60*60 &#125;, name: &#x27;maiZuo&#x27;&#125;)) 修改post请求的路由(设置req.session.username的值)1234567891011121314151617router.post(&#x27;/&#x27;,function(req, res, next) &#123; let dataLength axios.get(&quot;http://localhost:3000/users&quot;).then(re=&gt;&#123; dataLength=re.data.length for(var i=0;i&lt;dataLength;i++)&#123; if(re.data[i].username==req.body.username &amp;&amp; re.data[i].password==req.body.password)&#123; req.session.username = re.data[i].username res.send(&#123;ok:1&#125;) return &#125; &#125; if(i===dataLength)&#123; res.send(&#123;ok:0&#125;) &#125; &#125;)&#125;) 创建中间件对接口进行拦截123456789101112131415app.use((req,res,next)=&gt;&#123; // 解决重定向次数过多，只要是关于登录有关的接口就放行 if(req.url.includes(&#x27;login&#x27;))&#123; next() return &#125; if(req.session.username)&#123; //重新设置session，刷新过期时间\treq.session.mydate = Date.now() next() &#125;else&#123; // 重定向到登录界面 res.redirect(&#x27;http://localhost:3001/login&#x27;) &#125;&#125;) 整个app.js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var createError = require(&#x27;http-errors&#x27;);var express = require(&#x27;express&#x27;);const session = require(&#x27;express-session&#x27;)var path = require(&#x27;path&#x27;);var cookieParser = require(&#x27;cookie-parser&#x27;);var logger = require(&#x27;morgan&#x27;);var loginRouter = require(&#x27;./routes/login&#x27;);var usersRouter = require(&#x27;./routes/users&#x27;);var app = express();// view engine setupapp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.use(logger(&#x27;dev&#x27;));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 设置sessionapp.use(session(&#123; secret: &#x27;asdjlzxco&#x27;, //秘钥 resave: true, //重新设置session后，就会重新开始计算过期时间 saveUninitialized: true, //一开始访问就会生成一个无效的cookie, cookie: &#123; secure: false, maxAge: 1000*60*60 &#125;, name: &#x27;maiZuo&#x27;&#125;))// 中间件对接口进行拦截app.use((req,res,next)=&gt;&#123; // 解决重定向次数过多，只要是关于登录有关的接口就放行 if(req.url.includes(&#x27;login&#x27;))&#123; next() return &#125; if(req.session.username)&#123; //重新设置session，刷新过期时间\treq.session.mydate = Date.now() next() &#125;else&#123; // 重定向到登录界面 res.redirect(&#x27;http://localhost:3001/login&#x27;) &#125;&#125;)app.use(&#x27;/login&#x27;, loginRouter); //登录界面的路由app.use(&#x27;/&#x27;, usersRouter); //登录成功后界面的路由// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&#x27;env&#x27;) === &#x27;development&#x27; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&#x27;error&#x27;);&#125;);module.exports = app; 到这一步，伙伴们你们已经实现了一个登录鉴权功能了，是不是很简单呢！！登出功能的实现在登录成功后的界面写一个退出按钮123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;卖座后台&lt;/h1&gt; &lt;div&gt;&lt;button id=&quot;btn&quot;&gt;退出登录&lt;/button&gt;&lt;/div&gt; &lt;script&gt; btn.onclick=function()&#123; fetch(&#x27;http://localhost:3001/exit&#x27;).then(res=&gt;res.json()).then(res=&gt;&#123; if(res.ok===1)&#123; location.href = &#x27;./login&#x27; &#125;else&#123; alert(&quot;退出失败&quot;) &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后台退出的接口1234router.get(&#x27;/exit&#x27;, function(req, res, next) &#123; req.session.destroy() res.send(&#123;ok:1&#125;)&#125;); 总结呼！终于写完了，这种方法的弊端还是很多的，一旦登录用户一多，后台内存不断变大，容易导致后台直接奔溃，当然session可以存数据库，但是流量一大对数据库的压力也不小，所以也有另外一种登录鉴权方案——————JWT方案","tags":["node"],"categories":["前端进阶"]},{"title":"Electron的初次认识","path":"/2023/05/10/17/","content":"什么是Electron 简单的讲就是，使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架， 这篇博客将介绍Electron的最基本的使用—–打包自己的博客变成桌面App 创建一个文件夹 初始化，也就是记录版本与使用的依赖包 1npm init 将项目导入 Forge（注意兼容性）12npm install --save-dev @electron-forge/clinpx electron-forge import 这一步可能会出现node版本过高的错误，建议降低node版本（网上有很多教程），使其可以兼容Electron，注意node版本降低后，要重新全局安装npm哦！！ 安装成功后package.json会出现以下内容： 12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron-forge start&quot;, &quot;package&quot;: &quot;electron-forge package&quot;, &quot;make&quot;: &quot;electron-forge make&quot; &#125;, 建立一个js文件名字要与package.json这个相同 1&quot;main&quot;: &quot;index.js&quot;, 将以下内容写入index.js中 1234567891011121314151617181920212223242526272829303132const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)const path = require(&#x27;path&#x27;)function createWindow () &#123; const win = new BrowserWindow(&#123; &lt;!-- 更改窗口尺寸--&gt; width: 1000, height: 800, webPreferences: &#123; preload: path.join(__dirname, &#x27;preload.js&#x27;) &#125; &#125;) win.loadURL(&#x27;自己博客的地址&#x27;)&#125;app.whenReady().then(() =&gt; &#123; createWindow() app.on(&#x27;activate&#x27;, () =&gt; &#123; if (BrowserWindow.getAllWindows().length === 0) &#123; createWindow() &#125; &#125;)&#125;)app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit() &#125;&#125;) 将win.loadURL的地址写上自己博客的即可 执行 1npm start 可以看效果 更改图标修改forge.config.js的内容 123456789101112131415161718192021222324252627const path = require(&#x27;path&#x27;)module.exports = &#123; packagerConfig: &#123; // 自定义图标 icon: path.join(__dirname, &#x27;./favicon.ico&#x27;) &#125;, rebuildConfig: &#123;&#125;, makers: [ &#123; name: &#x27;@electron-forge/maker-squirrel&#x27;, config: &#123;&#125;, &#125;, &#123; name: &#x27;@electron-forge/maker-zip&#x27;, platforms: [&#x27;darwin&#x27;], &#125;, &#123; name: &#x27;@electron-forge/maker-deb&#x27;, config: &#123;&#125;, &#125;, &#123; name: &#x27;@electron-forge/maker-rpm&#x27;, config: &#123;&#125;, &#125;, ],&#125;; 生成桌面应用执行 1npm run make 出现out文件夹，打开里面的.exe文件即可注意ico的尺寸必须是256*256的，不然设置不上去，然后ico图标由于缓存可能会有延迟 我的博客的压缩文件地址https://gitee.com/xiao-zhe-is-not-lazy/lazychild-zip","tags":["Electron"],"categories":["桌面App"]},{"title":"面试题-1（来自b站千峰教育）","path":"/2023/05/04/16/","content":"rem em vw vw 百分比区别 相同点： rem，em，vw，vh，vw属于前端开发除了px单位之外的另外几种单位取值；但是具体含义存在区别 不同点： px：是像素单位，属于绝对单位，是一个具体的大小 rem：相对于根元素进行设置 em：如果自身有字体大小的设置，那么就相对于自身字体大小设置，如果自身没有字体大小设置，那么就相当于父元素进行设置。 vw：1vw相当于浏览器窗口宽度的百分之一 vh：1vh相当于浏览器窗口高度的百分之一 百分比：相对于父元素宽度或者高度的百分之几 注意：vw和vh是视口可以观看的区域的大小；如果没有滚动条的话，则宽度设置成100vw和100%的时候实现的效果一直；如果有滚动的话，则100vw中不是包括滚动条的，100%是包括滚动条的距离的 12345678910111213141516171819&lt;!--注意里面的代码解释说明--&gt; &lt;style&gt; *&#123;margin:0;padding:0&#125; html,body&#123; height: 100%; &#125; .box1&#123; width: 100%; height:500px; background-color: red; &#125; .box2&#123; width: 100vw; height:500px; background-color: green; &#125; &lt;/style&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; 750的设计图，20px为多少rem首先设计图是UI设计提供给前端开发工程师的设计稿，750的设计图出自于手机屏幕为375px*667px的iphone678手机屏幕的设计稿，这里也可以称之为2倍图。20px的字体大小涉及到了单位的转换，页面中默认的字体大小为16px，那么此时的1rem &#x3D; 16px;那么20px通过计算得出公式 1rem &#x3D; 16px; ?rem &#x3D; 20px; 得出结果为:1.25rem 扩展1：因为他的设备像素比（dpr&#x3D;物理像素&#x2F;CSS像素）是2；dpr是一个固定的比值；不同的手机型号比值不应：物理像素：可以理解成你ps里面测量的距离的大小CSS像素：你编写开发代码的时候CSS里面给定的像素值；dpr固定值如下如： app怎么做适配的 基于手机系统开发的app(原生Android&#x2F;IOS) 另外一种是webapp 设置以下标签：1&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;&quot; name=&quot;viewport&quot; /&gt; 具体的含义为：app完成的页面的宽度等于设备的宽度，页面的缩放比例为1.0，不允许最大缩放； 使用媒体查询和响应式做适配 使用媒体查询检测设备屏幕的大小改变布局样式，但是成本耗费比较大，不易操作 使用单位自己单位中经常使用的封装好的flexble.js文件做适配 封装好的flexble.js文件文件可以做到适配，并且原理是已经封装好的视口和设备像素比基于webapp开发 bfc是什么，清楚浮动的原理 BFC含义： 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域 BFC触发条件： 根元素 float属性不为none（脱离文档流） position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inine-flex overflow不为visible BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（按照最大margin值设置） 每个元素的margin box的左边， 与包含块border box的左边相接触 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 计算BFC的高度时，浮动元素也参与计算 boder实现0.5像素实现方法：CSS3有缩放的属性，我们可以利用这个属性，缩小50%的1px的边框，来实现这个功能代码如下： 123456789101112131415161718192021&lt;div class=&quot;border3&quot;&gt; &lt;div class=&quot;content&quot;&gt;伪类设置的边框&lt;/div&gt;&lt;/div&gt; &lt;style&gt;*&#123; margin:0;padding:0&#125;.border3&#123; position: relative; &#125;.border3:before&#123; content: &#x27;&#x27;; position: absolute; width: 200%; height: 200%; border: 1px solid red; transform-origin: 0 0; transform: scale(0.5, 0.5); box-sizing: border-box; &#125;&lt;/style&gt; 场景题（两个盒子，左边固定宽，右边自适应，你能想到几种方法） 公共HTML代码部分 1234&lt;div class=&quot;content&quot;&gt;\t&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\t&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 方法一：float来和BFC实现 123456789101112131415161718&lt;style&gt;.content &#123; border: 1px solid #000; height: 800px; padding: 20px;&#125;.left &#123; width: 200px; height: 100%; background: red; float: left;&#125;.right &#123; height: 100%; background: pink; overflow: hidden;&#125;&lt;/style&gt; 方法二：absolute定位和margin值实现 123456789101112131415161718&lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; &#125; .left &#123; width: 200px; height: 100%; background: red; position: absolute; &#125; .right &#123; height: 100%; background: pink; margin-left: 200px; &#125;&lt;/style&gt; 方法三：calc(100% - 固定内容的宽度) 用calc函数动态计算数值 12345678910111213141516171819&lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; &#125; .left &#123; width: 200px; height: 100%; background: red; float: left; &#125; .right &#123; height: 100%; background: pink; float: left; width: calc(100% - 200px); &#125;&lt;/style&gt; 方法四：flex布局轻松搞定 123456789101112131415161718&lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; display: flex; &#125; .left &#123; width: 200px; height: 100%; background: red; &#125; .right &#123; height: 100%; background: pink; flex: 1; &#125;&lt;/style&gt; 方法五：使用table和table-cell实现 12345678910111213141516171819 &lt;style&gt; .content &#123; border: 1px solid #000; width: 100%; height: 800px; display: table; &#125; .left &#123; width: 200px; height: 100%; background: red; display: table-cell; &#125; .right &#123; height: 100%; background: pink; display: table-cell; &#125;&lt;/style&gt; 方法六：使用inline-block携手calc函数设置宽度 1234567891011121314151617181920212223&lt;style&gt; .content &#123; border: 1px solid #000; width: 100%; height: 800px; font-size: 0; &#125; .left &#123; width: 200px; height: 100%; background: red; display: inline-block; vertical-align: top; &#125; .right &#123; height: 100%; background: pink; display: inline-block; vertical-align: top; width: calc(100% - 200px); font-size: 16px; &#125;&lt;/style&gt; css 选择器有哪些，权重是什么样的选择器含义：选择器是查找页面元素的一种方式方法，选择器的种类有很多种。常用的选择器有以下内容： ID #id class .class 标签 p 通用 * 属性 type&#x3D;”text” 伪类 :link :visited :hover :active 伪元素 ::first-line :first-letter 子选择器 div&gt;p 后代选择器 div p 相邻兄弟 div+p 通用兄弟 div~p 结构伪类 :nth-child :first-child :last-child 权重计算规则： 第一等：代表内联样式，如: style&#x3D;””，权值为1000。 第二等：代表ID选择器，如：#content，权值为0100。 第三等：代表类，伪类和属性选择器，如.content，权值为0010。 第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。 通配符、*权值为0000。 继承的样式没有权重值。 important &gt; 内联 &gt; ID &gt; 类| 伪类 | 属性选择|伪对象 &gt; 标签 &gt; 继承 &gt; 通配符","tags":["一阶段面试题集锦"],"categories":["前端面试题"]},{"title":"菜单栏多色图标","path":"/2023/05/03/15/","content":"这篇文章引自这里https://www.fomal.cc/posts/5389e93f.html,作者怕文章丢失就写在这里啦！找到自己想要的矢量图标推荐网站阿里巴巴矢量图标库 引入下载js代码(butterfly下面的_config.yml)123inject: bottom: - &lt;script src=&quot;/hexo/download/shiLiang/iconfont.js&quot;&gt;&lt;/script&gt; 替换[BlogRoot]\\themes\\butterfly\\layout\\includes\\header\\menu_item.pug为以下代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546if theme.menu .menus_items each value, label in theme.menu if typeof value !== &#x27;object&#x27; .menus_item - const valueArray = value.split(&#x27;||&#x27;) a.site-page.faa-parent.animated-hover(href=url_for(trim(value.split(&#x27;||&#x27;)[0]))) if valueArray[1] i.fa-fw(class=trim(valueArray[1])) - var icon_value = trim(value.split(&#x27;||&#x27;)[1]) - var anima_value = value.split(&#x27;||&#x27;)[2] ? trim(value.split(&#x27;||&#x27;)[2]) : &#x27;faa-tada&#x27; if icon_value.substring(0,2)==&quot;fa&quot; i.fa-fw(class=icon_value + &#x27; &#x27; + anima_value) else if icon_value.substring(0,4)==&quot;icon&quot; svg.icon(aria-hidden=&quot;true&quot; class=anima_value) use(xlink:href=`#`+ icon_value) span=&#x27; &#x27;+label else .menus_item - const labelArray = label.split(&#x27;||&#x27;) - const hideClass = labelArray[3] &amp;&amp; trim(labelArray[3]) === &#x27;hide&#x27; ? &#x27;hide&#x27; : &#x27;&#x27; a.site-page.group.faa-parent.animated-hover(class=`$&#123;hideClass&#125;` href=&#x27;javascript:void(0);&#x27;) if labelArray[1] - var icon_label = trim(label.split(&#x27;||&#x27;)[1]) - var anima_label = label.split(&#x27;||&#x27;)[2] ? trim(label.split(&#x27;||&#x27;)[2]) : &#x27;faa-tada&#x27; if icon_label.substring(0,2)==&quot;fa&quot; i.fa-fw(class=icon_label + &#x27; &#x27; + anima_label) else if icon_label.substring(0,4)==&quot;icon&quot; svg.icon(aria-hidden=&quot;true&quot; class=anima_label) use(xlink:href=`#`+ icon_label) span=&#x27; &#x27;+ trim(labelArray[0]) i.fas.fa-chevron-down ul.menus_item_child each val,lab in value - const valArray = val.split(&#x27;||&#x27;) li a.site-page.child.faa-parent.animated-hover(href=url_for(trim(val.split(&#x27;||&#x27;)[0]))) if valArray[1] - var icon_val = trim(val.split(&#x27;||&#x27;)[1]) - var anima_val = val.split(&#x27;||&#x27;)[2] ? trim(val.split(&#x27;||&#x27;)[2]) : &#x27;faa-tada&#x27; if icon_val.substring(0,2)==&quot;fa&quot; i.fa-fw(class=icon_val + &#x27; &#x27; + anima_val) else if icon_val.substring(0,4)==&quot;icon&quot; svg.icon(aria-hidden=&quot;true&quot; class=anima_val) use(xlink:href=`#`+ icon_val) span=&#x27; &#x27;+ lab 配置butterfly下面的_config.yml123456789menu: 首页: / || icon-shouye2 文章 || icon-xiewenzhang: 归档: /archives/ || icon-guidang 标签: /tags/ || icon-biaoqian 分类: /categories/ || icon-fenlei 友链: /link/ || icon-LINKS 我的: /about/ || icon-gerenzhongxin_wodediqu 留言板: /message/ || icon-liuyanban","tags":["butterfly"],"categories":["魔改"]},{"title":"依赖包与vue版本冲突问题","path":"/2023/05/02/14/","content":"😀😀这篇文章是根据作者自身犯的错误写的，在遇到同类错误时，请根据具体情况去找到自己的错误哦！！ 出现的问题当你下载某个模块时： 错误的解释：这是一个 npm 依赖冲突的错误。具体来说，在解决包的依赖关系时，npm 发现主项目使用了vue: 2.6.14，然后 vue-router 依赖于vue: 3.2.0，两个版本不兼容，导致冲突。 解决方法: 可以尝试在 npm install 命令后加上 –force 或 –legacy-peer-deps 参数来忽略错误，但这可能会导致包的版本兼容性问题。 更好的方法是解决依赖冲突，使得主项目和 vue-router 使用相同的 vue 版本，或者使用兼容的版本。 解决依赖冲突 在 package.json 中修改 vue 的版本号，将版本号更新为 “^3.2.0”（或者，将 vue 的版本设置为 “~2.6.14”，这意味着允许在小版本更新范围内更新版本号） 执行命令：npm update vue 再次执行命令：npm install 命令解释：执行 npm update vue 命令后，npm 会检查所有引用 vue 的包，并在这些包中寻找符合 vue 版本要求的中间版本。如果找到了可更新的版本，npm 就会下载并安装它们。但是，它并不会在 package.json 文件中更新版本号。因此，第三步执行的是 npm install 命令，这样可以确保更新后的依赖关系被记录在 package.json 文件中，以便将来进行版本控制。注意，如果 npm update vue 命令没有更新任何依赖项，则可以跳过第三步。","tags":["vue"],"categories":["前端进阶"]},{"title":"WgpSec CTF(web:尝试找到你的小姐姐吧)","path":"/2023/05/01/13/","content":"作者的啰嗦这是作者第一次更新有关ctf题目的文章，那么什么是CTF比赛呢？CTF是一种流行的信息安全竞赛形式，其英文名可直译为”夺得Flag”，也可意译为”夺旗赛”。其大致流程是，参赛团队之间通过进行攻防对抗、程序分析等形式，率先从主办方给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而夺得分数。为了方便称呼，我们把这样的内容称之为”Flag”。具体的的一些细节，我就不在这里说明了，如果您对CTF感兴趣的话，可以具体找找相关说明。 题目的网站这里是WgpSec CTF官方网站https://ctf.wgpsec.org，然后找到web题目:尝试找到你的小姐姐吧 开始做题在正式开始之前，你需要了解如下： 什么是robots协议 电脑已经有了Python环境，并且下载了pip（我的解题思路会用到Python脚本） 正式开始点进去后发现是这样的 什么都没有先查看一下源代码： 他说百度收录不了，那肯定就是robots协议，什么是robots协议呢？Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。试着访问&#x2F;robots.txt: 发现一个路径：&#x2F;readme_hahah.txt，试着访问它： 这里的信息特别多： 首先用户名是admin 密码是5位的数字 网站的登录网址（被遮盖了一部分） base32位解码将Hint的内容进行base32位解码（网上在线解码即可）： 提示我们用记事本打开最初的那张照片，那我们先右键图片进行下载后打开。可以找到： 这就是登录网址被遮盖的一部分：&#x2F;7b6ca699输入网址：http://web.t.ctf.wgpsec.org/notjustweb/7b6ca699/login.html 脚本爆破这里作者的方法是用Python进行爆破：1234567891011121314151617181920212223import requestsdef num(x): mmm = 6 - x item1 = &#x27;&#x27; ooo = range(1, mmm) for it in ooo: item1 += &#x27;0&#x27; return item1#url = &#x27;http://web.t.ctf.wgpsec.org/notjustweb/7b6ca699/login.php&#x27;data = &#123;&#x27;username&#x27;: &#x27;admin&#x27;, &#x27;password&#x27;: &#x27;00000&#x27;, &#x27;verifycode&#x27;: &#x27;&#x27;, &#x27;submit&#x27;: &#x27;&#x27;&#125;a = range(0, 10000)for item in a: stritem = str(item) newitem = num(len(stritem)) + stritem data[&#x27;password&#x27;] = newitem r = requests.post(url, data) print(r.text + newitem) 得到flag：","tags":["web"],"categories":["ctf"]},{"title":"基于hexo的搜索功能","path":"/2023/04/23/12/","content":"安装依赖包1npm install hexo-generator-search 添加代码至hexo下面的_config.yml文件1234search: path: search.xml field: post content: true 修改butterfly下面的_config.yml文件123local_search: enable: true preload: true 最后在重新部署即可","tags":["hexo"],"categories":["魔改"]},{"title":"更换博客背景2.0版本（自由选择）","path":"/2023/04/18/11/","content":"感觉用js去写html确实有点难度啊，而且js去写html的代码真的很乱（站长能力有限，只能写出这样的代码了，我会继续学习，优化自己的代码的，哈哈哈哈），维护起来不容易啊！！！ 更改后的js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// 适合于电脑的背景var arrImg = [&#x27;https://www.toopic.cn/public/uploads/small/1634204095151163420409592.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/163420343597163420343525.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1637562996238163756299635.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642751534826164275153484.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642751487281164275148774.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642751473324164275147339.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/164275143227816427514329.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642751024946164275102446.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642750988739164275098839.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/164275047944164275047961.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/164275045439516427504541.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642750432122164275043293.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1637562995904163756299548.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1634204739682163420473994.jpg&#x27;]// 适合于手机的背景var arrImg_1=[&#x27;https://www.toopic.cn/public/uploads/small/1643009966127164300996671.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009930474164300993032.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009928240164300992847.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642756678726164275667880.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009950579164300995042.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009929331164300992978.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/16430099287616430099288.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009925630164300992534.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009891321164300989160.jpg&#x27;]var a = document.querySelector(&#x27;.full_page&#x27;)var b = document.querySelector(&#x27;.menus_item&#x27;)var c = document.querySelector(&#x27;#menus&#x27;)var odiv = document.createElement(&#x27;div&#x27;) //创建一个div标签var suoying = parseInt(Math.random() * arrImg.length) //用来记录是第几张图片var suoying_1 = parseInt(Math.random() * arrImg_1.length) //用来记录是第几张图片odiv.innerHTML =\t&#x27;&lt;svg t=&quot;1681093944846&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;4217&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M947.2 173.248c6.912 0 12.8 5.888 12.8 12.8v615.232c0 6.912-5.888 12.8-12.8 12.8H76.8c-6.912 0-12.8-5.888-12.8-12.8V186.048c0-6.912 5.888-12.8 12.8-12.8h870.4m0-64H76.8c-42.24 0-76.8 34.56-76.8 76.8v615.232c0 42.24 34.56 76.8 76.8 76.8h870.4c42.24 0 76.8-34.56 76.8-76.8V186.048c0-42.24-34.56-76.8-76.8-76.8z&quot; fill=&quot;blue&quot; p-id=&quot;4218&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M694.4 760.192H117.824l242.176-257.28c25.344-26.944 66.88-26.944 92.224 0l242.176 257.28z&quot; fill=&quot;aqua&quot; p-id=&quot;4219&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M906.176 760.192H519.296l87.552-92.992 59.84-63.552c25.28-26.944 66.816-26.944 92.16 0l147.328 156.544z&quot; fill=&quot;aqua&quot; p-id=&quot;4220&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M649.792 341.952m-62.976 0a62.976 62.976 0 1 0 125.952 0 62.976 62.976 0 1 0-125.952 0Z&quot; fill=&quot;aqua&quot; p-id=&quot;4221&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;span&gt;更换背景&lt;/span&gt;&#x27;odiv.id = &#x27;custom&#x27; //给自己创建的div标签挂一个id属性，方便对其样式进行修改// 生成弹窗var al = document.querySelector(&#x27;#sidebar&#x27;)$alert1 = document.createElement(&#x27;div&#x27;)$alert2 = document.createElement(&#x27;div&#x27;)$alert5 = document.createElement(&#x27;div&#x27;)$alert6 = document.createElement(&#x27;div&#x27;)$alert7 = document.createElement(&#x27;div&#x27;)$alert8 = document.createElement(&#x27;div&#x27;)$alert9 = document.createElement(&#x27;div&#x27;)$alert10 = document.createElement(&#x27;div&#x27;)$alert11 = document.createElement(&#x27;div&#x27;)$alert12 = document.createElement(&#x27;div&#x27;)$alert13 = document.createElement(&#x27;div&#x27;)$alert14 = document.createElement(&#x27;div&#x27;)$input = document.createElement(&#x27;input&#x27;)$alert1.id = &#x27;alert&#x27;$alert2.id = &#x27;alertcenter&#x27;$alert10.innerHTML = &#x27;🥥🥥更换背景&#x27;$alert7.innerHTML = &#x27;自定义背景：&#x27;$alert8.innerHTML = &#x27;更改&#x27;$alert9.innerHTML = &#x27;&lt;label&gt;×&lt;/label&gt;&#x27;$alert12.innerHTML = &#x27;适合于电脑的背景:&#x27;$alert13.innerHTML = &#x27;适合于手机的背景:&#x27;$alert5.id = &#x27;alertcenterHeader&#x27;$alert6.id = &#x27;alertcenterContent&#x27;$alert8.id = &#x27;aaa&#x27;$alert11.id = &#x27;bbb&#x27;$alert14.id = &#x27;alertcenterContent_1&#x27;$input.type = &#x27;text&#x27;$input.placeholder = &#x27;请输入自定义背景的链接&#x27;$input.id = &#x27;alertcenterContentInput&#x27;odiv.onclick = function() &#123;\t$alert1.style.display = &#x27;block&#x27;&#125;c.appendChild(odiv)console.log(window.document.documentElement.clientWidth)if(window.document.documentElement.clientWidth&lt;500)&#123;\ta.style.backgroundImage = `url($&#123;arrImg_1[suoying_1]&#125;)`&#125;else&#123;\ta.style.backgroundImage = `url($&#123;arrImg[suoying]&#125;)`&#125;al.onclick = function(evt) &#123;\t// 这个if语句是为了只有点击空白处时才会关闭弹窗\tif (evt.target.id == &#x27;alert&#x27;) &#123; $alert1.style.display = &#x27;none&#x27;\t&#125;&#125;// ×的点击事件$alert9.onclick = function() &#123;\t$alert1.style.display = &#x27;none&#x27;&#125;// 判读照片链接的函数function checkImg(imgUrl) &#123;\treturn new Promise((resolve, reject) =&gt; &#123; var ImgObj = new Image() ImgObj.src = imgUrl ImgObj.onload = function(res) &#123; resolve(res) &#125; ImgObj.onerror = function(err) &#123; reject(err) &#125;\t&#125;)&#125;// 更改的事件$alert8.onclick = function() &#123;\tcheckImg($input.value).then(() =&gt; &#123; a.style.backgroundImage = `url($&#123;$input.value&#125;)`\t&#125;).catch(() =&gt; &#123; alert(&#x27;照片链接错误&#x27;)\t&#125;)&#125;al.appendChild($alert1)$alert1.appendChild($alert2)$alert2.appendChild($alert5)$alert2.appendChild($alert12)$alert2.appendChild($alert6)$alert2.appendChild($alert13)$alert2.appendChild($alert14)$alert2.appendChild($alert7)$alert2.appendChild($input)$alert2.appendChild($alert8)$alert5.appendChild($alert11)$alert11.appendChild($alert10)$alert11.appendChild($alert9)// 根据存放的照片数量创建img标签// 电脑背景for (let i = 0; i &lt; arrImg.length; i++) &#123;\tvar img = document.createElement(&#x27;img&#x27;)\timg.src = arrImg[i]\timg.onclick = function() &#123; a.style.backgroundImage = `url($&#123;arrImg[i]&#125;)`\t&#125;\t$alert6.appendChild(img)&#125;// 手机背景for (let i = 0; i &lt; arrImg_1.length; i++) &#123;\tvar img = document.createElement(&#x27;img&#x27;)\timg.src = arrImg_1[i]\timg.onclick = function() &#123; a.style.backgroundImage = `url($&#123;arrImg_1[i]&#125;)`\t&#125;\t$alert14.appendChild(img)&#125;// 适配黑夜模式var changeDark = document.querySelector(&#x27;#darkmode&#x27;)var win = document.querySelector(&#x27;html&#x27;)onscroll = function() &#123; //滚动条滚动就会触发\tif(win.dataset.theme==&#x27;dark&#x27;)&#123; odiv.style.color = &#x27;white&#x27;\t&#125;else&#123; if (window.document.documentElement.scrollTop &gt; 0) &#123; odiv.style.color = &#x27;black&#x27; &#125; else &#123; odiv.style.color = &#x27;white&#x27; &#125;\t&#125;&#125;changeDark.onclick=function()&#123;\t// console.log(win.dataset.theme)\tif(win.dataset.theme==&#x27;light&#x27;)&#123; odiv.style.color = &#x27;white&#x27; $alert2.style.backgroundColor=&#x27;#1c1a1a&#x27; $alert5.style.backgroundColor=&#x27;#283536&#x27; $input.style.backgroundColor=&#x27;black&#x27;\t&#125;else&#123; if (window.document.documentElement.scrollTop &gt; 0) &#123; odiv.style.color = &#x27;black&#x27; &#125; else &#123; odiv.style.color = &#x27;white&#x27; &#125; $alert2.style.backgroundColor=&#x27;white&#x27; $alert5.style.backgroundColor=&#x27;#a3e9eb&#x27; $input.style.backgroundColor=&#x27;white&#x27;\t&#125;&#125;if(win.dataset.theme==&#x27;dark&#x27;)&#123; odiv.style.color = &#x27;white&#x27; $alert2.style.backgroundColor=&#x27;#1c1a1a&#x27; $alert5.style.backgroundColor=&#x27;#283536&#x27; $input.style.backgroundColor=&#x27;black&#x27;\t&#125;else&#123; if (window.document.documentElement.scrollTop &gt; 0) &#123; odiv.style.color = &#x27;black&#x27; &#125; else &#123; odiv.style.color = &#x27;white&#x27; &#125;\t&#125; 更改后的css代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154 /* 背景更换 */ #custom&#123; display: flex; justify-content: space-between; align-items: center; position: absolute; width: 90px; height: 40px; right: 485px; top: 12px; font-size: 0.78em; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif; transition: all 1s; margin-right: 5px; color: white; &#125; #custom:hover&#123; transform: translateX(-0.5rem); &#125; @media screen and (max-width:768px) &#123; #custom&#123;\tright: 70px;&#125; &#125; @media screen and (min-width:768px) and (max-width:824px) &#123; #custom&#123;\tright: 90px;&#125; &#125; @media screen and (max-width:350px) &#123; #custom&#123;\tright: 10px;\ttop: 40px;&#125; &#125; .icon &#123; width: 1.5em; height: 1.5em; vertical-align: -0.45em; fill: currentColor; overflow: hidden; &#125; /* 更换背景的弹窗 */ #alert&#123; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; background-color: rgba(0, 0, 0, 0.8); z-index: 999; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif;; display: none; &#125; #alertcenter&#123; width: 70%; height: 70%; background-color: white; border-radius: 10px; overflow: auto; position: relative; margin: 10vh auto; &#125; #alertcenterHeader&#123; width:70%; height: 33px; background-color: #a3e9eb; line-height: 33px; font-size: 1.1rem; border-radius: 5px 5px 0 0; position: fixed; z-index: 100; &#125; @media screen and (max-width:521px) &#123; #alertcenter&#123; width: 100%; height: 90%; margin: 5vh 0; &#125; #alertcenterHeader&#123; width: 100%; &#125; &#125; #alertcenterContent&#123; width: 100%; display: flex; justify-content: center; flex-wrap: wrap; margin-top: 30px; &#125; #alertcenterContent img&#123; margin: 15px; width: 15%; border-radius: 5px; &#125; #alertcenterContent_1&#123; width: 100%; display: flex; justify-content: center; flex-wrap: wrap; &#125; #alertcenterContent_1 img&#123; margin: 15px; width: 20%; border-radius: 5px; &#125; @media screen and (max-width:780px) &#123; #alertcenterContent img&#123; width: 25%; &#125; &#125; @media screen and (max-width:400px) &#123; #alertcenterContent img&#123; width: 35%; &#125; &#125; #alertcenterContentInput&#123; width: 80%; height: 30px; font-size: 14px; border-radius: 10px; border: 1px solid deepskyblue; display: inline-block; margin-left: 20px; &#125; #aaa&#123; width: 3.875rem; height: 25px; line-height: 25px; text-align: center; font-size: 0.9rem; border: 1px solid black; display: inline-block; margin-left: 0.5rem; border-radius: 4px; &#125; #bbb&#123; height: 33px; display: flex; justify-content: space-between; align-items: center; &#125; #bbb div:nth-child(2)&#123; font-size: 25px; position: fixed; right: 10px; &#125; #alertcenter div:nth-child(2)&#123; position: relative; top: 34px; &#125; 这篇文章后续会持续修改的，请关注一下哦！！！","tags":["butterfly"],"categories":["魔改"]},{"title":"更换博客背景1.0版本（随机背景）","path":"/2023/04/16/10/","content":"提前声明要想完成这个功能你必须会前端三大件（html,css,js）的基础知识，不然你就只能照搬作者的代码，但是里面的内容你是看不懂的哦！！！ 自建与引入css与js文件相信大家应该已经学会了这个步骤了，如果不会的请先移步这篇文章自定义css与js js的代码123456789101112131415161718192021222324252627var arrImg=[&#x27;https://www.toopic.cn/public/uploads/small/1634204095151163420409592.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/163420343597163420343525.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642752073265164275207379.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751728155164275172815.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751487281164275148774.png&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751473324164275147339.png&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/164275143227816427514329.png&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751024946164275102446.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642750988739164275098839.jpg&#x27;]var a=document.querySelector(&#x27;.full_page&#x27;)var b=document.querySelector(&#x27;.menus_item&#x27;)var c=document.querySelector(&#x27;#menus&#x27;)var odiv=document.createElement(&#x27;div&#x27;) //创建一个div标签var suoying=parseInt(Math.random()*arrImg.length) //用来记录是第几张图片odiv.innerHTML=&#x27;&lt;svg t=&quot;1681093944846&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;4217&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M947.2 173.248c6.912 0 12.8 5.888 12.8 12.8v615.232c0 6.912-5.888 12.8-12.8 12.8H76.8c-6.912 0-12.8-5.888-12.8-12.8V186.048c0-6.912 5.888-12.8 12.8-12.8h870.4m0-64H76.8c-42.24 0-76.8 34.56-76.8 76.8v615.232c0 42.24 34.56 76.8 76.8 76.8h870.4c42.24 0 76.8-34.56 76.8-76.8V186.048c0-42.24-34.56-76.8-76.8-76.8z&quot; fill=&quot;blue&quot; p-id=&quot;4218&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M694.4 760.192H117.824l242.176-257.28c25.344-26.944 66.88-26.944 92.224 0l242.176 257.28z&quot; fill=&quot;aqua&quot; p-id=&quot;4219&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M906.176 760.192H519.296l87.552-92.992 59.84-63.552c25.28-26.944 66.816-26.944 92.16 0l147.328 156.544z&quot; fill=&quot;aqua&quot; p-id=&quot;4220&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M649.792 341.952m-62.976 0a62.976 62.976 0 1 0 125.952 0 62.976 62.976 0 1 0-125.952 0Z&quot; fill=&quot;aqua&quot; p-id=&quot;4221&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;span&gt;更换背景&lt;/span&gt;&#x27;odiv.id=&#x27;custom&#x27; //给自己创建的div标签挂一个id属性，方便对其样式进行修改odiv.onclick=function()&#123;\tsuoying++\tif(suoying===arrImg.length)&#123; suoying=0 a.style.backgroundImage=`url($&#123;arrImg[suoying]&#125;)`\t&#125;else&#123; a.style.backgroundImage=`url($&#123;arrImg[suoying]&#125;)`\t&#125;&#125;c.appendChild(odiv)onscroll=function()&#123; //滚动条滚动就会触发 if(window.document.documentElement.scrollTop&gt;0)&#123; odiv.style.color=&#x27;black&#x27; &#125;else&#123; odiv.style.color=&#x27;white&#x27; &#125; &#125;a.style.backgroundImage=`url($&#123;arrImg[suoying]&#125;)` 这里的arrImg数组用来存放照片的链接，可以自行添加照片的链接 css的代码123456789101112131415161718192021222324252627282930313233343536#custom&#123; display: flex; justify-content: space-between; align-items: center; position: absolute; width: 90px; height: 40px; right: 420px; /* 请根据自己的导航栏长度进行修改位置 */ top: 12px; font-size: 0.78em; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif; transition: all 1s; margin-right: 5px; color: white; &#125; #custom:hover&#123; transform: translateX(-0.5rem); &#125; @media screen and (max-width:768px) &#123; #custom&#123; right: 40px; /* 请根据自己的导航栏长度进行修改位置 */\t&#125; &#125; @media screen and (max-width:350px) &#123; #custom&#123; right: 10px; top: 40px;\t&#125; &#125; .icon &#123; width: 1.5em; height: 1.5em; vertical-align: -0.45em; fill: currentColor; overflow: hidden; &#125; 最后不要忘记引入了了哦，小伙伴们！！！ 部署后没有生效的原因如果刷新后没有生效，可以试着清除浏览器数据，再打开自己的博客网站","tags":["butterfly"],"categories":["魔改"]},{"title":"创建express项目","path":"/2023/04/15/9/","content":"安装express我这里是全局安装，去掉-g就不是全局了 1npm install -g express-generator 生成express项目1express myapp 默认生成的是jade的渲染模板更改渲染模板(ejs) 1express --view=ejs myapp 启动express项目在这之前请先执行（下载相关的依赖包）： 1npm i 启动： 1node ./bin/www 查看是否成功express项目默认占用的是3000端口所以去浏览器输入地址http://localhost:3000看看自己有没有成功吧！！","tags":["node"],"categories":["前端进阶"]},{"title":"vue-cli创建vue项目","path":"/2023/04/11/8/","content":"安装vue-cli1npm install -g @vue/cli 创建vue项目1vue create &lt;文件夹名字&gt; 出现： 可以选择默认的vue2项目或者vue3项目，也可以选择最后一条进行手动配置哦启动项目下载完成后尝试启动vue项目在终端执行： 1npm run serve 暂时关闭代码格式检测找到vue.config.js的文件（没有就自己创建） 12345const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave: false, // 暂时关闭代码格式检测&#125;)","tags":["vue"],"categories":["前端进阶"]},{"title":"利用css画图形","path":"/2023/04/10/7/","content":"利用border属性画一个三角形123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box&#123; width: 100px; height: 50px; background: blue; color: white; &#125; .box1&#123; width: 0; height: 0; border: 10px solid rgb(0,0,0,0); /* 将所有边框都透明显示 */ border-top: 10px solid red; /* 只显示上面的边框 */ display: inline-block; position: relative; top: 7px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;导航&lt;span class=&quot;box1&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 利用clip-path属性画一个三角形1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background-color: red; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 怎么样这种方法是不是很方便呢，clip-path属性可不仅仅是画一个简单的三角形，可以画的图形可比你想的还要多呢 clip-path绘制简单图形这里作者就提供一下网站http://tools.jb51.net/code/css3path","tags":["css"],"categories":["前端3大件"]},{"title":"自定义css与js","path":"/2023/04/08/6/","content":"找到butterfly下面的source文件夹（hexo目录下的source文件夹也一样）这是一个静态目录里面可以自定义自己的css与js文件，其实不光是css与js，你的图片与下载好的字体都可以放在这里面 尝试修改自己主题的样式吧如果你还不会css与js，建议前往学习哦！！这里站长就给你提供简单的一个例子在你自定义的css文件下添加一下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 侧边栏个人信息卡片动态渐变色 */#aside-content &gt; .card-widget.card-info &#123; background: linear-gradient( -45deg, #e8d8b9, #eccec5, #a3e9eb, #bdbdf0, #eec1ea ); box-shadow: 0 0 5px rgb(66, 68, 68); position: relative; background-size: 400% 400%; -webkit-animation: Gradient 10s ease infinite; -moz-animation: Gradient 10s ease infinite; animation: Gradient 10s ease infinite !important; &#125; @-webkit-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; @-moz-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; @keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; /* 黑夜模式适配 */ [data-theme=&quot;dark&quot;] #aside-content &gt; .card-widget.card-info &#123; background: #191919ee; &#125; /* 个人信息Follow me按钮 */ #aside-content &gt; .card-widget.card-info &gt; #card-info-btn &#123; background-color: #3eb8be; border-radius: 8px; &#125; 引入css文件 这里虽然是引入字体的地方，也是可以引入css文件的(最好字体的引入与主要的css文件分开)12blog_title_font: font_link: css/custom.css 主要在这里引入123inject: head: # - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/custom.css&quot;&gt; 赶快去试试看自己有没有成功吧！！！ 引入js文件提供一下js的简单代码，用于测试有没有成功引入 1console.log(&#x27;欢迎访问lazychild&#x27;) 开始引入: 123inject: bottom: - &lt;script src=&quot;js/custom.js&quot;&gt;&lt;/script&gt; 成功后重启服务器，打开页面后，按下F12打开console，看看有没有’欢迎访问lazychild’这句话吧，如果有，你就成功了 需要注意小伙伴有没有注意到我这里的引入都是本地引入呢，会出现许多的问题，比如我在引入本地css文件时，只有在首页才有效果，其他页面的没有生效，这就是相对路径引入的问题了，更换引入路径（外网）： 12345678910111213#这是我自己的字体的css文件@font-face &#123; /* 为载入的字体取名字(随意) */ font-family: &#x27;YSHST&#x27;; /* 字体文件地址(相对或者绝对路径都可以) */ src: url(https://xiao-zhe-is-not-lazy.gitee.io/hexo/font/%E9%9C%9E%E9%B6%A9%E6%96%87%E6%A5%B7TC%20Bold_mianfeiziti.com.woff2); /* 定义加粗样式(加粗多少) */ font-weight: normal; /* 定义字体样式(斜体/非斜体) */ font-style: normal; /* 定义显示样式 */ font-display: block; &#125; 然后在修改butterfly下的_config.yml 12blog_title_font: font_link: https://xiao-zhe-is-not-lazy.gitee.io/hexo/css/custom/font.css 12345inject: head: - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://xiao-zhe-is-not-lazy.gitee.io/hexo/css/custom/main.css&quot;&gt; bottom: - &lt;script src=&quot;https://xiao-zhe-is-not-lazy.gitee.io/hexo/js/custom.js&quot;&gt;&lt;/script&gt; 或者(省略掉前面的域名)： 12345inject: head: - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/hexo/css/custom/main.css&quot;&gt; bottom: - &lt;script src=&quot;/hexo/js/custom.js&quot;&gt;&lt;/script&gt; 在本地运行的问题主要就是同源策略的问题，关于什么是同源策略(不同域名，不同端口下就会发生)，就是一个约定，它是浏览器最核心也最基本的安全功能，注意同源策略只会发生在浏览器之间，如果没有同源策略，那么就可以请求任意网站的数据了,直接推送到远程就行，同源策略这个问题就会消失了哦！","tags":["butterfly"],"categories":["魔改"]},{"title":"开启文章封面","path":"/2023/04/07/5/","content":"默认封面的开启找到butterfly下面的_config.yml的文件 1234567891011cover: # display the cover or not (是否顯示文章封面) index_enable: true aside_enable: true archives_enable: true # the position of cover in home page (封面顯示的位置) # left/right/both position: both # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示) default_cover: - https://lskypro.acozycotage.net/Fomalhaut/img/default_cover_14.webp 在default_cover:添加默认封面的图片链接 文章自定义封面开启只要在文章开始添加一个属性 1cover: https://lskypro.acozycotage.net/Fomalhaut/img/default_cover_5.webp 图片来源 直接去别的网站寻找 建立一个远程仓库，将自己的图片放入 图片直接转链接，推荐网站：https://www.imgbed.link/ 重启服务器12$ hexo cl$ hexo s","tags":["butterfly"],"categories":["魔改"]},{"title":"butterfly关于logo图标与头像的增加","path":"/2023/04/06/4/","content":"准备好您的logo很多小伙伴可能对于设计logo这方面没有任何经验，但是又急缺logo，作者在这里推荐一个在线设计logo的网站https://www.logosc.cn/start 关于下载logo需要付费的问题作者这里提供给大家一个小妙招，直接截屏 去掉图片背景颜色大家直接在线去除就行https://www.easeconvert.com/image-remove-background/ 修改配置首先找到butterfly的_config.yml的文件 12345678910111213#修改主页的logonav: logo: img/logo.png display_title: true fixed: true # fixed navigation bar#修改网站标题的logofavicon: /img/favicon.ico#修改头像avatar: img: /img/tou.png effect: false","tags":["butterfly"],"categories":["魔改"]},{"title":"butterfly的安装使用与导航栏基础","path":"/2023/04/04/3/","content":"首先安装butterfly主题在你的根目录下执行 1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 应用butterfly主题找到你hexo的_config.yml文件，更改配置 1theme: butterfly 可能出现的问题(安装插件)如果你沒有 pug 以及 stylus 的渲染器，请下载安裝： 1npm install hexo-renderer-pug hexo-renderer-stylus --save butterfly导航栏的配置默认 12345678910Home: / || fas fa-homeArchives: /archives/ || fas fa-archiveTags: /tags/ || fas fa-tagsCategories: /categories/ || fas fa-folder-openList||fas fa-list: Music: /music/ || fas fa-music Movie: /movies/ || fas fa-videoLink: /link/ || fas fa-linkAbout: /about/ || fas fa-heart 生成新的页面默认安装完成后的butterfly缺少的许多页面，可以根据自己的需要生成举个例子，假如我要生成Tags页面 1hexo new page tags 注意新页面的配置增加一个类型 1type: tags","tags":["butterfly"],"categories":["魔改"]},{"title":"如何部署至Gitee","path":"/2023/04/03/2/","content":"网上也有许多教程，这里作者就是做了一个整理 创建一个Gitee仓库如果不会创建远程仓库的同学，可以先去学习一下哦 开启Gitee Pages先将远程仓库开源，然后在服务选项那里有一个Gitee Pages点进去开启就行(必须设置为开源哦) 一键部署的前提下载hexo-deployer-git 1$ npm install hexo-deployer-git 配置hexo下面的_config.yml1234deploy: type: git repo: (你自己仓库的地址) branch: master 可以在这里找到自己仓库的地址哦 12url: 开启Gitee Pages服务的地址root: 网站的根目录（/&lt;根目录的文件夹名字&gt;） 终端执行的命令12345hexo cl ##清除缓存hexo g ##生成网站静态文件到默认设置的 public 文件夹hexo d ##远程推送至仓库 更新记得更新您的Gitee Pages可能有延迟","tags":["hexo"],"categories":["魔改"]},{"title":"hexo的安装与使用","path":"/2023/04/02/1/","content":"为什么要使用hexo？hexo简单好用 下载node作者这里就只提供一下网站了，安装很简单，node 下载git不会git，建议先学习，这里推荐下载git的比较快的网站，git 查看版本1$ node -v 下载Hexo1$ npm install -g hexo-cli 安装Hexo在你的某个文件夹下，执行： 1$ hexo init 下一篇文章讲如何部署，很多细节哦","tags":["hexo"],"categories":["魔改"]},{"title":"关于站长","path":"/about/index.html","content":"刘哲路漫漫其修远兮,吾将上下而求索. 技术栈 html css js vue react node 微信小程序 uni-app hexo vant element echarts webpack vite nuxt vitepress 兴趣 代码 海贼 吉他 LoL 无畏契约 洛克王国 赚钱"},{"title":"留言","path":"/comments/index.html","content":"Document new Valine({ el: '#vcomments', appId: '1Wgun0BNYRkq1uy13wzMTTlt-gzGzoHsz', appKey: 'LgkvFc6EjDZy8neCIKorXwET', placeholder: '欢迎大家来到lazychild,如果有什么想说的话，请留言给作者哦，作者会尽量快速回复大家的哦😜😜，注意邮箱一定不能写错哦，不然你就收不到作者的回复了', avatar: 'wavatar', pageSize: 4, requiredFields: ['mail'] })"},{"title":"动态","path":"/dynamic/index.html","content":"2024 年 4 月 8 日浏览器平滑滚动：html,body{ scroll-behavior:smooth; }2024 年 3 月 8 日nginx配置反向代理示例：1234# 配置反向代理location /maoyan &#123; proxy_pass https://i.maoyan.com/api/mmdb/movie/v3/list/hot.json?ct=%E5%A8%84%E5%BA%95&amp;ci=274&amp;channelId=4;&#125;说明：当匹配到/maoyan路径请求时会进行反向代理2024 年 1 月 19 日css属性实现宽度自适应内容, width: fit-content;2024 年 1 月 7 日上天赐个我一位美丽的姑娘吧，我想谈恋爱了💓，哈哈哈哈"},{"title":"友链","path":"/friends/index.html","content":"一蓑烟雨的博客Joker2YueMiKeyAkilar糖果屋Fomalhaut🥝"}]