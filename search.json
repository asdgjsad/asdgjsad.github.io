[{"title":"vue3基础知识3","path":"/2024/04/06/58/","content":"slot插槽1. 基本插槽组件： 123456&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 使用者： 123456789&lt;template&gt; &lt;div&gt; &lt;Compo1 title=&quot;游戏列表&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in games&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Compo1&gt; &lt;/div&gt;&lt;/template&gt; 2. 具名插槽组件： 123456&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 使用者： 12345678910111213&lt;template&gt; &lt;div&gt; &lt;Compo1 title=&quot;游戏列表&quot; v-slot:content&gt; &lt;ul&gt; &lt;li v-for=&quot;item in games&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Compo1&gt; &lt;Compo1 title=&quot;美食中国&quot; #content&gt; &lt;img :src=&quot;imgUrl&quot; alt=&quot;&quot;&gt; &lt;/Compo1&gt; &lt;/div&gt;&lt;/template&gt; 3. 作用域插槽组件： 123456&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;slot name=&quot;content&quot; :games=&quot;games&quot; :imgUrl=&quot;imgUrl&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 使用者： 123456789101112&lt;template&gt; &lt;div&gt; &lt;Compo1 title=&quot;游戏列表&quot; v-slot:content = &#x27;params&#x27;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in params.games&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Compo1&gt; &lt;Compo1 title=&quot;美食中国&quot; #content = &#x27;params&#x27;&gt; &lt;img :src=&quot;params.imgUrl&quot; alt=&quot;&quot;&gt; &lt;/Compo1&gt; &lt;/div&gt;&lt;/template&gt; 自定义指令1. 局部注册1234567891011121314&lt;template&gt; &lt;div&gt; &lt;input v-focus type=&quot;text&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;const vFocus = &#123; mounted: (el) =&gt; &#123; el.style.height = &#x27;25px&#x27; el.focus() &#125;&#125;&lt;/script&gt; 2. 全局注册可以自定义一个文件夹directives，将所有指令的逻辑都放在这里 比如我新建一个vFocus.ts文件 123456789const vFocus = &#123; mounted: (el) =&gt; &#123; el.style.height = &#x27;25px&#x27; el.style.border = &#x27;1px dashed black&#x27; el.focus() &#125;&#125;export default vFocus main.js 1234567891011// 引入自定义指令import vFocus from &#x27;@/directives/vFocus&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App);//注册自定义指令 app.directive(&#x27;focus&#x27;, vFocus)app.mount(&#x27;#app&#x27;); shallowRef与shallowReactiveref()与reactive()的浅层作用形式，也就是说只对浅层的数据具有响应式 1234567const state = shallowRef(&#123; count: 1 &#125;)// 不会触发更改state.value.count = 2// 会触发更改state.value = &#123; count: 2 &#125; 123456789101112131415const state = shallowReactive(&#123; foo: 1, nested: &#123; bar: 2 &#125;&#125;)// 更改状态自身的属性是响应式的state.foo++// ...但下层嵌套对象不会被转为响应式isReactive(state.nested) // false// 不是响应式的state.nested.bar++ readonly()与shallowReadonly()readonly()只读代理是深层的：对任何嵌套属性的访问都将是只读的。 1234567891011121314const original = reactive(&#123; count: 0 &#125;)const copy = readonly(original)watchEffect(() =&gt; &#123; // 用来做响应性追踪 console.log(copy.count)&#125;)// 更改源属性会触发其依赖的侦听器original.count++// 更改该只读副本将会失败，并会得到一个警告copy.count++ // warning! 和 readonly() 不同，这里没有深层级的转换：只有根层级的属性变为了只读。 123456789101112131415const state = shallowReadonly(&#123; foo: 1, nested: &#123; bar: 2 &#125;&#125;)// 更改状态自身的属性会失败state.foo++// ...但可以更改下层嵌套对象isReadonly(state.nested) // false// 这是可以通过的state.nested.bar++ toRaw()toRaw() 可以返回由 reactive()、readonly()、shallowReactive() 或者 shallowReadonly() 创建的代理对应的原始对象。 1234const foo = &#123;&#125;const reactiveFoo = reactive(foo)console.log(toRaw(reactiveFoo) === foo) // true markRaw()markRaw 将一个对象标记为不可被转为代理。返回该对象本身。(只对reactive生效) 123456const foo = markRaw(&#123;&#125;)console.log(isReactive(reactive(foo))) // false// 也适用于嵌套在其他响应性对象const bar = reactive(&#123; foo &#125;)console.log(isReactive(bar.foo)) // false customRef()创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。 创建一个hooks： 123456789101112131415161718192021222324import &#123; customRef &#125; from &#x27;vue&#x27;export default function (inputInit, delay) &#123; const input = customRef((track, trigger) =&gt; &#123; let timer return &#123; get() &#123; track() //告诉vue数据inputInit很重要，你要对其进行持续关注，一旦其数据变化就去更新 return inputInit &#125;, set(value) &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; inputInit = value trigger() // 通知vue数据变化了 &#125;, delay) &#125; &#125; &#125;) return &#123; input &#125;&#125; 使用者： 123456789101112&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;input&quot;&gt; &lt;div&gt;&#123;&#123; input &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import useCustomRef from &#x27;./hooks/useCustomRef&#x27;;let &#123;input&#125; = useCustomRef(&#x27;666&#x27;, 2000)&lt;/script&gt; Teleport&lt;Teleport&gt; 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。 12345678&lt;button @click=&quot;open = true&quot;&gt;Open Modal&lt;/button&gt;&lt;Teleport to=&quot;body&quot;&gt; &lt;div v-if=&quot;open&quot; class=&quot;modal&quot;&gt; &lt;p&gt;Hello from the modal!&lt;/p&gt; &lt;button @click=&quot;open = false&quot;&gt;Close&lt;/button&gt; &lt;/div&gt;&lt;/Teleport&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"vue3基础知识2","path":"/2024/04/05/57/","content":"编程式路由导航123456789101112import &#123; useRouter &#125; from &#x27;vue-router&#x27;const router = useRouter()function handleClick(item: any) &#123; router.push(&#123; path: &#x27;/news/details&#x27;, query: &#123; id: item.id, title: item.title &#125;, &#125;)&#125; pinia存储与读取数据存储： 123456789import &#123; defineStore &#125; from &quot;pinia&quot;export const useTagsStore = defineStore(&#x27;tags&#x27;,&#123; state: ()=&gt;&#123; return &#123; dynamicTags : [&#x27;Tag 1&#x27;, &#x27;Tag 2&#x27;, &#x27;Tag 3&#x27;, &#x27;213&#x27;] &#125; &#125;&#125;) 读取： 1234import &#123; useTagsStore &#125; from &#x27;@/store/tags&#x27;const tagsStore = useTagsStore()const dynamicTags = tagsStore.dynamicTags pinia修改数据的2种方式第一种直接修改： 1tagsStore.dynamicTags.splice(tagsStore.dynamicTags.indexOf(tag),1) 第二种（actions） 1234567891011121314import &#123; defineStore &#125; from &quot;pinia&quot;export const useTagsStore = defineStore(&#x27;tags&#x27;,&#123; state: ()=&gt;&#123; return &#123; dynamicTags : [&#x27;Tag 1&#x27;, &#x27;Tag 2&#x27;, &#x27;Tag 3&#x27;] &#125; &#125;, actions: &#123; changeTags(index)&#123; this.dynamicTags.splice(index,1) &#125; &#125;&#125;) 1tagsStore.changeTags(tagsStore.dynamicTags.indexOf(tag)) getters与storeToRefsgetters类似于计算属性，在store中的写法： 12345678910111213141516171819import &#123; defineStore &#125; from &quot;pinia&quot;export const useTagsStore = defineStore(&#x27;tags&#x27;,&#123; state: ()=&gt;&#123; return &#123; dynamicTags : [&#x27;Tag 1&#x27;, &#x27;Tag 2&#x27;, &#x27;Tag 3&#x27;], &#125; &#125;, actions: &#123; changeTags(index)&#123; this.dynamicTags.splice(index,1) &#125; &#125;, getters: &#123; countTags()&#123; return this.dynamicTags.length + &#x27;&#x27; &#125; &#125;&#125;) storeToRefs的使用： 123456789import &#123; useTagsStore &#125; from &#x27;@/store/tags&#x27;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;const tagsStore = useTagsStore()// 这种方式不可取，因为他会把tagsStore中所有的东西都变成ref// let &#123; dynamicTags, countTags &#125; = toRefs(tagsStore)// 推荐这种let &#123; dynamicTags, countTags &#125; = storeToRefs(tagsStore) pinia中的$subscribe$subscribe可以监听数据的更改： 1234567import &#123; useTagsStore &#125; from &#x27;@/store/tags&#x27;const tagsStore = useTagsStore()tagsStore.$subscribe(()=&gt;&#123; console.log(&quot;tagsStore数据发生改变&quot;)&#125;) 组件通信的方式1. props父： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; 我的好朋友是&#123;&#123; a &#125;&#125; &lt;/div&gt; &lt;Compo1 :name1 = &#x27;name&#x27; :getName = &quot;handleName&quot;&gt;&lt;/Compo1&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;import Compo1 from &#x27;@/components/Compo1.vue&#x27;const name = ref(&quot;索隆&quot;)let a = ref(&#x27;&#x27;)function handleName(data)&#123; a.value = data.value&#125;&lt;/script&gt; 子： 123456789101112131415&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; 我的好朋友&#123;&#123; name1 &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;const name = ref(&quot;路飞&quot;)let props = defineProps([&#x27;name1&#x27;,&#x27;getName&#x27;])props.getName(name)&lt;/script&gt; 2. $refs+$parent父： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;Compo1 ref=&quot;a&quot;&gt;&lt;/Compo1&gt; &lt;Compo2 ref=&quot;b&quot;&gt;&lt;/Compo2&gt; &lt;/div&gt; &lt;button @click=&quot;handleClick($refs)&quot;&gt;点击&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo1 from &#x27;@/components/Compo1.vue&#x27;import Compo2 from &#x27;@/components/Compo2.vue&#x27;import &#123;ref, onMounted&#125; from &#x27;vue&#x27;const a = ref()const b = ref()let x = ref(2)let y = ref(10)function handleClick(refs)&#123; console.log(refs.a.title)&#125;onMounted(()=&gt;&#123; console.log(a.value.title)&#125;)defineExpose(&#123;x,y&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 子： 12345678910111213141516171819202122232425&lt;template&gt; &lt;h2&gt; 子组件1 &lt;/h2&gt; &lt;div&gt; &#123;&#123; title &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;handClick($parent)&quot;&gt;获取父组件信息&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;let title = ref(&quot;哈哈哈哈&quot;)let ppp = ref(2)function handClick(parent)&#123; console.log(parent.y)&#125;defineExpose(&#123;title, ppp&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 3. $attrs父： 123456789101112&lt;template&gt; &lt;div&gt; &lt;Compo2 a=&quot;111&quot; b=&quot;222&quot;&gt;&lt;/Compo2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo2 from &#x27;@/components/Compo2.vue&#x27;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 子： 123456789101112131415&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &#123;&#123; $attrs &#125;&#125; // &#123; &quot;a&quot;: &quot;111&quot;, &quot;b&quot;: &quot;222&quot; &#125; &lt;/div&gt; &lt;Compo1 v-bind=&quot;$attrs&quot;&gt;&lt;/Compo1&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import Compo1 from &#x27;./Compo1.vue&#x27;;const name = ref(&quot;索隆&quot;)&lt;/script&gt; 4. defineEmits自定义事件父： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;Compo2 @custom-event=&quot;send&quot;&gt;&lt;/Compo2&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo2 from &#x27;@/components/Compo2.vue&#x27;import &#123;ref&#125; from &#x27;vue&#x27;let name = ref(&#x27;????&#x27;)function send(data)&#123; // console.log(data) name.value = data&#125;&lt;/script&gt; 子： 12345678910111213141516&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;emit(&#x27;custom-event&#x27;, name)&quot;&gt;发送&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;const name = ref(&quot;索隆&quot;)// 自定义事件const emit = defineEmits([&#x27;custom-event&#x27;])&lt;/script&gt; 5. mitt事件总线安装mitt： 1npm install --save mitt 在文件夹utils中新建文件emitter.ts 12345import mitt from &#x27;mitt&#x27;const emitter = mitt()export default emitter 父： 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;Compo2&gt;&lt;/Compo2&gt; &lt;/div&gt; &lt;span&gt;&#123;&#123; name &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo2 from &#x27;@/components/Compo2.vue&#x27;import emitter from &#x27;@/utils/emitter&#x27;import &#123; ref &#125; from &#x27;vue&#x27;let name = ref(&#x27;???&#x27;)emitter.on(&#x27;send&#x27;, (data: any) =&gt; &#123; // console.log(data.value) name.value = data.value&#125;)&lt;/script&gt; 子： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;send&quot;&gt;发送&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import emitter from &#x27;@/utils/emitter&#x27;const name = ref(&quot;索隆&quot;)function send() &#123; emitter.emit(&#x27;send&#x27;, name)&#125;&lt;/script&gt; 6. provide+inject父： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;Compo1&gt;&lt;/Compo1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo1 from &#x27;@/components/Compo1.vue&#x27;import &#123;ref,provide&#125; from &#x27;vue&#x27;let x = ref(2)let y = ref(10)// 向后代提供数据provide(&#x27;x&#x27;,x)provide(&#x27;y&#x27;,y)&lt;/script&gt; 子： 1234567891011121314151617181920&lt;template&gt; &lt;h2&gt; 子组件1 &lt;/h2&gt; &lt;div&gt; &#123;&#123; title &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref,inject&#125; from &#x27;vue&#x27;let title = ref(&quot;哈哈哈哈&quot;)let m = ref(1)// 接收数据let x = inject(&#x27;x&#x27;,m)let y = inject(&#x27;y&#x27;,m)console.log(x.value,y.value)&lt;/script&gt; 7. v-model我们都知道在input标签上使用v-model，那么如果要想用在组件上，该怎么做呢？ 父： 12345678910111213&lt;template&gt; &lt;div&gt; &lt;Compo2 v-model=&quot;text&quot;&gt;&lt;/Compo2&gt; &#123;&#123; text &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import Compo2 from &#x27;@/components/Compo2.vue&#x27;import &#123; ref &#125; from &#x27;vue&#x27;let text = ref(&#x27;asd&#x27;)&lt;/script&gt; 子： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;!-- 传统写法 --&gt; &lt;!-- &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emit(&#x27;update:modelValue&#x27;, (&lt;HTMLInputElement&gt;$event.target).value)&quot;&gt; --&gt; &lt;!-- 新型写法 --&gt; &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;change&quot;&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;const name = ref(&quot;索隆&quot;)// 传统写法// defineProps([&#x27;modelValue&#x27;])// const emit = defineEmits([&#x27;update:modelValue&#x27;])// 3.4+推荐写法const model = defineModel()function change(e)&#123; model.value = e.target.value&#125;&lt;/script&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"vue3基础知识1","path":"/2024/04/05/56/","content":"toRef与toRefs使用它，消费者组件可以解构&#x2F;展开返回的对象而不会失去响应性： 123456789101112131415import &#123; reactive,toRefs,toRef &#125; from &#x27;vue&#x27;const person = reactive(&#123; name: &#x27;张三&#x27;, age: 18&#125;)const cityObj = reactive(&#123; name: &#x27;北京&#x27;, id: &#x27;asdasxzc&#x27;&#125;)// 消费者组件可以解构/展开返回的对象而不会失去响应性let &#123; name, age &#125; = toRefs(person)let city = toRef(cityObj,&#x27;name&#x27;) computed()函数创建一个只读的计算属性 ref： 123456const count = ref(1)const plusOne = computed(() =&gt; count.value + 1)console.log(plusOne.value) // 2plusOne.value++ // 错误 创建一个可写的计算属性 ref： 12345678910const count = ref(1)const plusOne = computed(&#123; get: () =&gt; count.value + 1, set: (val) =&gt; &#123; count.value = val - 1 &#125;&#125;)plusOne.value = 1console.log(count.value) // 0 watch()函数用于声明在数据更改时调用的侦听回调。 **immediate**：在侦听器创建时立即触发回调。第一次调用时，旧值将为 undefined。 **deep**：如果源是对象或数组，则强制深度遍历源，以便在深度变更时触发回调。详见深层侦听器。 **flush**：调整回调的刷新时机。详见回调的触发时机及 watchEffect()。 **onTrack / onTrigger**：调试侦听器的依赖关系。详见侦听器调试。 监听ref数据时： 12345678910111213let person = ref(&#123; name: &quot;张三&quot;, age: 18&#125;)// 默认是不会开启深度监听的，如果需要开启深度监听，需要在watch中传入deep参数// deep: truewatch(person, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal)&#125;, &#123; deep: true&#125;) 监听reactive数据时： 123456789let person = reactive(&#123; name: &quot;张三&quot;, age: 18&#125;)// 默认开启深度监听,并且无法修改watch(person, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue)&#125;) ​\t监听响应式对象中的单个属性 12345678910111213141516171819202122232425const person = reactive(&#123; name: &#x27;张三&#x27;, age: 18, adress: &#123; city: &#x27;北京&#x27;, street: &#x27;北京路&#x27; &#125;&#125;)// 如果要监听某个属性，可以使用getter函数// 1.如果这个属性值是基本类型，只能写成getter函数watch(()=&gt;person.name, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal)&#125;)/* 2.如果这个属性值是对象，如果写成getter函数， 那么就是监听的地址的变换，里面单个属性变化监听不到，但是可以开启deep，进行深度监听 如果不写成函数，那么就是监听里面单个属性的变化，无法监听地址的变换*/watch(()=&gt;person.adress, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal)&#125;) 监听响应式对象中的单个属性: 1234// 如果要监听多个属性，写成数组即可watch([()=&gt;person.name, ()=&gt;person.adress], (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal)&#125;) watchEffect()函数立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。 与watch的区别：watch需要指定数据源进行监听 12345678let height = ref(0)let weight = ref(0)watchEffect(() =&gt; &#123; if(height.value &gt; 5 &amp;&amp; weight.value &gt; 10)&#123; console.log(&quot;发送服务器消息&quot;) &#125;&#125;) ref与dom结构的联动使用选项式 API，引用将被注册在组件的 this.$refs 对象里： 12&lt;!-- 存储为 this.$refs.p --&gt;&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt; 使用组合式 API，引用将存储在与名字匹配的 ref 里： 123456789&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const p = ref()&lt;/script&gt;&lt;template&gt; &lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;&lt;/template&gt; 用于组件时： 1234567891011121314151617// test组件&lt;template&gt; &lt;h2&gt;我是一个组件&lt;/h2&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;let a = ref(0)let b = ref(1)let c = ref(2)defineExpose(&#123;a,b,c&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button @click=&quot;getDom&quot;&gt;获取dom&lt;/button&gt; &lt;test ref=&quot;tes&quot;&gt;&lt;/test&gt;&lt;/template&gt;import test from &#x27;./components/test.vue&#x27;let tes = ref();// 如果想要获取组件里面的变量，需要组件自行导出function getDom() &#123; console.log(tes.value.a); console.log(tes.value.b); console.log(tes.value.c);&#125; defineProps()12345// 类型限制+默认值+是否必传let props = withDefaults(defineProps&lt;&#123;list?:PersonList&#125;&gt;(),&#123; // 默认值 list:()=&gt;[&#123;id:&#x27;asdasdzxc&#x27;,name:&#x27;海尔&#x27;,age:22&#125;]&#125;) 基本路由123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;import Home from &#x27;@/views/Home.vue&#x27;;import News from &#x27;@/views/News.vue&#x27;;import About from &#x27;@/views/About.vue&#x27;;import NewsDetails from &#x27;@/views/NewsDetails.vue&#x27;;const router = createRouter(&#123; history: createWebHistory(), routes: [ &#123; path: &#x27;/home&#x27;, component: Home, &#125;, &#123; path: &#x27;/news&#x27;, component: News, children: [ &#123; path: &#x27;details&#x27;, component: NewsDetails, &#125;, ], &#125;, &#123; path: &#x27;/about&#x27;, component: About, &#125;, // 重定向 &#123; path: &#x27;/:pathMatch(.*)*&#x27;, redirect: to =&gt; &#123; return &#123; path: &#x27;/home&#x27; &#125;; &#125;, &#125;, ]&#125;)export default router; query传参当我点击某个按钮，让它跳转到新闻详情页面时：&#x2F;news&#x2F;details?id&#x3D;${item.id}&amp;title&#x3D;${item.title} 如何接收传的值呢？ 12345678910111213&lt;template&gt; &lt;div&gt; 新闻详情 &lt;ul&gt; &lt;li&gt;&#123;&#123; route.query.id &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; route.query.title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123;useRoute&#125; from &quot;vue-router&quot;;const route = useRoute();&lt;/script&gt; params传参也就是需要这样传参：&#x2F;news&#x2F;details&#x2F;${item.id}&#x2F;${item.title} 此时要怎样接收参数呢？ 改变路由结构： 12345678910&#123; path: &#x27;/news&#x27;, component: News, children: [ &#123; path: &#x27;details/:id/:title&#x27;, component: NewsDetails, &#125;, ],&#125;, 接收： 123456789101112&lt;template&gt; &lt;div&gt; 新闻详情 &lt;ul&gt; &lt;li&gt;&#123;&#123; route.params.id &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; route.params.title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123;useRoute&#125; from &quot;vue-router&quot;;const route = useRoute(); 路由props配置之前所说的query传参和params传参，在接收时感觉比较繁琐，接下来看看路由props配置，告别繁琐 首先改变路由： 123456789101112131415161718&#123; path: &#x27;/news&#x27;, component: News, children: [ &#123; path: &#x27;details&#x27;, component: NewsDetails, // 第一种params写法 // props: true, // 第二种query写法 props(route)&#123; return route.query; &#125;, &#125;, ],&#125;, 接收： 123456789101112&lt;template&gt; &lt;div&gt; 新闻详情 &lt;ul&gt; &lt;li&gt;&#123;&#123; id &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;defineProps([&#x27;id&#x27;, &#x27;title&#x27;])&lt;/script&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"md文件的解析、渲染与目录文件读取","path":"/2024/03/31/55/","content":"markdown文件内容的读取使用markdown-it的插件 1npm install markdown-it 123456import MarkdownIt from &quot;markdown-it&quot;import contentMd from &quot;@/article/1.md?raw&quot;const markdownit = new MarkdownIt()console.log(markdownit.render(contentMd)) markdown的渲染markdown-it只能将markdown文件转换为html标签，但是没有css样式，网上有很多插件对其进行美化，推荐一个网站：Themes Gallery — Typora 目录文件读取123456const localeResourceFiles = import.meta.glob(&#x27;@/article/*.md&#x27;, &#123; eager: true, import: &#x27;default&#x27;&#125;)console.log(localeResourceFiles)","tags":["vue"],"categories":["前端进阶"]},{"title":"js基础篇4","path":"/2024/03/21/54/","content":"proxy123456789101112131415161718192021222324 let obj = &#123; name: &#x27;tom&#x27;, &#125; // 使用 proxy 监听 obj 的变化 proxy = new Proxy(obj, &#123; get(target, key) &#123; console.log(`get $&#123;key&#125;`) if (key === &#x27;name&#x27;) &#123; a.innerHTML = target[key] &#125; return target[key] &#125;, set(target, key, value) &#123; console.log(`set $&#123;key&#125; = $&#123;value&#125;`) if (key === &#x27;name&#x27;) &#123; a.innerHTML = value &#125; target[key] = value return true &#125; &#125;)proxy.name// get name Reflect配合proxy12345678910111213let obj = &#123;&#125;let proxy = new Proxy(obj, &#123; get(target, key) &#123; console.log(`get $&#123;Reflect.get(target, key)&#125;`) // return Reflect.get(target, key) return Reflect.get(...arguments) &#125;, set(target, key, value) &#123; console.log(`set $&#123;key&#125; = $&#123;value&#125;`) Reflect.set(...arguments) return true &#125;&#125;) promise相关api一个 Promise 必然处于以下几种状态之一： ​ 1.待定（pending）：初始状态，既没有被兑现，也没有被拒绝。 ​ 2.已兑现（fulfilled）：意味着操作成功完成。 ​ 3.已拒绝（rejected）：意味着操作失败。 ajax函数 123456789101112131415function ajax(str, time, isSuccess) &#123; if (isSuccess)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(str); &#125;, time); &#125;); &#125;else&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(str); &#125;, time); &#125;); &#125;&#125; Promise.all() 等待所有 Promise, 在任意一个 Promise 被拒绝时拒绝 123456 Promise.all([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;)// [&#x27;1&#x27;, &#x27;2&#x27;] Promise.race() 看哪一个 Promise 先被执行完，就执行哪一个 Promise 123456Promise.race([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;)// 1 Promise.any() 当输入的任何 promise 实现时，此返回的 promise 将实现，并具有第一个 fulfillation 值。当所有输入的 promise 都拒绝时（包括传递空可迭代对象时），它会拒绝 123456Promise.any([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err, &#x27;拒绝&#x27;)&#125;)// 2 Promise.allSettled() 无论任何 promise 实现，此返回的 promise 都将实现，并具有一个数组，其中包含每个输入 promise 的状态和值。 12345678910Promise.allSettled([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, false)]).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;)/*[&#123;…&#125;, &#123;…&#125;]0: &#123;status: &#x27;rejected&#x27;, reason: &#x27;1&#x27;&#125;1: &#123;status: &#x27;rejected&#x27;, reason: &#x27;2&#x27;&#125;*/","tags":["js"],"categories":["前端3大件"]},{"title":"MongoDB的安装与使用","path":"/2024/03/16/53/","content":"安装下载官网（社区版）：Download MongoDB Community Server | MongoDB 根据自己的操作系统下载即可 配置环境变量（方便后续的启动）找到系统环境变量的编辑界面 添加自己下载好的mongodb的bin路径即可 最后进行测试，输入mongod，没有报错说明配置成功（这个命令主要用来启动mongodb） 启动mongo服务在启动之前必须配置mongo服务数据存放的文件夹，比如我在mongo安装的目录下，新建了一个db文件夹，用来存放数据库内容：D:\\Database\\MongoDB\\db， 启动方法 1mongod --dbpath D:\\Database\\MongoDB\\db 启动后不能关闭终端，不然会中断mongo的服务 node连接mongoDB 这里用express框架进行演示 1. 模块下载1npm i mongoose 2. 连接建议放在单独的一个文件中，方便管理 12345678910111213const mongoose = require(&#x27;mongoose&#x27;);const dbURL = &#x27;mongodb://127.0.0.1:27017/managerCool&#x27;;// 连接数据库mongoose.connect(dbURL);// 绑定数据库连接监听mongoose.connection.on(&quot;open&quot;, (err) =&gt; &#123; if (err) &#123; cosnole.log(&quot;连接失败...&quot;, err); &#125; else &#123; console.log(&quot;mongodb连接成功&quot;); &#125;&#125;) 在入口文件中进行引入即可 12// 连接数据库require(&#x27;../connect_db/mongo&#x27;) 3. 创建模型（需要连接的表）上述步骤已经成功连接到了具体的数据库了，而大家都知道库中是不是有具体的表，这是mysql的称呼，在mongodb中称为模型，建议将所有的创建模型的文件单独存放到一个文件夹中 比如我要连接introduction的模型 12345678910const mongoose = require(&#x27;mongoose&#x27;)const IntroductionType = &#123; title:String, value:String&#125;const IntroductionModel = mongoose.model(&#x27;introduction&#x27;, new mongoose.Schema(IntroductionType))module.exports = IntroductionModel 查询 比如我要查询introduction中的所有内容 12345678910const IntroductionModel = require(&#x27;../model/IntroductionModel&#x27;)router.get(&#x27;/&#x27;, function (req, res, next) &#123; IntroductionModel.find().then(data=&gt;&#123; console.log(data) &#125;) res.send(&#123; ok: 1 &#125;)&#125;); 修改 注意updateOne里面的第二个字段，对应的是new mongoose.Schema(IntroductionType))里面的字段，如果不对应的话是无法修改的哦 123456789101112router.post(&#x27;/api/change/homeData/:id&#x27;, (req, res)=&gt;&#123; IntroductionModel.updateOne(&#123;_id: req.body._id&#125;,&#123; title: req.body.title, value: req.body.value &#125;).then(result=&gt;&#123; console.log(result) res.send(&#123;ok:1&#125;) &#125;).catch(err=&gt;&#123; console.log(err) res.send(&#123;ok:0&#125;) &#125;)&#125;)","tags":["node"],"categories":["前端进阶"]},{"title":"js基础篇3","path":"/2024/03/14/52/","content":"数组扩展 拆分多维数组flat 123let arr = [1,2,[3,4,[5,6]]]console.log(arr.flat(2))// [1, 2, 3, 4, 5, 6] 数组元素修改fill 12345678 /* fill(value) fill(value, start) fill(value, start, end) */let arr = [1, 2, 3, 4, 5]console.log(arr.fill(10, 2))// [1, 2, 10, 10, 10] 只改变数组其中一个元素with 123let arr = [1, 2, 3, 4, 5]console.log(arr.with(1, 100))// [1, 100, 3, 4, 5] 对象扩展1. 判断一个对象是否存在特定属性12345678910111213let obj = &#123; name: &#x27;xiaoming&#x27;, age: 18&#125;// hasOwnPropertyconsole.log(obj.hasOwnProperty(&#x27;name&#x27;))// inconsole.log(&#x27;name&#x27; in obj)// Reflect.has()console.log(Reflect.has(obj, &#x27;name&#x27;)) 2. Object.assign() 拼接 123456789101112let obj1 = &#123; name: &#x27;John&#x27;, age: 30, city: &#x27;New York&#x27;&#125;let obj2 = &#123; age: 25, country: &#x27;USA&#x27;&#125;let obj3 = Object.assign(obj1, obj2)console.log(obj3)// &#123;name: &#x27;John&#x27;, age: 25, city: &#x27;New York&#x27;, country: &#x27;USA&#x27;&#125; 很多人可能会想到这种方式可不可以用来复制一个对象，我告诉你结果：不完全可以，为什么这样说，大家看如下代码： 1234567891011121314let obj4 = &#123; nameValue: &#x27;xiaoming&#x27;, age: 18, get name() &#123; console.log(&#x27;get name&#x27;) &#125;, set name(value) &#123; console.log(&#x27;set name&#x27;) &#125;&#125;let obj5 = &#123;&#125;let obj6 = Object.assign(obj5, obj4)console.log(obj6)// &#123;nameValue: &#x27;xiaoming&#x27;, age: 18, name: undefined&#125; 当这个对象中有get 或者 set 时就不行了 3. getOwnPropertyDescriptors()返回给定对象的所有自有属性描述符 12345678910111213let obj4 = &#123; nameValue: &#x27;xiaoming&#x27;, age: 18, get name() &#123; console.log(&#x27;get name&#x27;) &#125;, set name(value) &#123; console.log(&#x27;set name&#x27;) &#125;&#125;let obj7 = Object.getOwnPropertyDescriptors(obj4)obj7.name.get()// get name 4. Object.keys()​ 返回一个由给定对象自身的可枚举的字符串键属性名组成的数组。 1234567let obj1 = &#123; name: &#x27;John&#x27;, age: 30, city: &#x27;New York&#x27;&#125;console.log(Object.keys(obj1))// [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;] 5. Object.values()​ 返回一个由所有自身属性值的数组，包括不可枚举属性值。 12console.log(Object.values(obj1))// [&#x27;John&#x27;, 30, &#x27;New York&#x27;] 6. Object.entries()​ 返回一个数组，包含给定对象自有的可枚举字符串键属性的键值对。 12345678console.log(Object.entries(obj1))/*[ [&#x27;name&#x27;, &#x27;John&#x27;] [&#x27;age&#x27;, 30] [&#x27;city&#x27;, &#x27;New York&#x27;]\t]*/ 7. Object.create​ 以一个现有对象作为原型，创建一个新对象。 1234567891011121314151617181920212223242526 let obj1 = &#123; nameValue: &#x27;John&#x27;, age: 30, city: &#123; name: &#x27;New York&#x27;, population: 800000 &#125;, get name() &#123; console.log(&#x27;get name&#x27;) return this.nameValue &#125;, set name(value) &#123; console.log(&#x27;set name&#x27;) &#125; &#125; let obj3 = Object.create( Object.getPrototypeOf(obj1), Object.getOwnPropertyDescriptors(obj1), );console.log(obj3)// &#123;nameValue: &#x27;John&#x27;, age: 30, city: &#123;…&#125;&#125;console.log(obj3.name)// get name// John 获取css中的变量123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;简单的背景选择&lt;/title&gt; &lt;style&gt; :root&#123; --color: #000; &#125; body&#123; height: 96vh; background-color: var(--color); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;color&quot; id=&quot;color&quot;&gt; &lt;script&gt; // 获取css中变量的值 const rootColor = getComputedStyle(document.documentElement).getPropertyValue(&#x27;--color&#x27;); let colorSelector = document.querySelector(&#x27;#color&#x27;); colorSelector.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; // 通过改变css变量，改变页面背景色 document.documentElement.style.setProperty(&#x27;--color&#x27;, e.target.value); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; class新增 在属性面前在一个#，就是私有属性 1234567891011121314class Person &#123; static a = 1; // 定义私有属性 #privateName = &#x27;tiechui&#x27; constructor(name, age) &#123; this.name = name; this.age = age; this.privateName = this.#privateName &#125; // 定义一个方法 sayHello() &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); &#125;&#125; 静态代码块，当这个类被定义后，代码块会自动执行 1234567class test&#123; static n = 1 static &#123; console.log(&#x27;静态代码块&#x27;, this.n) &#125;&#125;// 静态代码块 1 异步迭代123456789101112131415161718192021222324252627282930313233function ajax(str, time) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(str); &#125;, time); &#125;);&#125;// 迭代器async function* foo() &#123; yield ajax(&#x27;a&#x27;,1000); yield ajax(&#x27;b&#x27;,1000); yield ajax(&#x27;c&#x27;,1000);&#125;let str = &#x27;&#x27;;let Foo = foo();Foo.next().then(res=&gt;&#123; console.log(res);&#125;)// &#123;value: &#x27;a&#x27;, done: false&#125;async function generate() &#123; for await (var val of foo()) &#123; str = str + val; console.log(val); &#125; console.log(str);&#125;generate();// a// b// c// abc 正则扩展123456789let str = &#x27;今天是2023-12-23&#x27;let reg = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;mounth&gt;\\d&#123;1,2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/let reg1 = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;mounth&gt;\\d&#123;1,2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/dconsole.log(reg.exec(str))// [&#x27;2023-12-23&#x27;, &#x27;2023&#x27;, &#x27;12&#x27;, &#x27;23&#x27;, index: 3, input: &#x27;今天是2023-12-23&#x27;, groups: &#123;…&#125;]console.log(reg1.exec(str))// [&#x27;2023-12-23&#x27;, &#x27;2023&#x27;, &#x27;12&#x27;, &#x27;23&#x27;, index: 3, input: &#x27;今天是2023-12-23&#x27;, groups: &#123;…&#125;, indices: Array(4)] 字符串扩展 includes函数可以判断字符串中是否含有指定字符串 123let str = &quot;helloworld&quot;console.log(str.includes(&quot;h&quot;))// true startsWith和endsWith方法可以判断字符串是否以指定字符串开头或结尾 1234567let str = &quot;hello&quot;console.log(str.startsWith(&quot;h&quot;))// trueconsole.log(str.startsWith(&quot;h&quot;, 1))// falseconsole.log(str.endsWith(&quot;o&quot;))// true 字符串的repeat方法可以重复字符串 123456let str = &quot;hello&quot;console.log(str.repeat(3))// hellohellohelloconsole.log(str.repeat(0)===&#x27;&#x27;)// true 字符串的padStart和padEnd方法可以对字符串进行填充 123456let str = &quot;hello&quot;console.log(str.padStart(10, &quot;world&quot;))// worldhelloconsole.log(str.padEnd(10, &quot;world&quot;))// helloworld at方法（寻找数组内的元素）1234567let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]console.log(arr.at(1))// 2console.log(arr.at(-1))// 10","tags":["js"],"categories":["前端3大件"]},{"title":"js基础篇2","path":"/2024/03/08/51/","content":"获取dom节点尺寸123456var omw=document.querySelector(&#x27;#box&#x27;)// 获取宽高console.log(omw.offsetWidth,omw.offsetHeight)// 获取宽高（不计算边框）console.log(omw.clientWidth,omw.clientHeight) 获取dom节点偏移量1234var a=document.querySelector(&#x27;.box&#x27;)// 获取节点相对于父节点的偏移量（要求父节点要设置position），否则根据整个页面进行计算console.log(a.offsetLeft,a.offsetTop) 获取可视窗口尺寸12345// 包括滚动条console.log(innerWidth,innerHeight)// 不包括滚动条console.log(window.document.documentElement.clientWidth,document.documentElement.clientHeight) 基本事件类型 单击：click 双击：dblclick 右键：contextmenu 鼠标按下：mousedown 鼠标抬起：mouseup 鼠标移动：mousemove 移入（包括子节点）：mouseover 移入（不包括子节点）：mouseenter 移出（包括子节点）：mouseout 移出（不包括子节点）：mouseleave 键盘按下：keydown 键盘抬起：keyup 得到焦点：focus 失去焦点：blur 内容改变：input 前后内容不一致：change 重置：reset 提交：submit 触摸开始：touchstart 触摸结束：touchend 触摸移动：touchmove 常用鼠标事件对象（event）12345678box.onclick = function (evt) &#123; //距离可视窗口的位置 console.log(evt.clientX, evt.clientY) //距离整个页面的位置，不受滚动条影响 console.log(evt.pageX, evt.pageY) //距离自己左上角的位置 console.log(evt.offsetX, evt.offsetY) &#125; 阻止事件传播123ob.onclick=function(evt)&#123; evt.stopPropagation() //阻止这个按钮事件往下传播&#125; 正则表达式 基本元字符 \\d 数字 \\D 非数字 \\s 空白（空格、缩进、换行） \\S 非空白 \\w 字母、数字或下划线 \\W 非字母、数字或下划线 . 任意内容 \\ 转义字符 边界符 ^ 开头 $ 结尾 限定符 * 0~多次 + 1~多次 ? 0~1 {n} 限定n次,必须连续 {n,} &gt;&#x3D;n {n,m} n~m 特殊符号 ( ) 作为整体 | 或(两边默认为整体) [] 表示里面只要有一个就行 [^abc]表示取反，不是abc其中一个 正则两大特新 懒惰性，解决：使用全局标识符g 贪婪 可以加个？，变成非贪婪 123456var reg1=/\\d&#123;1,4&#125;/ //贪婪var reg2=/\\d&#123;1,4&#125;?/ //非贪婪console.log(reg1.exec(&#x27;ab1234d&#x27;)[0])// 1234console.log(reg2.exec(&#x27;ab1234d&#x27;)[0])// 1 this指向问题 call apply bind call 与 apply都会自动执行函数，区别：传入参数的形式不同 bind不会自动执行函数 1234567891011121314151617181920212223242526obj1=&#123; name:&#x27;obj1&#x27;, getName:function(a,b,c)&#123; console.log(&#x27;getName1&#x27;,this.name) console.log(&#x27;参数&#x27;,a,b,c) &#125;&#125;obj2=&#123; name:&#x27;obj2&#x27;, getName:function()&#123; console.log(&#x27;getName2&#x27;,this.name) &#125;&#125;obj1.getName.call(obj2,1,2,3)// getName1 obj2// 参数 1 2 3obj1.getName.apply(obj2,[1,2,3])// getName1 obj2// 参数 1 2 3var fun= obj1.getName.bind(obj2,1,2,3)fun()// getName1 obj2// 参数 1 2 3 继承 1 123456789101112131415161718192021function Person(name,age)&#123; this.myname=name this.myage=age&#125;Person.prototype.mysay=function()&#123; console.log(&#x27;hello&#x27;,this.myname)&#125;function Student(name,age,grade)&#123; // 继承 Person.apply(this,[name,age]) this.grade=grade&#125;// 原型的继承Student.prototype=new Person()let stu=new Student(&#x27;pig&#x27;,14,100)console.log(stu)// &#123;myname: &#x27;pig&#x27;, myage: 14, grade: 100&#125;stu.mysay()// hello pig 2 123456789101112131415161718192021class Person&#123; constructor(name, age)&#123; this.myname = name this.age = age &#125; mysay()&#123; console.log(&#x27;hello&#x27;,this.myname) &#125;&#125;class Student extends Person&#123; constructor(name, age, grade)&#123; super(name, age) this.grade = grade &#125;&#125;let stu = new Student(&#x27;xz&#x27;,18,99)console.log(stu)// &#123;myname: &#x27;xz&#x27;, age: 18, grade: 99&#125;stu.mysay()// hello xz 数学方法 var num=124.2361234 // 指定保留几位小数,能够四舍五入 console.log(num.toFixed(3)) // 124.236 Math.random() 随机数 Math.round() 四舍五入 Math.ceil() 向上取整 Math.floor() 向下取整 Math.abs() 绝对值 Math.sqrt() 平方根 Math.pow(2,4) 2的4次方 &#x3D; 16 Math.max(10,11,20,1,2,4) 取最大 Math.min(10,11,20,1,2,4) 取最小 Math.PI","tags":["js"],"categories":["前端3大件"]},{"title":"处理yaml文件","path":"/2024/03/07/50/","content":"第一种方法这个很简单直接以import的形式引入，在后面加一个?raw,然后使用yaml模块进行解析即可 123import config from &#x27;@/assets/managerCool.config.yml?raw&#x27;import &#123;parse&#125; from &#x27;yaml&#x27;console.log(parse(config)) 第二种方法1. 转文件对象函数​ 记得安装axios 1234567891011121314import axios from &quot;axios&quot;;async function urlToFile(url:string, fileName:string) &#123; try &#123; const response = await axios.get(url, &#123; responseType: &#x27;blob&#x27; &#125;); return new File([response.data], fileName, &#123; type: response.headers[&#x27;content-type&#x27;] &#125;); &#125; catch (error) &#123; console.error(&#x27;Error fetching image:&#x27;, error); &#125;&#125;export &#123; urlToFile&#125; 2. 读取文件内容函数12345678910111213141516171819202122232425/** * 读取文件的方法，返回Promise对象 * @param file 要读取的文件对象 * @param encoding 文件编码格式，默认为&#x27;utf-8&#x27; */function readFile(file: File, encoding = &#x27;utf-8&#x27;): Promise&lt;string&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 创建FileReader对象 const reader = new FileReader(); // 当文件读取完成后，调用resolve方法返回文件内容 reader.onload = function () &#123; resolve(reader.result as string); &#125;; // 当文件读取出错时，调用reject方法返回错误信息 reader.onerror = function () &#123; reject(reader.error); &#125;; // 以指定的编码格式读取文件内容 reader.readAsText(file, encoding); &#125;);&#125;export &#123; readFile&#125; 3. 解析yaml文件​ 需要安装yaml模块 123import &#123;parse&#125; from &#x27;yaml&#x27;parse(&#x27;文件内容&#x27;) 4. 使用​ const url &#x3D; import.meta.env.VITE_CONFIG_URL;这个是我自己的配置的地址，具体的可以查看vite官网的env配置，其实这里的url就是一个指向yaml文件地址的字符串，你直接写你的yaml文件所在位置就行 123456789101112import &#123;readFile&#125; from &quot;@/tools/readFile.ts&quot;;import &#123;urlToFile&#125; from &quot;@/tools/urlToFile.ts&quot;;import &#123;parse&#125; from &#x27;yaml&#x27;const url = import.meta.env.VITE_CONFIG_URL;const name = &#x27;config.yml&#x27;;urlToFile(url, name).then(file =&gt; &#123; // 使用转换后的File对象 readFile(file as File).then(res=&gt;&#123; console.log(parse(res)) &#125;)&#125;);","tags":["vue"],"categories":["前端进阶"]},{"title":"js基础篇1","path":"/2024/03/05/49/","content":"数组常用方法 注意：前面7种方法会改变原数组 1. push 后面追加元素2. pop 后面删除元素3. unshift 前面追加元素4. shift 前面删除元素5. splice 删除与增加，比如arr.splice(1, 1)、arr.splice(1, 0, &quot;lz&quot;)6. reverse 倒序7. sort 排序： 从小到大 123456var arr1 = [10, 1, 7, 66, 11]arr1.sort(function (a, b) &#123; return a-b&#125;)// [1, 7, 10, 11, 66] 从大到小 123456var arr1 = [10, 1, 7, 66, 11]arr1.sort(function (a, b) &#123; return b-a&#125;)// [66, 11, 10, 7, 1] 8. concat 拼接两个数组9. join 数组转字符串10. slice 截取​ 说明：这个可以用于字符串，也可以用于数组 11. indexOf 查找元素​ 说明: 返回索引 12. forEach 遍历123456var arr = [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;]arr.forEach(function (value, index) &#123; console.log(value)&#125;)// aaa bbb ccc ddd 13. map 映射1234567var arr = [1, 2, 3, 4, 5]var arr1 = arr.map(function (value) &#123; return value * 2&#125;)console.log(arr1)// [2, 4, 6, 8, 10] 14. filter 过滤1234567var arr = [11, 2, 4, 1, 5]var arr1 = arr.filter(function (value) &#123; return value &gt; 4&#125;)console.log(arr1)// [11, 5] 15. every​ 说明：返回布尔值，如果数组里面的每一项都满足条件返回true,否则为false 1234567var arr = [90, 90, 80, 100, 95]var arr1 = arr.every(function (item) &#123; return item &gt;= 90&#125;)console.log(arr1);// false 16. some​ 说明：返回布尔值，只要数组中的有一项满足条件就返回true，否则为false 1234567var arr = [90, 90, 80, 100, 95]var arr1 = arr.some(function (a) &#123; return a &gt;= 100&#125;)console.log(arr1);// true 17. find​ 说明：返回第一个满足条件的数组元素 123456789101112131415161718192021var arr = [ &#123; name: &quot;语文&quot;, grade: 90 &#125;, &#123; name: &quot;数学&quot;, grade: 85 &#125;, &#123; name: &quot;英语&quot;, grade: 100 &#125;,]var arr1 = arr.find(function (item) &#123; return item.grade &gt;= 90&#125;)console.log(arr1)// &#123;name: &#x27;语文&#x27;, grade: 90&#125; 18. reduce​ 说明: 每一次运行 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。 ​ 1234567var arr = [1, 2, 3, 4, 5]var arr1 = arr.reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue&#125;)console.log(arr1);// 15 字符串常用方法1. charAt​ 12345var str = &quot;liuzhe&quot;var str1 = str.charAt(2)console.log(str1)// u 2. charCodeAt​ 12345var str = &quot;liuzhe&quot;var str1 = str.charCodeAt(2)console.log(str1)// 117 3. fromCharCode 获取26个字母​ 1234567var arr = []for (var i = 65; i &lt; 91; i++) &#123; arr.push(String.fromCharCode(i))&#125;console.log(arr)// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;] 4. toLocaleUpperCase &amp;&amp; toLocaleLowerCase 大小写的转换​ 123456var str1 = &quot;ASDasd&quot;, str2 = &quot;ZXCzxc&quot;console.log(str1.toLocaleUpperCase())console.log(str2.toLocaleLowerCase())// ASDASD// zxczxc 5. substr(开始索引，长度) &amp;&amp; substring(开始索引，结束索引) 字符串的截取6. replace 替换7. split 分割 字符串转成数组​ 1234var str = &quot;abcd&quot;console.log(str.split(&quot;&quot;))// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 8. trim 去掉首尾空格​ 12345var str = &quot; abcd &quot;console.log(&quot;|&quot; + str + &quot;|&quot;, &quot;|&quot; + str.trim() + &quot;|&quot;)// | abcd | |abcd| new Date()常用方法 ​ 注意：获取月份时记得加1 12345678910111213141516var date=new Date()console.log(date.getFullYear())//年console.log(date.getMonth()+1)//月console.log(date.getDate())//日console.log(date.getDay())//星期console.log(date.getHours())console.log(date.getMinutes())console.log(date.getSeconds())//时间戳 getTime()console.log(date.getTime())//修改date.setFullYear(2020)console.log(date) 浏览器相关1. 事件1234567891011121314// 页面所有资源加载完成后执行onload=function()&#123; console.log(&quot;加载完成&quot;)&#125; // 窗口大小改变就会执行onresize=function()&#123; console.log(&quot;resize&quot;)&#125;//滚动条滚动就会执行 onscroll=function()&#123; console.log(&quot;scroll&quot;)&#125; 2. 滚动距离window.document.documentElement.scrollTop||window.document.body.scrollTop 3. 回到顶部​ window.scrollTo(0,0) 4. 本地存储​ 1234567891011// 存储localStorage.setItem(&quot;age&quot;,&quot;19&quot;)// 获取localStorage.getItem(&quot;age&quot;)// 移除localStorage.removeItem(&quot;age&quot;)// 清除localStorage.clear() 给dom标签挂标识1. 新建原生属性​ 1234var a=document.getElementById(&quot;box&quot;)a.setAttribute(&quot;name&quot;,&quot;teichui&quot;)// &lt;div id=&quot;box&quot; name=&quot;teichui&quot;&gt;&lt;/div&gt; 2. 获取原生属性的值​ 123console.log(a.getAttribute(&quot;name&quot;))// teichui 3. 移除原生属性​ 1a.removeAttribute(&quot;name&quot;) 4. dataset​ 1234567a.dataset.xiaoming=&quot;111&quot;//&lt;div id=&quot;box&quot; data-xiaoming=&quot;111&quot;&gt;&lt;/div&gt;// 删除delete a.dataset.xiaoming 操作dom类名1. className(可以赋值,不会去重)​ 1234var a=document.querySelector(&quot;#box&quot;)a.className=&quot;box1 box2&quot;// &lt;div id=&quot;box&quot; class=&quot;box1 box2&quot;&gt;&lt;/div&gt; 2. classList(会自动去重)​ 12345//增加 a.classList.add(&quot;box4&quot;)// 移除a.classList.remove(&quot;box2&quot;) 获取指定dom的某个节点​ 123456789101112var a=document.querySelector(&quot;#box&quot;)// 获取所有子节点console.log(a.children)// 获取第一个元素子节点console.log(a.firstElementChild)// 获取上一个兄弟节点console.log(a.previousElementSibling)// 获取下一个兄弟节点console.log(a.nextElementSibling) 操作dom节点12345678910111213141516171819202122232425var a=document.querySelector(&#x27;#aa&#x27;)var b=document.querySelector(&#x27;#bb&#x27;)// 创建节点var odiv=document.createElement(&#x27;div&#x27;)//创建节点odiv.innerHTML=&#x27;我是新的&#x27;// 插入子节点a.appendChild(odiv)// 在谁的前面插入a.insertBefore(odiv,bb)// 删除子节点a.removeChild(bb)// 删除自己以及后代a.remove()// 节点的替换 replaceChild(新的节点，老的节点)// 节点的克隆 cloneNode()// false 不克隆后代// true 克隆后代var clon=a.cloneNode(true)","tags":["js"],"categories":["前端3大件"]},{"title":"文件上传完整流程","path":"/2024/02/22/48/","content":"思维导图 构建前端1. 安装项目1npm create vite@latest 相信大家运行个项目没啥问题吧，这里作者就不多费口舌了 2. 安装ant-design-vue1npm install ant-design-vue@4.x --save 不用安装这个也可以，但是要自己写前端上传代码，没必要，我们就站在巨人肩膀上就行 3. 引入ant-design-vue直接在main.ts中进行全局引入 12345678910import &#x27;./assets/main.css&#x27;import &#x27;ant-design-vue/dist/reset.css&#x27;;import Antd from &#x27;ant-design-vue&#x27;;import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App);app.use(Antd).mount(&#x27;#app&#x27;); 然后直接使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;a-upload v-model:file-list=&quot;fileList&quot; name=&quot;avatar&quot; action=&quot;http://localhost:3000/upload&quot; :headers=&quot;headers&quot; :progress=&quot;progress&quot; @change=&quot;handleChange&quot; &gt; &lt;a-button&gt; &lt;upload-outlined&gt;&lt;/upload-outlined&gt; Click to Upload &lt;/a-button&gt; &lt;/a-upload&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; message &#125; from &#x27;ant-design-vue&#x27;;import &#123; UploadOutlined &#125; from &#x27;@ant-design/icons-vue&#x27;;import &#123; ref &#125; from &#x27;vue&#x27;;import type &#123; UploadChangeParam, UploadProps &#125; from &#x27;ant-design-vue&#x27;;const handleChange = (info: UploadChangeParam) =&gt; &#123; if (info.file.status !== &#x27;uploading&#x27;) &#123; console.log(info.file, info.fileList); &#125; if (info.file.status === &#x27;done&#x27;) &#123; message.success(`$&#123;info.file.name&#125; file uploaded successfully`); &#125; else if (info.file.status === &#x27;error&#x27;) &#123; message.error(`$&#123;info.file.name&#125; file upload failed.`); &#125;&#125;;const fileList = ref([]);const progress: UploadProps[&#x27;progress&#x27;] = &#123; strokeColor: &#123; &#x27;0%&#x27;: &#x27;#108ee9&#x27;, &#x27;100%&#x27;: &#x27;#87d068&#x27;, &#125;, strokeWidth: 3, format: percent =&gt; `$&#123;parseFloat(percent.toFixed(2))&#125;%`, class: &#x27;test&#x27;,&#125;;const headers = &#123; authorization: &#x27;authorization-text&#x27; &#125;;&lt;/script&gt; 需要注意的点 name中的avatar是后端接收文件的字段名 action是具体的后端接口地址 headers中的authorization是前端传给后端的头部信息 详细的信息请查看官网: https://www.antdv.com/components/overview 构建后端1. 安装项目1express myapp 如果没有安装express，可以先安装express 1npm install -g express-generator 2. 安装crypto、multer1npm i crypto multer -S 3. 后端路由1234567891011121314151617181920212223242526272829303132333435var express = require(&#x27;express&#x27;);var router = express.Router();const path = require(&#x27;path&#x27;);const crypto = require(&#x27;crypto&#x27;); // 加密// 引入multerconst multer = require(&#x27;multer&#x27;)// 定义一个生成唯一哈希文件名的函数function generateHashedFilename(req, file, callback) &#123; const hash = crypto.randomBytes(16).toString(&#x27;hex&#x27;); const ext = path.extname(file.originalname); // 获取原始文件扩展名 const filename = `$&#123;hash&#125;$&#123;ext&#125;`; // 将哈希与扩展名拼接成新的文件名 callback(null, filename);&#125;const storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, &#x27;public/images/&#x27;); &#125;, filename: generateHashedFilename,&#125;);const upload = multer(&#123; storage &#125;)/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;index&#x27;, &#123; title: &#x27;Express&#x27; &#125;);&#125;);router.post(&#x27;/upload&#x27;,upload.single(&#x27;avatar&#x27;), function(req, res, next) &#123; res.send(&#x27;恭喜上传成功&#x27;); // console.log(req.file);&#125;);module.exports = router; 说明 cb(null, ‘public&#x2F;images&#x2F;‘); 这个是将文件保存到public&#x2F;images&#x2F;目录下 upload.single(‘avatar’)是前端传过来的avatar字段名，这个字段名在前端的name属性中定义的 4. 解决跨域安装cors 1npm install cors -S 在app.js中添加 12345678var cors = require(&#x27;cors&#x27;);// 解决跨域问题app.use(cors(&#123; origin: &#x27;http://127.0.0.1:5173&#x27;, // 允许指定源进行跨域访问，也可以设置为&#x27;*&#x27;表示任何源 credentials: false, // 如果需要携带cookie，开启此项 allowedHeaders: [&#x27;x-requested-with&#x27;,&#x27;authorization&#x27;] // 允许自定义请求头&#125;)); 说明 origin是前端实际地址 记得放在路由之前，不然会报错 总结这里就只对单文件上传进行简单的讲解，关于文件上传还有很多的逻辑，比如： 文件大小限制 文件类型限制 支持文件夹上传 大文件分片上传 多文件上传等等； 大家可以参考ant-design-vue与multer官网，或者网上找找资料","tags":["node"],"categories":["前端进阶"]},{"title":"解决vite+vue中别名问题","path":"/2024/02/20/47/","content":"创建vite+vue项目1npm create vite@latest 配置别名在vite.config.js中配置别名 12345678910111213import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import path from &#x27;path&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;), &#125;, &#125;,&#125;) 此时的@别名指向的是src目录 解决vscode仍然无法识别别名问题这个问题作者也找了很久，根据网上提示说: 这个问题可能是因为VS Code的JavaScript&#x2F;TypeScript语言服务没有识别到你设置的路径别名 解决方法在你的项目根目录下添加jsconfig.json或tsconfig.json文件（取决于你是用JavaScript还是TypeScript），然后设置路径别名。例如，如果你想要设置@为src目录的别名，可以按照以下方式设置： 123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;]&#125;","tags":["vue"],"categories":["前端进阶"]},{"title":"npm创建vue项目","path":"/2024/02/15/46/","content":"创建vue3项目1npm init vue@latest npm init vue@latest 安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。创建的 vue3 项目是基于 Vite 打包的。","tags":["vue"],"categories":["前端进阶"]},{"title":"主题推荐-stellar","path":"/2024/02/01/45/","content":"预览图 官方文档https://xaoxuu.com/wiki/stellar/ 安装在hexo根目录下执行 1git clone https://github.com/xaoxuu/hexo-theme-stellar.git themes/stellar 运行安装后运行可能会缺少一些模块，可以根据报错，将缺失的模块安装比如我缺少的模块是: hexo-fs hexo-util 执行 1npm install hexo-fs hexo-util -D 增加友链页面 先在hexo根目录执行 1hexo new page friends 修改主题配置文件增加一个导航 12nav_tabs: &#x27;友链&#x27;: /friends/ 新建yml文件，用以存放友链信息在根目录下新建: source&#x2F;_data&#x2F;links&#x2F;ios_developer.yml配置如下 12345- title: 某某某 url: https:// cover: icon: description: 使用找到刚才新建的friends页面, 在其index.md文件中添加如下内容: 1&#123;% friends ios_developer %&#125;","tags":["stellar"],"categories":["魔改"]},{"title":"css中变量的使用","path":"/2024/02/01/44/","content":"前言说来惭愧，最近学习sass后，才发现原来css中也可以写变量，原来自己对css的知识只是冰山一角，接下来我们就来写一个简单的动态改变背景颜色的demo css中如何定义变量123:root&#123; --color: #000; &#125; 如何使用1234body&#123; height: 96vh; background-color: var(--color); &#125; js中获取变量值1const rootColor = getComputedStyle(document.documentElement).getPropertyValue(&#x27;--color&#x27;); js中动态改变变量值1document.documentElement.style.setProperty(&#x27;--color&#x27;, 值); 完整代码12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;简单的背景选择&lt;/title&gt; &lt;style&gt; :root&#123; --color: #000; &#125; body&#123; height: 96vh; background-color: var(--color); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;color&quot; id=&quot;color&quot;&gt; &lt;script&gt; // const rootColor = getComputedStyle(document.documentElement).getPropertyValue(&#x27;--color&#x27;); let colorSelector = document.querySelector(&#x27;#color&#x27;); colorSelector.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; // 通过改变css变量，改变页面背景色 document.documentElement.style.setProperty(&#x27;--color&#x27;, e.target.value); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 或许css才是最神秘的语言","tags":["css"],"categories":["前端3大件"]},{"title":"在vscode中的使用sass插件","path":"/2024/02/01/43/","content":"介绍Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。官网: https://sass-lang.com/ 在vscode中安装安装插件: Live Sass Compiler此插件可以直接将sass文件转为css文件官方文档: https://github.com/ritwickdey/vscode-live-sass-compiler?tab=readme-ov-file 安装后需要进行配置 点击扩展设置 编辑json文件 我的配置如下（仅供参考） 12345678910111213141516171819202122232425262728293031&#123; &quot;liveSassCompile.settings.formats&quot;:[ // This is Default. &#123; /* 1.nested: 嵌套模式 2.compact: 紧凑模式 3.expanded: 展开模式 4.compressed: 压缩模式 */ &quot;format&quot;: &quot;expanded&quot;, &quot;extensionName&quot;: &quot;.css&quot;, &quot;savePath&quot;: &quot;~/./css&quot; &#125;, ], // 排除目录 &quot;liveSassCompile.settings.excludeList&quot;: [ &quot;**/node_modules/**&quot;, &quot;.vscode/**&quot; ], // 是否添加兼容前缀 &quot;liveSassCompile.settings.autoprefix&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot; ], // 控制资源管理器是否应在通过回收站删除文件时要求确认。 &quot;explorer.confirmDelete&quot;: false, // 是否生成.map文件 &quot;liveSassCompile.settings.generateMap&quot;: false&#125; 如何使用安装成功后，会在vscode的下方出现watch Sass，点击后就会对你目前的sass文件进行监听，自动生成css文件","tags":["sass"],"categories":["前端进阶"]},{"title":"js扩展API","path":"/2024/02/01/42/","content":"数组方法 拆分多维数组flat 123let arr = [1,2,[3,4,[5,6]]]console.log(arr.flat(2))// [1,2,3,4,5,6] 数组元素修改fill 123let arr = [1, 2, 3, 4, 5]console.log(arr.fill(10, 2))// [1, 2, 10, 10, 10] 只改变数组其中一个元素with 123let arr = [1, 2, 3, 4, 5]console.log(arr.with(1, 100))//[1, 100, 3, 4, 5] 数值方法 Math.trunc() 方法会将数字的小数部分去掉，只保留整数部分 123let a = 123.9999console.log(Math.trunc(a))// 123 Math.sign() 函数返回一个数字的符号，指示数字是正数，负数还是零 123456console.log(Math.sign(99))// 1console.log(Math.sign(-3))// -1console.log(Math.sign(0))// 0 字符串方法 startsWith和endsWith方法可以判断字符串是否以指定字符串开头或结尾 1234567let str = &quot;hello&quot;console.log(str.startsWith(&quot;h&quot;))// trueconsole.log(str.startsWith(&quot;h&quot;, 1))// falseconsole.log(str.endsWith(&quot;o&quot;))// true 字符串的repeat方法可以重复字符串 123let str = &quot;hello&quot;console.log(str.repeat(3))// hellohellohello 字符串的padStart和padEnd方法可以对字符串进行填充 12345let str = &quot;hello&quot;console.log(str.padStart(10, &quot;world&quot;))// worldhelloconsole.log(str.padEnd(10, &quot;world&quot;))// helloworld at函数用于访问数组 12345let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]console.log(arr.at(1))// 2console.log(arr.at(-1))// 10 generator函数生成器函数可以暂停执行，下次调用时继续执行 12345678910function *generator() &#123; yield &#x27;aaa&#x27;; yield &#x27;bbb&#x27;; &#125; let a = generator(); for(let item of generator())&#123; console.log(item); &#125;// aaa// bbb ReflectReflect对象提供了一组静态方法，用于操作对象的属性和方法 Reflect.has判断对象是否存在某个属性 123456let obj = &#123; name: &#x27;xiaoming&#x27;, age: 18 &#125;console.log(Reflect.has(obj, &#x27;name&#x27;))// true Reflect.ownKeys()返回这个对象自身的属性 12console.log(Reflect.ownKeys(obj))// [ &#x27;name&#x27;, &#x27;age&#x27; ] Reflect.defineProperty()为对象添加一个属性，并且可以进行配置 12345678Reflect.defineProperty(obj, &#x27;height&#x27;, &#123; value: 170, writable: true, enumerable: true, configurable: true &#125;)console.log(obj)// &#123; name: &#x27;xiaoming&#x27;, age: 18, height: 170 &#125; Reflect.set()为对象直接添加一个属性 123Reflect.set(obj, &#x27;weight&#x27;, 70)console.log(obj)// &#123;name: &#x27;xiaoming&#x27;, age: 18, weight: 70&#125; Reflect与Proxy联合使用 12345678910let obj = &#123;&#125;let proxy = new Proxy(obj, &#123; get(target, key) &#123; return Reflect.get(...arguments) &#125;, set(target, key, value) &#123; Reflect.set(...arguments) return true &#125; &#125;) matchAll()方法返回一个迭代器，该迭代器包含了检索字符串与正则表达式进行匹配的所有结果 123456789101112let str = ` &lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt; &lt;/ul&gt; `let reg = /&lt;li&gt;(?&lt;content&gt;.*)&lt;\\/li&gt;/gfor(var item of str.matchAll(reg))&#123; console.log(item)&#125; Promise集合一个 Promise 必然处于以下几种状态之一：1.待定（pending）：初始状态，既没有被兑现，也没有被拒绝。2.已兑现（fulfilled）：意味着操作成功完成。3.已拒绝（rejected）：意味着操作失败。 123456789101112131415function ajax(str, time, isSuccess) &#123; if (isSuccess)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(str); &#125;, time); &#125;); &#125;else&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(str); &#125;, time); &#125;); &#125; &#125; Promise.all()等待所有 Promise, 在任意一个 Promise 被拒绝时拒绝 12345Promise.all([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) Promise.race() 看哪一个 Promise 先被执行完，就执行哪一个 Promise 12345Promise.race([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) Promise.any()当输入的任何 promise 实现时，此返回的 promise 将实现，并具有第一个 fulfillation 值。当所有输入的 promise 都拒绝时（包括传递空可迭代对象时），它会拒绝 12345Promise.any([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err, &#x27;拒绝&#x27;) &#125;) Promise.allSettled() 无论任何 promise 实现，此返回的 promise 都将实现，并具有一个数组，其中包含每个输入 promise 的状态和值。 12345Promise.allSettled([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, false)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;)","tags":["js"],"categories":["前端3大件"]},{"title":"css属性mix-blend-mode介绍","path":"/2024/02/01/41/","content":"介绍mix-blend-mode 是一种 CSS 属性，它定义了一个元素的颜色如何与其父元素的颜色以及兄弟元素的颜色混合。它允许您创建令人惊艳的视觉效果，可以用于创建半透明效果、添加阴影、制作图片蒙版和很多其他效果。 具体属性值 difference将前景色减去背景色的值，并取绝对值。这会导致一个反相的效果。效果如下: multiply将两个颜色的值相乘，得到一个更暗的颜色。这通常用于创建阴影效果。原效果如下: 使用multiply后 screen将两个颜色的值相加，然后减去相乘的值，得到一个更亮的颜色。这通常用于创建高光效果。效果如下: overlay根据背景颜色的亮度来选择颜色混合模式。如果背景颜色较暗，则使用 multiply 模式；如果背景颜色较亮，则使用 screen 模式。 darken将两个颜色的值比较，使用较暗的那个颜色。 lighten将两个颜色的值比较，使用较亮的那个颜色。 color-dodge将前景色分解为 RGB 分量，并将每个分量分别除以（1 减去背景色的对应分量）。然后将每个分量限制在 0 到 1 之间，并使用限制后的前景色作为混合色。 color-burn将前景色分解为 RGB 分量，并将每个分量分别除以背景色的对应分量。然后将每个分量限制在 0 到 1 之间，并使用限制后的前景色作为混合色。 exclusion将前景色和背景色的值相加，然后减去相乘的值的两倍。这通常用于创建反相效果。 hue将前景色的色相（Hue）与背景色的饱和度（Saturation）和亮度（Lightness）混合。这可以用于在不改变亮度和饱和度的情况下改变颜色。 saturation将前景色的饱和度与背景色的色相和亮度混合。这可以用于在不改变颜色的情况下改变饱和度。 color将前景色的色相、饱和度和亮度与背景色混合。这可以用于在改变所有颜色属性的情况下改变前景色的颜色。 luminosity将前景色的亮度与背景色的色相和饱和度混合。这可以用于在不改变颜色的情况下改变亮度。","tags":["css"],"categories":["前端3大件"]},{"title":"uni-app实现app自动检测更新","path":"/2024/02/01/40/","content":"前言在做app项目时，app版本管理是必不可少的，在发布新版本后，应该提醒用户需要更新了此时需要两个功能： 后台进行版本发布与管理（使用uni-app的模板admin即可，需要关联Dcloud的服务空间） 前台检测更新（使用uni-app的插件, https://ext.dcloud.net.cn/plugin?id=4542） 后台 在HBuilder里面新建一个项目（模板为uni-admin）： 运行项目到浏览器 登录即可（没有先注册） 在系统管理中找到应用管理 新增一个应用成功后即可发布版本，首先得进行云打包，每次发布都会让你上传apk资源包的，并且每次上传的版本号要比上次大 前台检测更新 插件引入, https://ext.dcloud.net.cn/plugin?id=4542 添加路径在pages.json文件，添加一个更新页面 12345678910111213141516&#123;\t&quot;path&quot;: &quot;uni_modules/uni-upgrade-center-app/pages/upgrade-popup&quot;,\t&quot;style&quot;: &#123; &quot;disableScroll&quot;: true, &quot;app-plus&quot;: &#123; &quot;backgroundColorTop&quot;: &quot;transparent&quot;, &quot;background&quot;: &quot;transparent&quot;, &quot;titleNView&quot;: false, &quot;scrollIndicator&quot;: false, &quot;popGesture&quot;: &quot;none&quot;, &quot;animationType&quot;: &quot;fade-in&quot;, &quot;animationDuration&quot;: 200 &#125;\t&#125;&#125; 添加更新代码(建议在App.vue中引入) 1import checkUpdate from &#x27;uni_modules/uni-upgrade-center-app/utils/check-update.ts&#x27; 在生命周期函数中调用此函数 1checkUpdate()","tags":["uni-app"],"categories":["前端进阶"]},{"title":"vue(原生js)事件委托与参数同时使用","path":"/2024/02/01/39/","content":"事件委托的作用在孩子节点需要绑定多个点击事件的时候，可以直接使用事件委托，将点击事件绑定到父节点，利用事件委托就可以知道自己点击的孩子节点是谁了 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../库/vue2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot; @click=&quot;test&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#box&#x27;, methods: &#123; test(event) &#123; console.log(event.target) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 默认在不传参数的时候，在方法定义的第一个参数就是事件委托的对象 vue事件委托与参数同时使用如果需要传参的同时，并且能够使用事件委托对象，可以这样： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../库/vue2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot; @click=&quot;test($event, &#x27;ttt&#x27;)&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#box&#x27;, methods: &#123; test(event, a) &#123; console.log(event.target, a) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原生js事件委托与参数同时使用可以使用闭包，还有其他方法可以在这里发表哦，这也是事件传递参数的一种方式 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;box&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; box.onclick = test(&quot;aaa&quot;) function test(a) &#123; return function (evt) &#123; console.log(evt.target, a) &#125; &#125;&lt;/script&gt;&lt;/html&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"探究css的滤镜效果","path":"/2024/02/01/38/","content":"今天来讲一讲前端的滤镜效果，也就是filter属性 drop-shadow如果我让你对一个图片里面的图形设置阴影，你有什么办法吗？正常来说你可能想到的是box-shadow,给盒子设置一个阴影 1box-shadow: 10px 10px 10px gray; 但是好像没有达到我们预期的效果，那么这里就要用上drop-shadow了不要box-shadow，而是filter 1filter: drop-shadow(10px 10px 10px gray); blur这个值会让像素变得模糊正常来说: 设置blur后（后面还发现了一个神奇的现象，我的margin: 0 auto;好像失效了，但是好像又没有，因为这个盒子还是在屏幕中间的，不知道为什么，好像这个blur会使这个元素的像素点回到最初的状态） 1filter: blur(10px); contrast提高色彩对比度 grayscale变灰，一些纪念日用得上 backdrop-filter正常: 如果我想给他的背景加点模糊效果，怎么做呢?注意这里可不能用filter了而是得用到我们的backdrop-filter这个可以模糊自身后面的像素 1backdrop-filter: blur(10px);","tags":["css"],"categories":["前端3大件"]},{"title":"主题推荐-anzhiyu","path":"/2024/02/01/37/","content":"预览图 官方文档https://docs.anheyu.com/ 下载1git clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu 安装 pug 和 stylus 渲染插件1npm install hexo-renderer-pug hexo-renderer-stylus --save","tags":["anzhiyu"],"categories":["魔改"]},{"title":"maupassant的基本配置","path":"/2024/02/01/36/","content":"新增标签页面 在hexo根目录下执行 1hexo new page tags 会发现在source文件夹下多了一个tags文件夹, 点进去找到index.md文件，添加如下配置即可 12345---title: tagsdate: 2023-10-13 23:11:26layout: tagcloud--- 添加一个导航找到主题配置文件的_config.yml文件, 找到menu属性: 12345678910111213menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: tags directory: tags/ icon: fa-tag - page: about directory: about/ icon: fa-user 添加网站图标将favicon.ico放到hexo的根目录source文件夹下即可，推荐像素为32*32, 不会立即生效 增加搜索功能 安装插件 1npm install hexo-generator-search 添加代码至hexo下面的_config.yml文件 1234search: path: search.xml field: post content: true 修改主题下的_config.yml文件 1self_search: true 清除多余的搜索框做到这里你会发现你的页面多了一个搜索输入框，我来教你解决找到主题文件下的source&#x2F;js&#x2F;search.js添加脚本 12const searchInput = document.querySelector(&#x27;.widget input&#x27;)searchInput.style.display = &#x27;none&#x27;","tags":["maupassant"],"categories":["魔改"]},{"title":"主题推荐-maupassant","path":"/2024/02/01/35/","content":"今天给大家推荐一款非常好看的主题，预览如下 下载主题首先在自己的hexo博客项目的根目录下执行 1git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant 安装渲染器12npm install hexo-renderer-sass --savenpm install hexo-renderer-jade --save 修改_config.yml1theme: maupassant 运行查看效果1hexo s","tags":["maupassant"],"categories":["魔改"]},{"title":"uni-app中的省市区选择组件","path":"/2024/02/01/34/","content":"找到省市区选择组件的资源包因为uni-app中不支持npm安装后直接导入，所以我们必须先找到这个组件 uni-app中提供了这个组件资源，我们打开Hbuilder，新建一个uni-app的模板项目，如下： 创建完成后找到这个组件，如下： 将其复制到自己的uni-app项目中 配置可参考：https://github.com/MPComponent/mpvue-citypicker 我的配置（仅供参考） 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt;\t&lt;view class=&quot;&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;city&quot; style=&quot;border: 1px solid black;&quot;&gt; &lt;button @tap=&quot;showCityPicker&quot;&gt;选择城市&lt;/button&gt; &lt;mpvue-city-picker ref=&quot;mpvueCityPicker&quot; :pickerValueDefault=&quot;pickerValueDefault&quot; @onChange=&quot;onChange&quot; @onCancel=&quot;onCancel&quot; @onConfirm=&quot;onConfirm&quot;&gt;&lt;/mpvue-city-picker&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\timport mpvueCityPicker from &#x27;@/components/mpvue-citypicker/mpvueCityPicker.vue&#x27;;\texport default &#123; data() &#123; return &#123; pickerValueDefault: [0, 0, 1], city: &#x27;请选择...&#x27; &#125;; &#125;, components: &#123; mpvueCityPicker &#125;, methods: &#123; showCityPicker() &#123; this.$refs.mpvueCityPicker.show(); &#125;, onChange(e) &#123; console.log(e); &#125;, onCancel(e) &#123; console.log(e); &#125;, onConfirm(e) &#123; this.city = e.label &#125; &#125;\t&#125;;&lt;/script&gt;","tags":["uni-app"],"categories":["前端进阶"]},{"title":"chart.js的使用","path":"/2024/02/01/33/","content":"先导之前使用canvaJS已经写过了一个统计页面，但是我觉得样式不够好看，于是又去找图表框架，发现chart.js还挺好看，这里就不说怎么创建一个统计页面了，我不可能所有文章都从最最最基础的讲起的，作者也开始摆烂咯，哈哈哈哈！！！（主要是写教程没经济来源） 找到教程教程：Chart.js · GitBook (bootcss.com) 本教程会使用到webpack, 不知道什么是webpack的，可以先去看一下，官网在：webpack，用于解决模块化导入问题。我觉得很多小伙伴是不是卡在这里了呢？看到这里你是不是觉得很懵，为什么能直接在自己博客的目录下安装chart.js, 然后直接引用，哈哈哈哈，hexo可不支持模块化哦！，看以后会不会支持吧，反正不管怎样都要使用webpack去打包，生成一个可用的js文件 安装webpack在一个空文件夹中 1npm i webpack 1npm i webpack-cli 安装chart.js1npm i chart.js 新建一个src目录在此目录新建main.js, 主要用于写chart.js的配置内容如下： 1234567891011121314151617181920212223242526272829303132333435363738import Chart from &quot;chart.js/auto&quot;;var ctx = document.getElementById(&quot;myChart&quot;).getContext(&#x27;2d&#x27;);var myChart = new Chart(ctx, &#123; type: &#x27;bar&#x27;, data: &#123; labels: [&quot;Red&quot;, &quot;Blue&quot;, &quot;Yellow&quot;, &quot;Green&quot;, &quot;Purple&quot;, &quot;Orange&quot;], datasets: [&#123; label: &#x27;# of Votes&#x27;, data: [12, 19, 3, 5, 2, 3], backgroundColor: [ &#x27;rgba(255, 99, 132, 0.2)&#x27;, &#x27;rgba(54, 162, 235, 0.2)&#x27;, &#x27;rgba(255, 206, 86, 0.2)&#x27;, &#x27;rgba(75, 192, 192, 0.2)&#x27;, &#x27;rgba(153, 102, 255, 0.2)&#x27;, &#x27;rgba(255, 159, 64, 0.2)&#x27; ], borderColor: [ &#x27;rgba(255,99,132,1)&#x27;, &#x27;rgba(54, 162, 235, 1)&#x27;, &#x27;rgba(255, 206, 86, 1)&#x27;, &#x27;rgba(75, 192, 192, 1)&#x27;, &#x27;rgba(153, 102, 255, 1)&#x27;, &#x27;rgba(255, 159, 64, 1)&#x27; ], borderWidth: 1 &#125;] &#125;, options: &#123; scales: &#123; yAxes: [&#123; ticks: &#123; beginAtZero:true &#125; &#125;] &#125; &#125;&#125;); 注意chart.js的引用：import Chart from “chart.js&#x2F;auto”; 配置webpack的打包信息新建文件webpack.config.js 12345678910const path = require(&#x27;path&#x27;);module.exports = &#123; mode: &#x27;development&#x27;, entry: &#x27;./src/main.js&#x27;, // 项目的入口文件路径 output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27; // 构建后的文件路径和文件名 &#125;&#125;; 执行命令： 1npx webpack 执行后生成一个dist文件夹 创建html页面1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;myChart&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用浏览器打开应该就成功了 最后在根据我之前的那篇文章：增加一个统计模块 | Lazychild&#39;s Blog，可以获取本地的一些数据，将图表的数据与博客数据关联起来，最后将自己生成的js文件与html页面移植到自己的博客项目中即可","tags":["butterfly"],"categories":["魔改"]},{"title":"LeanCloud云数据库基本操作","path":"/2024/02/01/32/","content":"官网LeanCloud: 在这里你可以注册leanCloud的账号，并且创建你的应用，即数据库 下面将以vue2案例向大家介绍如何使用leanCloud进行数据的储存, 带大家写一个最常用的登录验证的例子吧 创建一个最简单的vue2项目吧1vue create 项目名称 之前有介绍， 这里就不详细说明了 创建好后，建立两个页面，一个登录页面，还有一个登录跳转后的页面 先自己将路由写好， 能够访问这两个页面即可 下载必要的模块npm install leancloud-storage 在登录页面引入模块并初始化1234567const AV = require(&quot;leancloud-storage&quot;);// 初始化 LeanCloudAV.init(&#123; appId: &quot;你的应用的appId&quot;, appKey: &quot;你的应用的appKey&quot;, serverURL: &quot;https://ysyeflyc.lc-cn-n1-shared.com&quot;,&#125;); 用户的登录验证 123456// 用户登录AV.User.logIn(username, password).then(function(user) &#123; // 登录成功，跳转页面&#125;).catch(function(error) &#123; // 登录失败&#125;); vue2的路由守卫的书写，防止用户未登录就能访问登录后的页面 1234567891011121314beforeEnter: (to, from, next) =&gt; &#123; var token = localStorage.getItem(&#x27;AV/YsYeflyCpiGJrcfPnYM80d43-gzGzoHsz/currentUser&#x27;) var tokenObj = JSON.parse(token) AV.User.become(tokenObj?._sessionToken) .then(function (user) &#123; // token 验证成功，user 是验证后返回的用户对象 next() &#125;) .catch(function (error) &#123; // token 验证失败 location.href = &quot;http://xiao-zhe-is-not-lazy.gitee.io/chou/#/login&quot; &#125;); &#125; 用户属性的更改，将awordNumber改为0 1234567891011var currentUser = AV.User.current(); currentUser.set(&quot;awordNumber&quot;, 0); currentUser .save() .then(function (updatedUser) &#123; // 更新成功 console.log(&quot;更新成功&quot;); &#125;) .catch(function (error) &#123; // 更新失败 &#125;); 我的项目页面展示我主要是写了一个抽奖的项目，一个用户登录后只能抽一次奖 登录界面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221&lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;cover&quot; v-if=&quot;isShow&quot;&gt;登录失败&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- span标签作为背景的圆形图案 --&gt; &lt;div class=&quot;bg&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;text&quot;&gt; 云亦音乐 &lt;span style=&quot; font-size: 12px; line-height: 50px; margin-left: 5px; color: gray; &quot; &gt;周年庆抽奖活动火热进行中!&lt;/span &gt; &lt;/div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;账号&quot; id=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; id=&quot;password&quot; /&gt; &lt;input type=&quot;text&quot; placeholder=&quot;验证码&quot; id=&quot;code&quot; /&gt; &lt;div class=&quot;code&quot;&gt; &lt;div&gt;验证码:&lt;/div&gt; &lt;div&gt;&#123;&#123; code &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;button @click=&quot;btn&quot;&gt;→&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import codeFun from &#x27;@/assets/code&#x27;const AV = require(&quot;leancloud-storage&quot;);// 初始化 LeanCloudAV.init(&#123; appId: &quot;隐藏&quot;, appKey: &quot;隐藏&quot;, serverURL: &quot;https://ysyeflyc.lc-cn-n1-shared.com&quot;,&#125;);export default &#123; data() &#123; return &#123; isShow: false, code: &quot;1234&quot;, timer: null, &#125;; &#125;, created()&#123; this.code = codeFun() &#125;, methods: &#123; btn() &#123; clearTimeout(this.timer); if (code.value == this.code) &#123; AV.User.logIn(username.value, password.value) .then((user) =&gt; &#123; // 登录成功 this.$router.push(&quot;/chou&quot;); &#125;) .catch(() =&gt; &#123; // 登录失败（可能是密码错误） this.isShow = true; this.timer = setTimeout(() =&gt; &#123; this.isShow = false; &#125;, 2000); &#125;); &#125; else &#123; this.code = codeFun() this.isShow = true; this.timer = setTimeout(() =&gt; &#123; this.isShow = false; &#125;, 2000); &#125; &#125;, &#125;,&#125;;&lt;/script&gt; &lt;style scoped&gt;.box &#123; background-color: rgba(0, 0, 0); margin: 0; padding: 0; width: 100%; height: 100%; position: absolute; z-index: -2;&#125;.container &#123; width: 80vw; height: 65vh; margin: 20vh auto; background-color: rgba(255, 255, 255, 0.1); border-radius: 20px; position: relative; box-shadow: inset 1px 1px 6px rgba(255, 255, 255, 0.3), 2px 2px 15px rgba(0, 0, 0, 0.5);&#125;input &#123; background: transparent; outline: none; border: none; border-bottom: 1px solid #666; width: 80%; height: 45px; font-size: 18px; margin-left: 30px; margin-top: 40px; color: white;&#125;.text &#123; display: inline-block; font-size: 26px; margin-left: 34px; margin-top: 50px; color: #eee;&#125;button &#123; border: none; width: 70px; height: 70px; border-radius: 50%; font-weight: bold; font-size: 26px; margin-top: 60px; margin-left: calc(50% - 35px); cursor: pointer; background-color: rgba(255, 255, 255, 0.1); color: white; text-align: center; box-shadow: 0 2px 10px #111;&#125;button:hover &#123; color: greenyellow; background-color: rgba(255, 255, 255, 0.2);&#125;span &#123; position: absolute; border-radius: 50%; box-shadow: 1px 1px 50px #000; z-index: -1;&#125;.bg &#123; width: 100%; height: 100%; position: absolute; z-index: -1; animation: am2 ease-out 1s;&#125;.bg span:nth-child(1) &#123; width: 80px; height: 80px; top: -30px; left: -30px; background-color: purple; animation: am1 ease-in-out 3s infinite alternate;&#125;.bg span:nth-child(2) &#123; width: 40px; height: 40px; top: 40px; right: 40px; background-color: orange; animation: am1 ease-in-out 4s infinite alternate-reverse;&#125;.bg span:nth-child(3) &#123; width: 120px; height: 120px; bottom: -60px; right: -25px; background-color: cyan; animation: am1 ease-in-out 2.5s 0.5s infinite alternate;&#125;/* 动画 */@keyframes am1 &#123; 0% &#123; transform: translateY(0); &#125; 100% &#123; transform: translateY(-30px); &#125;&#125;@keyframes am2 &#123; 0% &#123; transform: scale(0, 0) rotateZ(60deg); &#125; 100% &#123; transform: scale(1, 1) rotateZ(0); &#125;&#125;.cover &#123; width: 90vw; position: absolute; top: 10vh; left: 5vw; text-align: center; opacity: 0.9; color: #e10b0b; border-radius: 20px;&#125;/* 验证码 */.code &#123; color: #c2a3a3; display: flex; margin-left: 10%; margin-top: 10px;&#125;.code div:nth-child(2) &#123; width: 70px; height: 30px; text-align: center; line-height: 30px; margin-left: 10px; background-color: #353743; border: 1px solid white; font-size: 20px; border-radius: 3px;&#125;&lt;/style&gt; 登录页面需要引用的js（验证码的生成）123456789let codeFun = () =&gt; &#123; var code1 = String(Math.floor(Math.random() * 10)) var code2 = String(Math.floor(Math.random() * 10)) var code3 = String(Math.floor(Math.random() * 10)) var code4 = String(Math.floor(Math.random() * 10)) return code1 + code2 + code3 + code4&#125;export default codeFun 抽奖页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;template&gt; &lt;div @click=&quot;btn2()&quot; class=&quot;box&quot;&gt; &lt;audio src=&quot;@/assets/music.mp3&quot; autoplay&gt;&lt;/audio&gt; &lt;!-- 抽中奖品后的遮罩层 --&gt; &lt;div class=&quot;cover&quot; v-if=&quot;isShow&quot;&gt; &#123;&#123; selectedPrize?.name &#125;&#125; &lt;span&gt;恭喜你获得：&#123;&#123; selectedPrize?.describe &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;button @click.once=&quot;btn&quot;&gt;抽奖&lt;/button&gt; &lt;div&gt;剩余的抽奖次数: &#123;&#123; currentUser?.attributes.awordNumber &#125;&#125;&lt;/div&gt; &lt;footer&gt; &lt;h3&gt;奖品详情：&lt;/h3&gt; &lt;div v-for=&quot;(data, index) in prizes&quot; :key=&quot;index&quot;&gt; &lt;span&gt; &#123;&#123; data.name &#125;&#125; : &lt;/span&gt; &lt;span&gt;&#123;&#123; data.describe &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const AV = require(&quot;leancloud-storage&quot;);// 声明 classconst Todo = AV.Object.extend(&quot;Todo&quot;);// 构建对象const todo = new Todo();export default &#123; data() &#123; return &#123; prizes: [ &#123; name: &quot;一等奖&quot;, describe: &quot;免费体验课&quot;, probability: 0 &#125;, &#123; name: &quot;二等奖&quot;, describe: &quot;尤克里里一个&quot;, probability: 0 &#125;, &#123; name: &quot;三等奖&quot;, describe: &quot;小玩具一个&quot;, probability: 0.05 &#125;, &#123; name: &quot;四等奖&quot;, describe: &quot;免费来撸猫&quot;, probability: 0.15 &#125;, &#123; name: &quot;鼓励奖&quot;, describe: &quot;抱抱&quot;, probability: 1 &#125;, ], selectedPrize: null, isShow: false, currentUser: null, &#125;; &#125;, created() &#123; this.currentUser = AV.User.current(); &#125;, methods: &#123; btn(event) &#123; if (this.currentUser.attributes.awordNumber === 0) &#123; alert(&quot;抽奖次数已用完&quot;); return; &#125; this.isRote = true; this.currentUser.attributes.awordNumber -= 1; // 生成一个随机的概率值 var randomProbability = Math.random(); for (var i = 0; i &lt; this.prizes.length; i++) &#123; var prize = this.prizes[i]; if (randomProbability &lt; prize.probability) &#123; this.selectedPrize = prize; // 为属性赋值 todo.set(this.currentUser.attributes.username, prize.describe); break; &#125; else &#123; this.selectedPrize = &#123; name: &quot;空&quot;, describe: &quot;什么都没有&quot; &#125;; &#125; &#125; // 更新后台 this.currentUser.set( &quot;awordNumber&quot;, this.currentUser.attributes.awordNumber ); this.currentUser .save() .then(function (updatedUser) &#123; // 更新成功 console.log(&quot;更新成功&quot;); &#125;) .catch(function (error) &#123; // 更新失败 console.log(&quot;更新失败&quot;); &#125;); // 用户奖品的数据储存 // 将对象保存到云端 todo.save().then( (todo) =&gt; &#123; // 成功保存之后，执行其他逻辑 console.log(`奖品数据保存成功`); &#125;, (error) =&gt; &#123; // 异常处理 console.log(`奖品数据保存失败`); &#125; ); this.isShow = true; // 阻止冒泡 event.stopPropagation(); &#125;, btn2() &#123; this.isShow = false; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.box &#123; height: 100vh; background: no-repeat url(&quot;@/assets/bg.png&quot;); background-size: cover;&#125;button &#123; border: none; width: 70px; height: 70px; border-radius: 50%; font-weight: bold; font-size: 26px; margin-top: 60px; margin-left: calc(50% - 35px); cursor: pointer; background-color: rgba(255, 255, 255, 0.1); text-align: center; box-shadow: 0 2px 10px #111;&#125;.item &#123; width: 80px; height: 80px; background-color: rgba(0, 0, 0, 0.8); margin: 20px; color: #fff; line-height: 80px; text-align: center; border-radius: 10px; font-size: 14px;&#125;.cover &#123; width: 90vw; height: 30vh; position: absolute; top: 35vh; left: 5vw; text-align: center; line-height: 30vh; background-color: black; opacity: 0.9; color: #eee; border-radius: 20px;&#125;footer &#123; width: 100%; position: absolute; left: 0; bottom: 0; font-size: 15px; background-color: rgba(0, 0, 0, 0.4); color: white; font-size: 30px;&#125;footer span &#123; margin-bottom: 5px;&#125;@keyframes am1 &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125;&lt;/style&gt;","tags":["LeanCloud"]},{"title":"Aseprite汉化教程","path":"/2024/02/01/31/","content":"推荐一个好用的像素画制作软件官网：https://www.aseprite.org/ 汉化包与主题包下载在网上找了好久，才找到，于是直接上传到云仓库了，防止丢失，嘻嘻https://gitee.com/xiao-zhe-is-not-lazy/aseprite Aseprite汉化与主题修改 打开下载好的软件，找到左上角，点击Edit 将最下面的File type改为All files： 找到下载好的汉化包与主题包，增加即可 然后会发现多了种语言和主题： 将语言改为中文（将这里的en修改为sChinese）： 到了这一步会发现字体模糊，需要配置主题才可以 修改主题： 点击调整缩放：","tags":["Aseprite"],"categories":["游戏制作"]},{"title":"解决安装Godot时未授权","path":"/2024/02/01/30/","content":"最近对像素类游戏产生了极大的兴趣，感觉玩的不是很过瘾（主要是好多游戏都收费），于是我打算去自己动手制作一款像素类游戏找了很多游戏引擎，搜到最多的就是Unity和Godot，经过一番思考，我打算学习Godot 首先我喜欢Godot的编辑页面， 给人一种简约美 个人认为Godot容易上手 至于游戏的各种素材的制作， 也就是美术和音频，我打算慢慢积累，毕竟游戏制作我认为素材的制作最重要，也最难，目前是打算制作一款像素风格类的生存游戏 于是开始安装Godot找到官网https://godotengine.org/后，开始下载，速度很慢，但这不是大问题，大概下了一半左右，上面提示说未授权， 我真的很懵逼， 刚开始我以为是Godot需要收费，后面去搜索， 发现Godot是一款完全免费的软件，于是去找发现是本地安全策略的问题， 于是去看大佬们的解决办法， 这里@https://blog.csdn.net/weixin_60526471&#x2F;article&#x2F;details&#x2F;126105622 作者就是看这篇文章解决的， 为了防止文章丢失， 作者这里就记录一下 1. 新建一个txt文件，内容如下 123456@echo offpushd &quot;%~dp0&quot;dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txtdir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txtfor /f %%i in (&#x27;findstr /i . List.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;C:\\Windows\\servicing\\Packages\\%%i&quot;pause 2. 将txt文件的后缀改为.cmd, 然后右键以管理员身份打开，等待.cmd文件运行完成，就可以成功开启组策略了3. 同时按【WIN键+R键】，打开cmd命令窗口，输入gpedit.msc，这时候点击【确定】按钮，或按回车键(Enter)就可以打开本地策略组的内容了，4. 本地组策略编辑器找到之后就是调整一下设置了 。找到计算机配置 → windows管理 → 安全设置 → 本地策略 → 安全选项 → 用户控制：以管理员批准模式运行所有管理员 → 双击进入，设置为已禁用状态即可。重启电脑即可正常下载软件了。","tags":["Godot"],"categories":["游戏制作"]},{"title":"使用nvm对node进行版本管理","path":"/2024/02/01/29/","content":"下载nvm地址在https://github.com/coreybutler/nvm-windows/releases 下载后在任意终端执行, 看是否安装成功 1nvm -v 不成功的，可以先将已经安装的node卸载掉 nvm常用命令 安装指定版本: 1nvm install 版本号 列出远程服务器上所有的可用版本： 1nvm ls available 在不同版本间进行切换(已经安装了) 1nvm use 版本号 查看本地安装了的node版本 1nvm ls","tags":["node"],"categories":["前端进阶"]},{"title":"ws模块实现聊天的一些基本功能","path":"/2024/02/01/28/","content":"本篇文章难度较大哦，小伙伴们👀️本文要讲解的代码作者已上传至云仓库：https://gitee.com/xiao-zhe-is-not-lazy/chat学习本篇文章之前记得先去看:1.登录鉴权——JWT(前后端分离) | Lazychild&#39;s Blog2. 初始ws模块 | Lazychild&#39;s Blog 先写好一个基本的登录鉴权功能之前文章写过了，小伙伴们自己去看看吧👀️ 前端一共有两个界面： 登录界面 聊天室界面 到了这一步应该实现前端进行登录，后端进行token校验，成功后跳转至聊天室这个界面（只要跳转就行，后面会讲聊天室界面对于token的校验） 代码展示 登录界面代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;登录&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 const autorization = response.headers.autorization autorization &amp;&amp; localStorage.setItem(&#x27;token&#x27;, autorization) return response &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;聊天室登录界面&lt;/h2&gt; &lt;div&gt;账号：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;/div&gt; &lt;div&gt;密码：&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;登录&lt;/button&gt; &lt;script&gt; btn.onclick = function () &#123; axios.post(&#x27;http://localhost:3000/login&#x27;, &#123; username: username.value, password: password.value &#125;).then(res =&gt; &#123; if (res.data.ok) &#123; location.href = &#x27;/index&#x27; &#125; else &#123; alert(&#x27;账号或密码错误&#x27;) &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 基本的路由代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var express = require(&#x27;express&#x27;);var jwtObj = require(&#x27;../utils/jsonwebtoken&#x27;)const mysql2 = require(&#x27;mysql2&#x27;)var router = express.Router();/* GET home page. */router.get(&#x27;/login&#x27;, function (req, res, next) &#123; res.type(&#x27;html&#x27;); res.render(&#x27;login&#x27;)&#125;)router.get(&#x27;/index&#x27;, function (req, res, next) &#123; res.type(&#x27;html&#x27;); res.render(&#x27;index&#x27;)&#125;)let mony, namerouter.post(&#x27;/login&#x27;, async function (req, res) &#123; a = &#x27;users&#x27; // 创建连接池 const config = handleConfig() const promisePool = mysql2.createPool(config).promise() let users = await promisePool.query(`SELECT * FROM $&#123;a&#125; WHERE name=&#x27;$&#123;req.body.username&#125;&#x27; AND password=&#x27;$&#123;req.body.password&#125;&#x27;`) //sql语句 if (users[0].length) &#123; mony = users[0][0].mony name = users[0][0].name // 将token放在header中 const token = jwtObj.sign(&#123; name, mony &#125;, &#x27;1h&#x27;) res.header(&#x27;Autorization&#x27;, token) res.send(&#123; ok: 1 &#125;) &#125; else &#123; res.send(&#123; ok: 0 &#125;) &#125;&#125;)module.exports = router;// 连接数据库的基本配置function handleConfig() &#123; return &#123; host: &#x27;localhost&#x27;, port: 3306, user: &quot;root&quot;, password: &quot;&quot;, database: &quot;maizuo&quot;, connectLimit: 1 &#125;&#125; token加密&#x2F;解密代码 1234567891011121314151617181920const &#123; json &#125; = require(&#x27;express&#x27;)const jwt = require(&#x27;jsonwebtoken&#x27;)const key = &#x27;maizuoc312asdpkj&#x27; //秘钥const obj=&#123; // 加密 sign: function(data,time)&#123; const token=jwt.sign(data, key, &#123; expiresIn: time &#125;) return token &#125;, verify: function(token)&#123; try &#123; return jwt.verify(token, key) &#125; catch (error) &#123; return false &#125; &#125;&#125;module.exports=obj 各种依赖包记得下载 依赖包展示（package.json文件） 12345678910111213141516171819&#123; &quot;name&quot;: &quot;nodeapp2-jwt&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node ./bin/www&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;cookie-parser&quot;: &quot;~1.4.4&quot;, &quot;debug&quot;: &quot;~2.6.9&quot;, &quot;ejs&quot;: &quot;~2.6.1&quot;, &quot;express&quot;: &quot;~4.16.1&quot;, &quot;http-errors&quot;: &quot;~1.6.3&quot;, &quot;jsonwebtoken&quot;: &quot;^9.0.0&quot;, &quot;morgan&quot;: &quot;~1.9.1&quot;, &quot;mysql2&quot;: &quot;^3.3.3&quot;, &quot;ws&quot;: &quot;^8.13.0&quot; &#125;&#125; 进入主题ws模块大家之前应该就使用过了吧，这里主要是与之前的登录鉴权实现一些聊天的基本功能，比如群聊，单聊等，站长这里只讲功能，页面的美化得靠大家，直接代码展示node服务端ws代码展示(建议新建一个文件独立写ws的代码，容易维护)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const WebSocket = require(&quot;ws&quot;)const &#123; WebSocketServer &#125; = require(&quot;ws&quot;)const JWT = require(&#x27;../utils/jsonwebtoken&#x27;)const wss = new WebSocketServer(&#123; port: 8080 &#125;);wss.on(&#x27;connection&#x27;, function connection(ws, req) &#123; ws.on(&#x27;error&#x27;, console.error); // 验证token const payload = JWT.verify(req.url.split(&#x27;=&#x27;)[1]) if (payload) &#123; ws.user = payload // 通知在线用户的人数 sendAll() &#125; else &#123; ws.send(createMessage(WebSocketType.Error, null, &quot;登录已过期&quot;)) &#125; ws.on(&#x27;message&#x27;, function message(data, isBinary) &#123; // 解析前端发送过来的消息进行判断 const msgObj = JSON.parse(data) // 判断，进行逻辑处理 switch (msgObj.type) &#123; case WebSocketType.groupList: break; case WebSocketType.groupChat: wss.clients.forEach(function each(client) &#123; if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123; client.send(data, &#123; binary: isBinary &#125;); &#125; &#125;); break; case WebSocketType.singleChat: wss.clients.forEach(function each(client) &#123; if (client.user.name == msgObj.to &amp;&amp; client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123; client.send(data, &#123; binary: isBinary &#125;); &#125; &#125;); break; &#125; &#125;) // 当服务器断开时触发 ws.on(&#x27;close&#x27;, () =&gt; &#123; wss.clients.delete(ws.user) sendAll() &#125;)&#125;);const WebSocketType = &#123; Error: 0, groupList: 1, //在线人数 groupChat: 2, //群聊 singleChat: 3 //单聊&#125;function createMessage(type, user, data) &#123; return JSON.stringify(&#123; type, user, data &#125;)&#125;// 给所有的在线用户实时发送当前的用户列表function sendAll() &#123; wss.clients.forEach(function each(client) &#123; if (client.readyState === WebSocket.OPEN) &#123; client.send(createMessage(WebSocketType.groupList, null, JSON.stringify(Array.from(wss.clients).map(item =&gt; item.user)))) &#125; &#125;);&#125; 前端聊天室代码展示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;聊天室&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;聊天室&lt;/h1&gt; &lt;input type=&quot;text&quot; class=&quot;message&quot;&gt; &lt;select name=&quot;&quot; id=&quot;onlineUsers&quot;&gt;&lt;/select&gt; &lt;button id=&quot;btn&quot;&gt;发送&lt;/button&gt; &lt;script&gt; // to字段主要是在单聊时，知道要发给谁 function createMessage(type, data, to) &#123; return JSON.stringify(&#123; type, data, to &#125;) &#125; let btn = document.querySelector(&#x27;#btn&#x27;) let message = document.querySelector(&#x27;.message&#x27;) let onlineUsers = document.querySelector(&#x27;#onlineUsers&#x27;) const WebSocketType = &#123; Error: 0, groupList: 1, //在线人数 groupChat: 2, //群聊 singleChat: 3 //单聊 &#125; const ws = new WebSocket(`ws://localhost:8080?token=$&#123;localStorage.getItem(&#x27;token&#x27;)&#125;`) ws.onopen = () =&gt; &#123; console.log(&quot;服务器已连接&quot;) &#125; ws.onmessage = (msgObj) =&gt; &#123; // 解析后端传过来的值，进行判断 let dataObj = JSON.parse(msgObj.data) switch (dataObj.type) &#123; case WebSocketType.Error: location.href = &#x27;/login&#x27; break; case WebSocketType.groupList: // 获取用户列表 onlineUsers.innerHTML =&#x27;&lt;option value=&quot;all&quot;&gt;群发&lt;/option&gt;&#x27; + JSON.parse(dataObj.data).map(item =&gt;`&lt;option value=&quot;$&#123;item.name&#125;&quot;&gt;$&#123;item.name&#125;&lt;/option&gt;`) break; //群聊 case WebSocketType.groupChat: console.log(&#x27;群聊&#x27;, dataObj) break; //单聊 case WebSocketType.singleChat: console.log(&#x27;单聊&#x27;, dataObj) break; &#125; // 发送消息 btn.onclick = function () &#123; if (onlineUsers.value == &#x27;all&#x27;) &#123; // 群发 ws.send(createMessage(WebSocketType.groupChat, message.value)) &#125;else&#123; // 单聊 ws.send(createMessage(WebSocketType.singleChat, message.value, onlineUsers.value)) &#125; &#125; &#125; ws.onerror = () =&gt; &#123; console.log(&quot;error&quot;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 能够看到这里的小伙伴给自己鼓鼓掌吧，未来的前端是你们的🎉️","tags":["node"],"categories":["前端进阶"]},{"title":"闲聊篇（2023.7.6）","path":"/2024/02/01/27/","content":"7月6日，下班后有感：很想说说我以前喜欢过的女生 谈谈初中她是我的同桌，额，准确来说是我的初三的同桌吧，当时老班把我和她安排到同桌的时候，真的开心了好久，她长的不高，脸上有一些雀斑，和我一个姓，当时她成绩特别好，嗯嗯，至少比我好太多了，一般都是班上前几名，我真的对学习好的女生特别有好感，但是我当时用一组词来形容（可能现在也好不到哪去吧）就是：矮、穷、挫，反正不好的标签往我身上贴就行，但是不知道是谁说我喜欢你，搞的全班皆知，除了老班，我的本意哪敢和你说我喜欢你啊，我用脚趾头都能想到，你不可能喜欢我，哎！不记得这个走漏风声的人是谁了，不然在这里非得骂你几句，当时想着只要不影响你学习，我这一辈子都不会去告诉你我喜欢你的我觉得我同桌当时被我这样的人喜欢一定很痛苦吧，在这里向你道歉了，哈哈哈 谈谈高中高一刚进来的时候，也有过许多漂亮的女同学，但是我好像对爱情的向往再也没有了兴趣😮‍💨😮‍💨，好吧，我骗人的，其实我喜欢过一个女生，她的名字中有一个和我一样，长得不高，鼻子很挺，给人一种明星的感觉，成绩不是很好，但是好像喜欢一个人，真的没有什么标准，就是一瞬间，她的某个动作，或者某个眼神，直击你的心脏，哈哈哈哈，我这样描述，好肉麻，反正我知道她就是我喜欢的女生了，但是表白这种行为，在我这里就好比让我去摘天上的月亮这么难，可能受我原生家庭的影响吧，你别看我平时各种搞笑，其实我的自卑是刻在骨子里的，就是现在，我其实也没有自信，但是可能比以前好了（自我感觉）所以一直没有和她说后来分班了，其实我一直喜欢着她，直到现在毕业，我承认还是会想起她，但是还是没有向她袒露心声可能有些事情错过了就是一辈子，有些人一转身就是永远吧，我只能默默祝福你了呢，哈哈哈哈 谈谈大学好像有点喝醉了。。。头好晕，不写了","categories":["生活闲聊"]},{"title":"初始ws模块","path":"/2024/02/01/26/","content":"websocket协议Webscoket是Web浏览器和服务器之间的一种全双工通信协议 ，其中WebSocket协议由IETF定为标准，WebSocket API由W3C定为标准。 一旦Web客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。 通信过程中，可互相发送JSON、XML、HTML或图片等任意格式的数据。我们将基于这个协议，实现聊天室的功能 下载ws模块1npm i ws node服务端代码1234567891011121314151617const WebSocket = require(&quot;ws&quot;)const &#123; WebSocketServer &#125; = require(&quot;ws&quot;)const wss = new WebSocketServer(&#123; port: 8080 &#125;);wss.on(&#x27;connection&#x27;, function connection(ws) &#123; ws.on(&#x27;error&#x27;, console.error); ws.on(&#x27;message&#x27;, function message(data, isBinary) &#123; wss.clients.forEach(function each(client) &#123; if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123; client.send(data, &#123; binary: isBinary &#125;); &#125; &#125;); &#125;); ws.send(&quot;欢迎进入聊天室&quot;)&#125;); 前端代码12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;聊天室&lt;/h1&gt; &lt;script&gt; var ws = new WebSocket(&quot;ws://localhost:8080&quot;) ws.onopen = ()=&gt;&#123; console.log(&quot;连接成功&quot;) &#125; ws.onmessage = (msgObj)=&gt;&#123; console.log(msgObj.data) &#125; ws.onerror = ()=&gt;&#123; console.log(&quot;error&quot;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 测试打开两个前端页面（客户端），在一个客户端控制台输入ws.send(“hello”) 在另一个客户端的控制台就能收到hello这个消息了， 这里其实已经相当一个群聊功能了，只是聊天的用户都是互相不知道的，接下来作者会使用登录验证，让所有用户能够彼此能够认识 让我们实现私聊功能吧！！","tags":["node"],"categories":["前端进阶"]},{"title":"hexo博客项目部署至vercel","path":"/2024/02/01/25/","content":"部署过程太过于繁琐，作者真的好懒，不想写，这里就大概描述一下我的部署过程吧 注册github账号GitHub 因为作者之前用的都是Gitee，因为vercel的部署不能用Gitee了，所有注册github是必要的，并且作者悄悄的告诉你，github才是真正的源码市场，可以学到很多大佬的源码 下载fastgithub很多人访问github都很难进去，这是当然，毕竟是国外的网站，这里可以自己翻墙，但是大多数翻墙软件都需要money👀️ ，这里就不得不介绍另外一种软件了——fastgithub不多说，用它之后腰不疼，腿也不疼了，哈哈哈哈😄 直接搜索即可下载，网上有使用教程，作者真的很懒，不想多说 修改hexo下面的_config.yml文件因为作者之前用的是Gitee，你如果之前用的是github请省略这个步骤这一步也不想多说，主要是改变了云仓库的地址，直接展示： 1234deploy: type: git repo: 自己仓库的地址 branch: main 注册vercel账号https://vercel.com/ 这里最最最最最好使用github账号登录即可，方便后续代码的上传更新，总而言之，很方便注册成功后点击新建一个项目（不要跟我说新建项目也不会，实在不行请留言给我），之后会出现： 点击import导入自己github的项目即可🎉️最后经过一系列的操作就会成功部署，然后你很开心的打开vercel给你分配的域名发现根本无法访问，哎！！，这里注意vercel给的域名在国内是访问不了的，这里就需要接下来的步骤了 购买域名这里自己随便找个网站购买域名（其实挺麻烦，购买成功后，找到控制台，对域名进行解析，解析@，www这两个即可，这里需要绑定ip地址，可以在vercel的设置域名那里找到（具体的我也忘了，反正可以在vercel中找到👀️ ） vercel的配置创建好项目后点击： 进入后再点击： 这里接着的操作请使用浏览器自带的翻译功能，一步步的配置自己的域名，写起来挺麻烦，但是操作起来挺简单，这里配置成功后需要有一个等待时间他会不断的刷新，然后报错，等等他就好了 最后变成这样你就成功了🎉️ ： 最后一步修改hexo下面的_config.yml文件12url: 自己网站的域名root: / 记得重新上传代码","tags":["hexo"],"categories":["魔改"]},{"title":"留言板模块与文章评论开启","path":"/2024/02/01/24/","content":"注册LeanCloud账号注册LeanCloud账号是为了给评论的数据提供云存储 首先来到LeanCloud的首页:https://www.leancloud.cn/，点击右上角的控制台，按照指引进行注册即可 创建应用注册完成后,进行登录会进入这个页面：点击创建应用，随后填写一些应用的基本信息后你的应用就创建成功啦🎉️ 创建留言板页面1hexo new page message 修改其目录下的index.md为index.ejs,增添如下内容： 1234567891011121314151617181920212223242526272829---title: 留言板---&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&#x27;//unpkg.com/valine/dist/Valine.min.js&#x27;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Valine(&#123; el: &#x27;#vcomments&#x27;, appId: &#x27;你的AppID&#x27;, appKey: &#x27;你的AppKey&#x27;, placeholder: &#x27;欢迎大家来到lazychild,如果有什么想说的话，请留言给作者哦，作者会尽量快速回复大家的哦😜😜，注意邮箱一定不能写错哦，不然你就收不到作者的回复了&#x27;, avatar: &#x27;wavatar&#x27;, pageSize: 4, requiredFields: [&#x27;mail&#x27;] &#125;)&lt;/script&gt;&lt;/html&gt; AppID与AppKey的设置：创建好LeanCloud应用后，找到左边设置的应用凭证即可找到自己的AppID与AppKey 这里的评论系统使用的是基于基于LeanCloud的快速、简洁且高效的无后端评论系统————Valine，更多的Valine的配置请自主学习，请参考https://valine.js.org/configuration.html👀️ 增加导航栏菜单最后自己在主题配置文件_config.yml中配置即可这是我的： 12345678910menu: 首页: / || icon-shouye2 文章 || icon-xiewenzhang: 归档: /archives/ || icon-guidang 标签: /tags/ || icon-biaoqian 分类: /categories/ || icon-fenlei 统计: /statistics/ || icon-tongjitu 友链: /link/ || icon-LINKS 我的: /about/ || icon-gerenzhongxin_wodediqu 留言板: /message/ || icon-liuyanban icon图标是我自己引入的，你不能照搬哦👀️ ，具体的引入方法请参考菜单栏多色图标 | Lazychild&#39;s Blog (gitee.io)到这里你就已经完成了留言板模块了🎉️ 文章评论功能的开启在此之前小伙伴们肯定已经创建了一个LeanCloud应用了，这里请小伙伴们再创建一个LeanCloud应用，用来存放文章评论 创建成功后，找到主题配置文件_config.yml,修改： 12345678910comments: # Up to two comments system, the first will be shown as default # Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk use: Valine text: true # Display the comment name next to the button # lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport. # If you set it to true, the comment count will be invalid lazyload: true count: true # Display comment count in post&#x27;s top_img card_post_count: true # Display comment count in Home Page 12345678valine: appId: 你的AppID appKey: 你的AppKey avatar: wavatar # gravatar style https://valine.js.org/#/avatar serverURLs: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in) bg: # valine background visitor: false option: bug解决发现了一个bug，发现很多不需要用到评论的地方也有了评论功能，解决办法：在自定义的js文件中增加如下内容： 12345// 删除多余的评论板块// 解决留言板模块2次渲染问题导致评论区出现了2次if(path[2] == &#x27;message&#x27; || path[2] == &#x27;about&#x27; || path[2] == &#x27;tags&#x27; || path[2] == &#x27;categories&#x27; || path[2] == &#x27;statistics&#x27; || path[2] == &#x27;link&#x27;)&#123;\tvar postComment = document.querySelector(&#x27;#post-comment&#x27;) &amp;&amp; postComment.remove()&#125;","tags":["butterfly"],"categories":["魔改"]},{"title":"增加一个统计模块","path":"/2024/02/01/23/","content":"canvasJS的使用这是前端的一个画各种表格的插件，十分好用哦！！官网地址在https://canvasjs.com/ 新建一个js文件123456789101112131415161718// 将文章日期和数量存本地var achivesDate = document.querySelectorAll(&#x27;.card-archive-list-date&#x27;); var achivesDateNumber = document.querySelectorAll(&#x27;.card-archive-list-count&#x27;); var achivesDateArr = []; var achivesDateNumberArr = [];if (achivesDate.length) &#123;\tfor (var i = 0; i &lt; achivesDate.length; i++) &#123; achivesDateArr.push(achivesDate[i].innerHTML); achivesDateNumberArr.push(achivesDateNumber[i].innerHTML) &#125;; localStorage.setItem(&#x27;achivesDateArr&#x27;, achivesDateArr); localStorage.setItem(&#x27;achivesDateNumberArr&#x27;, achivesDateNumberArr)&#125;// 将分类信息存入本地var cardCategoryListCountArr = []var cardCategoryListNameArr = []var cardCategoryListCount = document.querySelectorAll(&#x27;.card-category-list-count&#x27;)var cardCategoryListName = document.querySelectorAll(&#x27;.card-category-list-name&#x27;)if (cardCategoryListCount.length) &#123;\tfor (var i = 0; i &lt; cardCategoryListCount.length; i++) &#123; cardCategoryListCountArr.push(cardCategoryListCount[i].innerHTML) cardCategoryListNameArr.push(cardCategoryListName[i].innerHTML)\t&#125;\tlocalStorage.setItem(&#x27;card-category-list-count&#x27;, cardCategoryListCountArr)\tlocalStorage.setItem(&#x27;card-category-list-name&#x27;, cardCategoryListNameArr)&#125; 记得引入至主题配置文件_config.yml中 新建页面在根目录source目录下新建一个目录statistics，在其下面新建index.ejs文件增加如下内容即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879---title: 统计---&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot;&gt;\t&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\t&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\t&lt;title&gt;Document&lt;/title&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.lazychild.fun/js/canvasJS.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;\t&lt;div id=&quot;chartContainer&quot; style=&quot;height: 300px; width: 95%;&quot;&gt;&lt;/div&gt;\t&lt;div id=&quot;chartContainer1&quot; style=&quot;height: 300px; width: 95%;&quot;&gt;&lt;/div&gt;\t&lt;script type=&quot;text/javascript&quot;&gt; // 从本地获取文章数量和日期 var achivesDateArr = localStorage.getItem(&#x27;achivesDateArr&#x27;).split(&#x27;,&#x27;).reverse() var achivesDateNumberArr = localStorage.getItem(&#x27;achivesDateNumberArr&#x27;).split(&#x27;,&#x27;).reverse() var cardCategoryListName = localStorage.getItem(&#x27;card-category-list-name&#x27;).split(&#x27;,&#x27;) var cardCategoryListCount = localStorage.getItem(&#x27;card-category-list-count&#x27;).split(&#x27;,&#x27;) // 文章 var chart = new CanvasJS.Chart(&quot;chartContainer&quot;, &#123; title: &#123; text: &quot;归档&quot; &#125;, data: [ &#123; dataPoints: [] &#125; ] &#125;); let initX = 1 for (var i = 0; i &lt; achivesDateArr.length; i++) &#123; chart.options.data[0].dataPoints.push(&#123; x: initX, y: parseInt(achivesDateNumberArr[i]), label: achivesDateArr[i] &#125;) initX++ &#125; chart.render(); // 分类 var chart1 = new CanvasJS.Chart(&quot;chartContainer1&quot;, &#123; legend: &#123; maxWidth: 350, itemWidth: 120 &#125;, title: &#123; text: &quot;分类&quot; &#125;, data: [ &#123; type: &quot;pie&quot;, showInLegend: true, legendText: &quot;&#123;indexLabel&#125;&quot;, dataPoints: [] &#125; ] &#125;); for (var i = 0; i &lt; cardCategoryListName.length; i++) &#123; chart1.options.data[0].dataPoints.push(&#123; y: parseInt(cardCategoryListCount[i]), indexLabel: cardCategoryListName[i] &#125;) &#125; chart1.render();\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后在增加一个导航栏12menu: 统计: /statistics/ || icon-tongjitu","tags":["butterfly"],"categories":["魔改"]},{"title":"vue项目打包部署至云仓库","path":"/2024/02/01/22/","content":"创建云仓库这里不做过多解释，网上都有教程，作者用的是Gitee创建好后就可以将自己的项目上传了 配置vue.config.js文件1234567module.exports = &#123; publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/仓库根目录的名字&#x27; : &#x27;/&#x27; , productionSourceMap: false,&#125; 修改.gitignore文件删除文件里dist这个字段修改此文件的目的是执行push命令时能上传dist目录， vue项目打包1npm run build 打包成功后会出现一个dist目录 使用git命令上传至云仓库这里还不会的建议先去看看教程 开启Gitee Pages先将远程仓库开源，然后在服务选项那里有一个Gitee Pages点进去开启就行(必须设置为开源哦)记得将部署的目录改成dist","tags":["vue"],"categories":["前端进阶"]},{"title":"Electron与vue的组合","path":"/2024/02/01/21/","content":"本篇文章出自：https://blog.csdn.net/honest1120110/article/details/116643392 创建vue项目1vue create myapp 安装electron环境Electron安装 1npm install electron Vue项目添加Electron-builder打包工具 1vue add electron-builder 提示：如果出现electron安装失败，或者后面使用electron-builder打包时，出现从github down包失败，请设置electron镜像。 1npm config edit 使用该命令会弹出npm的配置文档，将以下类容复制到文件末尾。 12electron_mirror=https://npm.taobao.org/mirrors/electron/electron-builder-binaries_mirror=https://npm.taobao.org/mirrors/electron-builder-binaries/ 测试1npm run electron:serve 运行成功后会自动弹出一个窗口，这就是你的app了，你成功了吗？ 替换客户端图标进入项目路径，查看是否存在vue.config.js同名文件（好像是vue3没有，vue2会有），没有则创建一个空文件。编辑vue.config.js文件 12345678910111213141516171819module.exports = &#123; pluginOptions: &#123; electronBuilder: &#123; builderOptions: &#123; &quot;appId&quot;: &quot;com.example.app&quot;, &quot;productName&quot;: &quot;aDemo&quot;,//项目名，也是生成的安装文件名，即aDemo.exe &quot;copyright&quot;: &quot;Copyright © 2023&quot;,//版权信息 &quot;directories&quot;: &#123; &quot;output&quot;: &quot;./dist&quot;//输出文件路径，之前编译的默认是dist_electron &#125;, &quot;win&quot;: &#123; &quot;icon&quot;: &quot;Demo.ico&quot;//这里注意配好图标路径 &#125; // options placed here will be merged with default configuration and passed to electron-builder &#125; &#125; &#125;&#125; electron-builder的更多配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;build&quot;: &#123; &quot;productName&quot;:&quot;xxxx&quot;, //项目名 这也是生成的exe文件的前缀名 &quot;appId&quot;: &quot;com.xxx.xxxxx&quot;,\t//包名 &quot;copyright&quot;:&quot;xxxx&quot;, //版权信息 &quot;directories&quot;: &#123; //输出文件夹 &quot;output&quot;: &quot;build&quot; &#125;, &quot;nsis&quot;: &#123;\t//nsis相关配置，打包方式为nsis时生效 &quot;oneClick&quot;: false, // 是否一键安装 &quot;allowElevation&quot;: true, // 允许请求提升，如果为false，则用户必须使用提升的权限重新启动安装程序。 &quot;allowToChangeInstallationDirectory&quot;: true, // 允许修改安装目录 &quot;installerIcon&quot;: &quot;./build/icons/aaa.ico&quot;, // 安装图标 &quot;uninstallerIcon&quot;: &quot;./build/icons/bbb.ico&quot;, //卸载图标 &quot;installerHeaderIcon&quot;: &quot;./build/icons/aaa.ico&quot;, // 安装时头部图标 &quot;createDesktopShortcut&quot;: true, // 创建桌面图标 &quot;createStartMenuShortcut&quot;: true, // 创建开始菜单图标 &quot;shortcutName&quot;: &quot;xxxx&quot;, // 图标名称 &quot;include&quot;: &quot;build/script/installer.nsh&quot;, // 包含的自定义nsis脚本 &#125;, &quot;publish&quot;: [ &#123; &quot;provider&quot;: &quot;generic&quot;, // 服务器提供商，也可以是GitHub等等 &quot;url&quot;: &quot;http://xxxxx/&quot; // 服务器地址 &#125; ], &quot;win&quot;: &#123; &quot;icon&quot;: &quot;build/icons/aims.ico&quot;, &quot;target&quot;: [ &#123; &quot;target&quot;: &quot;nsis&quot;, //使用nsis打成安装包，&quot;portable&quot;打包成免安装版 &quot;arch&quot;: [ &quot;ia32&quot;, //32位 &quot;x64&quot; //64位 ] &#125; ] &#125;, &quot;mac&quot;: &#123; &quot;icon&quot;: &quot;build/icons/icon.icns&quot; &#125;, &quot;linux&quot;: &#123; &quot;icon&quot;: &quot;build/icons&quot; &#125; &#125; 打包(生成桌面app)1npm run electron:build","tags":["Electron"],"categories":["桌面App"]},{"title":"首页轮播功能的实现","path":"/2024/02/01/20/","content":"本篇文章参考https://akilar.top/posts/8e1264d1/这里只是做个记录 在博客根目录安装插件1npm install hexo-butterfly-swiper --save 更改根目录下的_config.yml1234567891011121314151617## 增加首页的轮播功能# hexo-butterfly-swiper# see https://akilar.top/posts/8e1264d1/swiper: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: all # 应用页面 timemode: date #date/updated layout: # 挂载容器类型 type: id name: recent-posts index: 0 default_descr: 再怎么看我也不知道怎么描述它的啦！ swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css #swiper css依赖 swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js #swiper js依赖 custom_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css # 适配主题样式补丁 custom_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js # swiper初始化方法 增加文章的一个配置项1swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前","tags":["hexo"],"categories":["魔改"]},{"title":"登录鉴权——JWT(前后端分离)","path":"/2024/02/01/19/","content":"本篇文章适合有node基础的同学们哦！这篇文章记录了做的仿卖座电影的一个登录功能我用到的技术 express（基于node的后端） 数据库（我用的是Wampserver64） vue2 （前端） axios mysql2 jsonwebtoken 创建后台项目1express --view=ejs nodeApp 下载依赖1npm i 测试能否成功访问开启本地服务器： 1node ./bin/www 访问http://localhost:3000 创建数据库打开Wampserver64, 如果是绿色则启动成功 后端根目录下载mysql21npm i mysql2 前端下载axios1npm i axios 后端路由1234567891011121314151617181920212223242526272829303132var express = require(&#x27;express&#x27;);const mysql2 = require(&#x27;mysql2&#x27;)var router = express.Router();/* GET home page. */router.post(&#x27;/login&#x27;,async function(req, res)&#123; a=&#x27;users&#x27; // 创建连接池 const config=handleConfig() const promisePool=mysql2.createPool(config).promise() let users=await promisePool.query(`SELECT * FROM $&#123;a&#125; WHERE name=&#x27;$&#123;req.body.username&#125;&#x27; AND password=&#x27;$&#123;req.body.password&#125;&#x27;`) //sql语句 console.log(users[0]) if(users[0].length)&#123; res.send(&#123;ok:1&#125;) &#125;else&#123; res.send(&#123;ok:0&#125;) &#125;&#125;)module.exports = router;// 连接数据库的基本配置function handleConfig()&#123; return&#123; host:&#x27;localhost&#x27;, port:3306, user:&quot;root&quot;, password:&quot;&quot;, database:&quot;maizuo&quot;, connectLimit:1 &#125;&#125; express设置跨域12345678//设置允许跨域访问该服务.app.all(&#x27;*&#x27;, function (req, res, next) &#123; res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;); res.header(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;); next();&#125;); 前端请求代码12345678axios.post(&#x27;http://localhost:3000/login&#x27;,&#123; username:values.username, password:values.password &#125;).then(res=&gt;&#123; console.log(res.data) &#125;).catch(err=&gt;&#123; console.log(err) &#125;) 到这里就完成最基本的登录鉴权了，接下来进入主题 下载jsonwebtoken1npm i jsonwebtoken 导入1const jwt = require(&#x27;jsonwebtoken&#x27;) 创建一个公共js文件此文件用来存放jsonwebtoken的加密与解密函数 1234567891011121314151617181920const &#123; json &#125; = require(&#x27;express&#x27;)const jwt = require(&#x27;jsonwebtoken&#x27;)const key = &#x27;maizuoc312asdpkj&#x27; //秘钥const obj=&#123; // 加密 sign: function(data,time)&#123; const token=jwt.sign(data, key, &#123; expiresIn: time &#125;) return token &#125;, verify: function(token)&#123; try &#123; return jwt.verify(token, key) &#125; catch (error) &#123; return false &#125; &#125;&#125;module.exports=obj 更改express的路由12345678910111213141516171819router.post(&#x27;/login&#x27;,async function(req, res)&#123; a=&#x27;users&#x27; // 创建连接池 const config=handleConfig() const promisePool=mysql2.createPool(config).promise() let users=await promisePool.query(`SELECT * FROM $&#123;a&#125; WHERE name=&#x27;$&#123;req.body.username&#125;&#x27; AND password=&#x27;$&#123;req.body.password&#125;&#x27;`) //sql语句 if(users[0].length)&#123; mony=users[0][0].mony name=users[0][0].name // 将token放在header中 const token=jwtObj.sign(users[0][0],&#x27;1h&#x27;) res.header(&#x27;Autorization&#x27;, token) res.send(&#123; ok:1 &#125;) &#125;else&#123; res.send(&#123;ok:0&#125;) &#125;&#125;) 使用axios拦截器12345678910111213141516171819// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); 到这里会发现可能拿不到自定义头部在设置跨越那里加上 1res.header(&#x27;Access-Control-Expose-Headers&#x27;, &#x27;Autorization&#x27;); 意思就是允许头部信息Autorization的显示 拿到头部并保存本地1234567891011axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 const autorization = response.headers.autorization autorization &amp;&amp; localStorage.setItem(&#x27;token&#x27;,autorization) return response &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); 每次向后端请求都带上token123456789axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 const token=localStorage.getItem(&#x27;token&#x27;) config.headers.Authorization = `Bearer $&#123;token&#125;` return config &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;); 后端进行接收前端发过来的token进行校验1const examineToken = jwtObj.verify(req.headers.authorization.split(&#x27; &#x27;)[1]) 然后就可以对校验的结果进行自己相关的逻辑处理 总结就是前端输入登录账号与密码，后端进行判断，如果成功，就向前端通过header发送token的值前端接收到token后就存在本地，然后每次向后端发送请求时就带上这个token，后端进行校验后返回值给前端，前端根据后端返回的值再进行业务逻辑的一个处理","tags":["node"],"categories":["前端进阶"]},{"title":"登录鉴权——Cookie与Session(适合后台嵌套模板)","path":"/2024/02/01/18/","content":"本篇文章适合有node基础的同学们哦！我用到的技术 express（基于node的后端） json-server 创建项目1express --view=ejs nodeApp 下载依赖1npm i 测试能否成功访问开启本地服务器： 1node ./bin/www 访问http://localhost:3000 创建一个登录界面在views目录下（ejs）代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;卖座后台登录界面：&lt;/h1&gt; &lt;div&gt; &lt;span&gt;用户:&lt;/span&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; id=&quot;mypassword&quot;&gt; &lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn&quot;&gt;login&lt;/button&gt;&lt;/div&gt; &lt;script&gt; btn.onclick = function () &#123; // console.log(username.value,mypassword.value) fetch(&quot;http://localhost:3001/login&quot;, &#123; method: &#x27;POST&#x27;, headers: &#123; &quot;content-type&quot;: &quot;application/json&quot; &#125;, body: JSON.stringify(&#123; username: username.value, password: mypassword.value &#125;) &#125;).then(res =&gt; res.json()).then(res =&gt; &#123; if(res.ok===1)&#123; alert(&quot;登录成功&quot;) location.href = &#x27;http://localhost:3001/index&#x27; &#125;else&#123; alert(&#x27;登录失败&#x27;) &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建一个登录成功后的跳转界面（ejs）创建完后记得写好接口，渲染这个ejs页面 后台路由代码这里使用fetch一直报错，我不知道什么原因，后面使用了axios(好用，爱用，哈哈哈哈！！) 下载json-server1npm i -g json-server 开启json-server服务这里要注意:express项目与json-server的默认端口都是3000,建议修改express的端口（容易改），在bin目录下修改www即可在你的express项目下创建user.jsonuser.json的内容如下： 1234567891011121314&#123; &quot;users&quot;:[ &#123; &quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&quot;123&quot;, &quot;mony&quot;:&quot;567&quot; &#125;, &#123; &quot;username&quot;:&quot;test&quot;, &quot;password&quot;:&quot;1234&quot;, &quot;mony&quot;:&quot;11&quot; &#125; ]&#125; 执行 1json-server --watch user.json 这样你的user.json这个文件就在json-server的监听下了 下载axios(一种请求方式)1npm i axios 123456789101112131415161718192021222324252627var express = require(&#x27;express&#x27;);var axios = require(&#x27;axios&#x27;)var router = express.Router();/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;login&#x27;);&#125;);router.post(&#x27;/login&#x27;,function(req, res, next) &#123; let dataLength axios.get(&quot;http://localhost:3000/users&quot;).then(re=&gt;&#123; dataLength=re.data.length for(var i=0;i&lt;dataLength;i++)&#123; if(re.data[i].username==req.body.username &amp;&amp; re.data[i].password==req.body.password)&#123; res.send(&#123;ok:1&#125;) return &#125; &#125; if(i===dataLength)&#123; res.send(&#123;ok:0&#125;) &#125; &#125;)&#125;)module.exports = router; 这里作者只是讲一下登录鉴权的一个过程，就没有创建数据库了，正常的应该在路由中去获取数据库的内容，验证前端提交用户名与密码是否正确,作者这里就使用json-server模拟了一下后台数据 到这里最简单的一个登录鉴权就已经写完了但是现在好像不登录直接输入后台url地址也能访问，现在就要进入本篇文章的主题了，使用Express中间件 Express-session 安装express-session中间件1npm i express-session 配置app.js文件导入express-session1const session = require(&#x27;express-session&#x27;) 配置session（记得放在express的路由之前）12345678// 设置sessionapp.use(session(&#123; secret: &#x27;asdjlzxco&#x27;, //秘钥 resave: true, //重新设置session后，就会重新开始计算过期时间 saveUninitialized: true, //一开始访问就会生成一个无效的cookie, cookie: &#123; secure: false, maxAge: 1000*60*60 &#125;, name: &#x27;maiZuo&#x27;&#125;)) 修改post请求的路由(设置req.session.username的值)1234567891011121314151617router.post(&#x27;/&#x27;,function(req, res, next) &#123; let dataLength axios.get(&quot;http://localhost:3000/users&quot;).then(re=&gt;&#123; dataLength=re.data.length for(var i=0;i&lt;dataLength;i++)&#123; if(re.data[i].username==req.body.username &amp;&amp; re.data[i].password==req.body.password)&#123; req.session.username = re.data[i].username res.send(&#123;ok:1&#125;) return &#125; &#125; if(i===dataLength)&#123; res.send(&#123;ok:0&#125;) &#125; &#125;)&#125;) 创建中间件对接口进行拦截123456789101112131415app.use((req,res,next)=&gt;&#123; // 解决重定向次数过多，只要是关于登录有关的接口就放行 if(req.url.includes(&#x27;login&#x27;))&#123; next() return &#125; if(req.session.username)&#123; //重新设置session，刷新过期时间\treq.session.mydate = Date.now() next() &#125;else&#123; // 重定向到登录界面 res.redirect(&#x27;http://localhost:3001/login&#x27;) &#125;&#125;) 整个app.js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var createError = require(&#x27;http-errors&#x27;);var express = require(&#x27;express&#x27;);const session = require(&#x27;express-session&#x27;)var path = require(&#x27;path&#x27;);var cookieParser = require(&#x27;cookie-parser&#x27;);var logger = require(&#x27;morgan&#x27;);var loginRouter = require(&#x27;./routes/login&#x27;);var usersRouter = require(&#x27;./routes/users&#x27;);var app = express();// view engine setupapp.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.use(logger(&#x27;dev&#x27;));app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 设置sessionapp.use(session(&#123; secret: &#x27;asdjlzxco&#x27;, //秘钥 resave: true, //重新设置session后，就会重新开始计算过期时间 saveUninitialized: true, //一开始访问就会生成一个无效的cookie, cookie: &#123; secure: false, maxAge: 1000*60*60 &#125;, name: &#x27;maiZuo&#x27;&#125;))// 中间件对接口进行拦截app.use((req,res,next)=&gt;&#123; // 解决重定向次数过多，只要是关于登录有关的接口就放行 if(req.url.includes(&#x27;login&#x27;))&#123; next() return &#125; if(req.session.username)&#123; //重新设置session，刷新过期时间\treq.session.mydate = Date.now() next() &#125;else&#123; // 重定向到登录界面 res.redirect(&#x27;http://localhost:3001/login&#x27;) &#125;&#125;)app.use(&#x27;/login&#x27;, loginRouter); //登录界面的路由app.use(&#x27;/&#x27;, usersRouter); //登录成功后界面的路由// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; next(createError(404));&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&#x27;env&#x27;) === &#x27;development&#x27; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&#x27;error&#x27;);&#125;);module.exports = app; 到这一步，伙伴们你们已经实现了一个登录鉴权功能了，是不是很简单呢！！登出功能的实现在登录成功后的界面写一个退出按钮123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;卖座后台&lt;/h1&gt; &lt;div&gt;&lt;button id=&quot;btn&quot;&gt;退出登录&lt;/button&gt;&lt;/div&gt; &lt;script&gt; btn.onclick=function()&#123; fetch(&#x27;http://localhost:3001/exit&#x27;).then(res=&gt;res.json()).then(res=&gt;&#123; if(res.ok===1)&#123; location.href = &#x27;./login&#x27; &#125;else&#123; alert(&quot;退出失败&quot;) &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后台退出的接口1234router.get(&#x27;/exit&#x27;, function(req, res, next) &#123; req.session.destroy() res.send(&#123;ok:1&#125;)&#125;); 总结呼！终于写完了，这种方法的弊端还是很多的，一旦登录用户一多，后台内存不断变大，容易导致后台直接奔溃，当然session可以存数据库，但是流量一大对数据库的压力也不小，所以也有另外一种登录鉴权方案——————JWT方案","tags":["node"],"categories":["前端进阶"]},{"title":"Electron的初次认识","path":"/2024/02/01/17/","content":"什么是Electron 简单的讲就是，使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架， 这篇博客将介绍Electron的最基本的使用—–打包自己的博客变成桌面App 创建一个文件夹 初始化，也就是记录版本与使用的依赖包 1npm init 将项目导入 Forge（注意兼容性）12npm install --save-dev @electron-forge/clinpx electron-forge import 这一步可能会出现node版本过高的错误，建议降低node版本（网上有很多教程），使其可以兼容Electron，注意node版本降低后，要重新全局安装npm哦！！ 安装成功后package.json会出现以下内容： 12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron-forge start&quot;, &quot;package&quot;: &quot;electron-forge package&quot;, &quot;make&quot;: &quot;electron-forge make&quot; &#125;, 建立一个js文件名字要与package.json这个相同 1&quot;main&quot;: &quot;index.js&quot;, 将以下内容写入index.js中 1234567891011121314151617181920212223242526272829303132const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)const path = require(&#x27;path&#x27;)function createWindow () &#123; const win = new BrowserWindow(&#123; &lt;!-- 更改窗口尺寸--&gt; width: 1000, height: 800, webPreferences: &#123; preload: path.join(__dirname, &#x27;preload.js&#x27;) &#125; &#125;) win.loadURL(&#x27;自己博客的地址&#x27;)&#125;app.whenReady().then(() =&gt; &#123; createWindow() app.on(&#x27;activate&#x27;, () =&gt; &#123; if (BrowserWindow.getAllWindows().length === 0) &#123; createWindow() &#125; &#125;)&#125;)app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit() &#125;&#125;) 将win.loadURL的地址写上自己博客的即可 执行 1npm start 可以看效果 更改图标修改forge.config.js的内容 123456789101112131415161718192021222324252627const path = require(&#x27;path&#x27;)module.exports = &#123; packagerConfig: &#123; // 自定义图标 icon: path.join(__dirname, &#x27;./favicon.ico&#x27;) &#125;, rebuildConfig: &#123;&#125;, makers: [ &#123; name: &#x27;@electron-forge/maker-squirrel&#x27;, config: &#123;&#125;, &#125;, &#123; name: &#x27;@electron-forge/maker-zip&#x27;, platforms: [&#x27;darwin&#x27;], &#125;, &#123; name: &#x27;@electron-forge/maker-deb&#x27;, config: &#123;&#125;, &#125;, &#123; name: &#x27;@electron-forge/maker-rpm&#x27;, config: &#123;&#125;, &#125;, ],&#125;; 生成桌面应用执行 1npm run make 出现out文件夹，打开里面的.exe文件即可注意ico的尺寸必须是256*256的，不然设置不上去，然后ico图标由于缓存可能会有延迟 我的博客的压缩文件地址https://gitee.com/xiao-zhe-is-not-lazy/lazychild-zip","tags":["Electron"],"categories":["桌面App"]},{"title":"面试题-1（来自b站千峰教育）","path":"/2024/02/01/16/","content":"rem em vw vw 百分比区别 相同点： rem，em，vw，vh，vw属于前端开发除了px单位之外的另外几种单位取值；但是具体含义存在区别 不同点： px：是像素单位，属于绝对单位，是一个具体的大小 rem：相对于根元素进行设置 em：如果自身有字体大小的设置，那么就相对于自身字体大小设置，如果自身没有字体大小设置，那么就相当于父元素进行设置。 vw：1vw相当于浏览器窗口宽度的百分之一 vh：1vh相当于浏览器窗口高度的百分之一 百分比：相对于父元素宽度或者高度的百分之几 注意：vw和vh是视口可以观看的区域的大小；如果没有滚动条的话，则宽度设置成100vw和100%的时候实现的效果一直；如果有滚动的话，则100vw中不是包括滚动条的，100%是包括滚动条的距离的 12345678910111213141516171819&lt;!--注意里面的代码解释说明--&gt; &lt;style&gt; *&#123;margin:0;padding:0&#125; html,body&#123; height: 100%; &#125; .box1&#123; width: 100%; height:500px; background-color: red; &#125; .box2&#123; width: 100vw; height:500px; background-color: green; &#125; &lt;/style&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; 750的设计图，20px为多少rem首先设计图是UI设计提供给前端开发工程师的设计稿，750的设计图出自于手机屏幕为375px*667px的iphone678手机屏幕的设计稿，这里也可以称之为2倍图。20px的字体大小涉及到了单位的转换，页面中默认的字体大小为16px，那么此时的1rem &#x3D; 16px;那么20px通过计算得出公式 1rem &#x3D; 16px; ?rem &#x3D; 20px; 得出结果为:1.25rem 扩展1：因为他的设备像素比（dpr&#x3D;物理像素&#x2F;CSS像素）是2；dpr是一个固定的比值；不同的手机型号比值不应：物理像素：可以理解成你ps里面测量的距离的大小CSS像素：你编写开发代码的时候CSS里面给定的像素值；dpr固定值如下如： app怎么做适配的 基于手机系统开发的app(原生Android&#x2F;IOS) 另外一种是webapp 设置以下标签：1&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;&quot; name=&quot;viewport&quot; /&gt; 具体的含义为：app完成的页面的宽度等于设备的宽度，页面的缩放比例为1.0，不允许最大缩放； 使用媒体查询和响应式做适配 使用媒体查询检测设备屏幕的大小改变布局样式，但是成本耗费比较大，不易操作 使用单位自己单位中经常使用的封装好的flexble.js文件做适配 封装好的flexble.js文件文件可以做到适配，并且原理是已经封装好的视口和设备像素比基于webapp开发 bfc是什么，清楚浮动的原理 BFC含义： 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域 BFC触发条件： 根元素 float属性不为none（脱离文档流） position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inine-flex overflow不为visible BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（按照最大margin值设置） 每个元素的margin box的左边， 与包含块border box的左边相接触 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 计算BFC的高度时，浮动元素也参与计算 boder实现0.5像素实现方法：CSS3有缩放的属性，我们可以利用这个属性，缩小50%的1px的边框，来实现这个功能代码如下： 12345678910111213141516171819202122html&lt;div class=&quot;border3&quot;&gt; &lt;div class=&quot;content&quot;&gt;伪类设置的边框&lt;/div&gt;&lt;/div&gt; &lt;style&gt;*&#123; margin:0;padding:0&#125;.border3&#123; position: relative; &#125;.border3:before&#123; content: &#x27;&#x27;; position: absolute; width: 200%; height: 200%; border: 1px solid red; transform-origin: 0 0; transform: scale(0.5, 0.5); box-sizing: border-box; &#125;&lt;/style&gt; 场景题（两个盒子，左边固定宽，右边自适应，你能想到几种方法） 公共HTML代码部分 12345html&lt;div class=&quot;content&quot;&gt;\t&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\t&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 方法一：float来和BFC实现 12345678910111213141516171819html&lt;style&gt;.content &#123; border: 1px solid #000; height: 800px; padding: 20px;&#125;.left &#123; width: 200px; height: 100%; background: red; float: left;&#125;.right &#123; height: 100%; background: pink; overflow: hidden;&#125;&lt;/style&gt; 方法二：absolute定位和margin值实现 12345678910111213141516171819html&lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; &#125; .left &#123; width: 200px; height: 100%; background: red; position: absolute; &#125; .right &#123; height: 100%; background: pink; margin-left: 200px; &#125;&lt;/style&gt; 方法三：calc(100% - 固定内容的宽度) 用calc函数动态计算数值 1234567891011121314151617181920html&lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; &#125; .left &#123; width: 200px; height: 100%; background: red; float: left; &#125; .right &#123; height: 100%; background: pink; float: left; width: calc(100% - 200px); &#125;&lt;/style&gt; 方法四：flex布局轻松搞定 12345678910111213141516171819html&lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; display: flex; &#125; .left &#123; width: 200px; height: 100%; background: red; &#125; .right &#123; height: 100%; background: pink; flex: 1; &#125;&lt;/style&gt; 方法五：使用table和table-cell实现 1234567891011121314151617181920html &lt;style&gt; .content &#123; border: 1px solid #000; width: 100%; height: 800px; display: table; &#125; .left &#123; width: 200px; height: 100%; background: red; display: table-cell; &#125; .right &#123; height: 100%; background: pink; display: table-cell; &#125;&lt;/style&gt; 方法六：使用inline-block携手calc函数设置宽度 123456789101112131415161718192021222324html&lt;style&gt; .content &#123; border: 1px solid #000; width: 100%; height: 800px; font-size: 0; &#125; .left &#123; width: 200px; height: 100%; background: red; display: inline-block; vertical-align: top; &#125; .right &#123; height: 100%; background: pink; display: inline-block; vertical-align: top; width: calc(100% - 200px); font-size: 16px; &#125;&lt;/style&gt; css 选择器有哪些，权重是什么样的选择器含义：选择器是查找页面元素的一种方式方法，选择器的种类有很多种。常用的选择器有以下内容： ID #id class .class 标签 p 通用 * 属性 type&#x3D;”text” 伪类 :link :visited :hover :active 伪元素 ::first-line :first-letter 子选择器 div&gt;p 后代选择器 div p 相邻兄弟 div+p 通用兄弟 div~p 结构伪类 :nth-child :first-child :last-child 权重计算规则： 第一等：代表内联样式，如: style&#x3D;””，权值为1000。 第二等：代表ID选择器，如：#content，权值为0100。 第三等：代表类，伪类和属性选择器，如.content，权值为0010。 第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。 通配符、*权值为0000。 继承的样式没有权重值。 important &gt; 内联 &gt; ID &gt; 类| 伪类 | 属性选择|伪对象 &gt; 标签 &gt; 继承 &gt; 通配符","tags":["一阶段面试题集锦"],"categories":["前端面试题"]},{"title":"菜单栏多色图标","path":"/2024/02/01/15/","content":"这篇文章引自这里https://www.fomal.cc/posts/5389e93f.html,作者怕文章丢失就写在这里啦！找到自己想要的矢量图标推荐网站阿里巴巴矢量图标库 引入下载js代码(butterfly下面的_config.yml)123inject: bottom: - &lt;script src=&quot;/hexo/download/shiLiang/iconfont.js&quot;&gt;&lt;/script&gt; 替换[BlogRoot]\\themes\\butterfly\\layout\\includes\\header\\menu_item.pug为以下代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546if theme.menu .menus_items each value, label in theme.menu if typeof value !== &#x27;object&#x27; .menus_item - const valueArray = value.split(&#x27;||&#x27;) a.site-page.faa-parent.animated-hover(href=url_for(trim(value.split(&#x27;||&#x27;)[0]))) if valueArray[1] i.fa-fw(class=trim(valueArray[1])) - var icon_value = trim(value.split(&#x27;||&#x27;)[1]) - var anima_value = value.split(&#x27;||&#x27;)[2] ? trim(value.split(&#x27;||&#x27;)[2]) : &#x27;faa-tada&#x27; if icon_value.substring(0,2)==&quot;fa&quot; i.fa-fw(class=icon_value + &#x27; &#x27; + anima_value) else if icon_value.substring(0,4)==&quot;icon&quot; svg.icon(aria-hidden=&quot;true&quot; class=anima_value) use(xlink:href=`#`+ icon_value) span=&#x27; &#x27;+label else .menus_item - const labelArray = label.split(&#x27;||&#x27;) - const hideClass = labelArray[3] &amp;&amp; trim(labelArray[3]) === &#x27;hide&#x27; ? &#x27;hide&#x27; : &#x27;&#x27; a.site-page.group.faa-parent.animated-hover(class=`$&#123;hideClass&#125;` href=&#x27;javascript:void(0);&#x27;) if labelArray[1] - var icon_label = trim(label.split(&#x27;||&#x27;)[1]) - var anima_label = label.split(&#x27;||&#x27;)[2] ? trim(label.split(&#x27;||&#x27;)[2]) : &#x27;faa-tada&#x27; if icon_label.substring(0,2)==&quot;fa&quot; i.fa-fw(class=icon_label + &#x27; &#x27; + anima_label) else if icon_label.substring(0,4)==&quot;icon&quot; svg.icon(aria-hidden=&quot;true&quot; class=anima_label) use(xlink:href=`#`+ icon_label) span=&#x27; &#x27;+ trim(labelArray[0]) i.fas.fa-chevron-down ul.menus_item_child each val,lab in value - const valArray = val.split(&#x27;||&#x27;) li a.site-page.child.faa-parent.animated-hover(href=url_for(trim(val.split(&#x27;||&#x27;)[0]))) if valArray[1] - var icon_val = trim(val.split(&#x27;||&#x27;)[1]) - var anima_val = val.split(&#x27;||&#x27;)[2] ? trim(val.split(&#x27;||&#x27;)[2]) : &#x27;faa-tada&#x27; if icon_val.substring(0,2)==&quot;fa&quot; i.fa-fw(class=icon_val + &#x27; &#x27; + anima_val) else if icon_val.substring(0,4)==&quot;icon&quot; svg.icon(aria-hidden=&quot;true&quot; class=anima_val) use(xlink:href=`#`+ icon_val) span=&#x27; &#x27;+ lab 配置butterfly下面的_config.yml123456789menu: 首页: / || icon-shouye2 文章 || icon-xiewenzhang: 归档: /archives/ || icon-guidang 标签: /tags/ || icon-biaoqian 分类: /categories/ || icon-fenlei 友链: /link/ || icon-LINKS 我的: /about/ || icon-gerenzhongxin_wodediqu 留言板: /message/ || icon-liuyanban","tags":["butterfly"],"categories":["魔改"]},{"title":"依赖包与vue版本冲突问题","path":"/2024/02/01/14/","content":"😀😀这篇文章是根据作者自身犯的错误写的，在遇到同类错误时，请根据具体情况去找到自己的错误哦！！ 出现的问题当你下载某个模块时： 错误的解释：这是一个 npm 依赖冲突的错误。具体来说，在解决包的依赖关系时，npm 发现主项目使用了vue: 2.6.14，然后 vue-router 依赖于vue: 3.2.0，两个版本不兼容，导致冲突。 解决方法: 可以尝试在 npm install 命令后加上 –force 或 –legacy-peer-deps 参数来忽略错误，但这可能会导致包的版本兼容性问题。 更好的方法是解决依赖冲突，使得主项目和 vue-router 使用相同的 vue 版本，或者使用兼容的版本。 解决依赖冲突 在 package.json 中修改 vue 的版本号，将版本号更新为 “^3.2.0”（或者，将 vue 的版本设置为 “~2.6.14”，这意味着允许在小版本更新范围内更新版本号） 执行命令：npm update vue 再次执行命令：npm install 命令解释：执行 npm update vue 命令后，npm 会检查所有引用 vue 的包，并在这些包中寻找符合 vue 版本要求的中间版本。如果找到了可更新的版本，npm 就会下载并安装它们。但是，它并不会在 package.json 文件中更新版本号。因此，第三步执行的是 npm install 命令，这样可以确保更新后的依赖关系被记录在 package.json 文件中，以便将来进行版本控制。注意，如果 npm update vue 命令没有更新任何依赖项，则可以跳过第三步。","tags":["vue"],"categories":["前端进阶"]},{"title":"WgpSec CTF(web:尝试找到你的小姐姐吧)","path":"/2024/02/01/13/","content":"作者的啰嗦这是作者第一次更新有关ctf题目的文章，那么什么是CTF比赛呢？CTF是一种流行的信息安全竞赛形式，其英文名可直译为”夺得Flag”，也可意译为”夺旗赛”。其大致流程是，参赛团队之间通过进行攻防对抗、程序分析等形式，率先从主办方给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而夺得分数。为了方便称呼，我们把这样的内容称之为”Flag”。具体的的一些细节，我就不在这里说明了，如果您对CTF感兴趣的话，可以具体找找相关说明。 题目的网站这里是WgpSec CTF官方网站https://ctf.wgpsec.org，然后找到web题目:尝试找到你的小姐姐吧 开始做题在正式开始之前，你需要了解如下： 什么是robots协议 电脑已经有了Python环境，并且下载了pip（我的解题思路会用到Python脚本） 正式开始点进去后发现是这样的 什么都没有先查看一下源代码： 他说百度收录不了，那肯定就是robots协议，什么是robots协议呢？Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。试着访问&#x2F;robots.txt: 发现一个路径：&#x2F;readme_hahah.txt，试着访问它： 这里的信息特别多： 首先用户名是admin 密码是5位的数字 网站的登录网址（被遮盖了一部分） base32位解码将Hint的内容进行base32位解码（网上在线解码即可）： 提示我们用记事本打开最初的那张照片，那我们先右键图片进行下载后打开。可以找到： 这就是登录网址被遮盖的一部分：&#x2F;7b6ca699输入网址：http://web.t.ctf.wgpsec.org/notjustweb/7b6ca699/login.html 脚本爆破这里作者的方法是用Python进行爆破：1234567891011121314151617181920212223import requestsdef num(x): mmm = 6 - x item1 = &#x27;&#x27; ooo = range(1, mmm) for it in ooo: item1 += &#x27;0&#x27; return item1#url = &#x27;http://web.t.ctf.wgpsec.org/notjustweb/7b6ca699/login.php&#x27;data = &#123;&#x27;username&#x27;: &#x27;admin&#x27;, &#x27;password&#x27;: &#x27;00000&#x27;, &#x27;verifycode&#x27;: &#x27;&#x27;, &#x27;submit&#x27;: &#x27;&#x27;&#125;a = range(0, 10000)for item in a: stritem = str(item) newitem = num(len(stritem)) + stritem data[&#x27;password&#x27;] = newitem r = requests.post(url, data) print(r.text + newitem) 得到flag：","tags":["web"],"categories":["ctf"]},{"title":"基于hexo的搜索功能","path":"/2024/02/01/12/","content":"安装依赖包1npm install hexo-generator-search 添加代码至hexo下面的_config.yml文件1234search: path: search.xml field: post content: true 修改butterfly下面的_config.yml文件123local_search: enable: true preload: true 最后在重新部署即可","tags":["hexo"],"categories":["魔改"]},{"title":"更换博客背景2.0版本（自由选择）","path":"/2024/02/01/11/","content":"感觉用js去写html确实有点难度啊，而且js去写html的代码真的很乱（站长能力有限，只能写出这样的代码了，我会继续学习，优化自己的代码的，哈哈哈哈），维护起来不容易啊！！！ 更改后的js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// 适合于电脑的背景var arrImg = [&#x27;https://www.toopic.cn/public/uploads/small/1634204095151163420409592.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/163420343597163420343525.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1637562996238163756299635.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642751534826164275153484.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642751487281164275148774.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642751473324164275147339.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/164275143227816427514329.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642751024946164275102446.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642750988739164275098839.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/164275047944164275047961.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/164275045439516427504541.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642750432122164275043293.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1637562995904163756299548.png&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1634204739682163420473994.jpg&#x27;]// 适合于手机的背景var arrImg_1=[&#x27;https://www.toopic.cn/public/uploads/small/1643009966127164300996671.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009930474164300993032.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009928240164300992847.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1642756678726164275667880.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009950579164300995042.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009929331164300992978.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/16430099287616430099288.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009925630164300992534.jpg&#x27;,\t&#x27;https://www.toopic.cn/public/uploads/small/1643009891321164300989160.jpg&#x27;]var a = document.querySelector(&#x27;.full_page&#x27;)var b = document.querySelector(&#x27;.menus_item&#x27;)var c = document.querySelector(&#x27;#menus&#x27;)var odiv = document.createElement(&#x27;div&#x27;) //创建一个div标签var suoying = parseInt(Math.random() * arrImg.length) //用来记录是第几张图片var suoying_1 = parseInt(Math.random() * arrImg_1.length) //用来记录是第几张图片odiv.innerHTML =\t&#x27;&lt;svg t=&quot;1681093944846&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;4217&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M947.2 173.248c6.912 0 12.8 5.888 12.8 12.8v615.232c0 6.912-5.888 12.8-12.8 12.8H76.8c-6.912 0-12.8-5.888-12.8-12.8V186.048c0-6.912 5.888-12.8 12.8-12.8h870.4m0-64H76.8c-42.24 0-76.8 34.56-76.8 76.8v615.232c0 42.24 34.56 76.8 76.8 76.8h870.4c42.24 0 76.8-34.56 76.8-76.8V186.048c0-42.24-34.56-76.8-76.8-76.8z&quot; fill=&quot;blue&quot; p-id=&quot;4218&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M694.4 760.192H117.824l242.176-257.28c25.344-26.944 66.88-26.944 92.224 0l242.176 257.28z&quot; fill=&quot;aqua&quot; p-id=&quot;4219&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M906.176 760.192H519.296l87.552-92.992 59.84-63.552c25.28-26.944 66.816-26.944 92.16 0l147.328 156.544z&quot; fill=&quot;aqua&quot; p-id=&quot;4220&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M649.792 341.952m-62.976 0a62.976 62.976 0 1 0 125.952 0 62.976 62.976 0 1 0-125.952 0Z&quot; fill=&quot;aqua&quot; p-id=&quot;4221&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;span&gt;更换背景&lt;/span&gt;&#x27;odiv.id = &#x27;custom&#x27; //给自己创建的div标签挂一个id属性，方便对其样式进行修改// 生成弹窗var al = document.querySelector(&#x27;#sidebar&#x27;)$alert1 = document.createElement(&#x27;div&#x27;)$alert2 = document.createElement(&#x27;div&#x27;)$alert5 = document.createElement(&#x27;div&#x27;)$alert6 = document.createElement(&#x27;div&#x27;)$alert7 = document.createElement(&#x27;div&#x27;)$alert8 = document.createElement(&#x27;div&#x27;)$alert9 = document.createElement(&#x27;div&#x27;)$alert10 = document.createElement(&#x27;div&#x27;)$alert11 = document.createElement(&#x27;div&#x27;)$alert12 = document.createElement(&#x27;div&#x27;)$alert13 = document.createElement(&#x27;div&#x27;)$alert14 = document.createElement(&#x27;div&#x27;)$input = document.createElement(&#x27;input&#x27;)$alert1.id = &#x27;alert&#x27;$alert2.id = &#x27;alertcenter&#x27;$alert10.innerHTML = &#x27;🥥🥥更换背景&#x27;$alert7.innerHTML = &#x27;自定义背景：&#x27;$alert8.innerHTML = &#x27;更改&#x27;$alert9.innerHTML = &#x27;&lt;label&gt;×&lt;/label&gt;&#x27;$alert12.innerHTML = &#x27;适合于电脑的背景:&#x27;$alert13.innerHTML = &#x27;适合于手机的背景:&#x27;$alert5.id = &#x27;alertcenterHeader&#x27;$alert6.id = &#x27;alertcenterContent&#x27;$alert8.id = &#x27;aaa&#x27;$alert11.id = &#x27;bbb&#x27;$alert14.id = &#x27;alertcenterContent_1&#x27;$input.type = &#x27;text&#x27;$input.placeholder = &#x27;请输入自定义背景的链接&#x27;$input.id = &#x27;alertcenterContentInput&#x27;odiv.onclick = function() &#123;\t$alert1.style.display = &#x27;block&#x27;&#125;c.appendChild(odiv)console.log(window.document.documentElement.clientWidth)if(window.document.documentElement.clientWidth&lt;500)&#123;\ta.style.backgroundImage = `url($&#123;arrImg_1[suoying_1]&#125;)`&#125;else&#123;\ta.style.backgroundImage = `url($&#123;arrImg[suoying]&#125;)`&#125;al.onclick = function(evt) &#123;\t// 这个if语句是为了只有点击空白处时才会关闭弹窗\tif (evt.target.id == &#x27;alert&#x27;) &#123; $alert1.style.display = &#x27;none&#x27;\t&#125;&#125;// ×的点击事件$alert9.onclick = function() &#123;\t$alert1.style.display = &#x27;none&#x27;&#125;// 判读照片链接的函数function checkImg(imgUrl) &#123;\treturn new Promise((resolve, reject) =&gt; &#123; var ImgObj = new Image() ImgObj.src = imgUrl ImgObj.onload = function(res) &#123; resolve(res) &#125; ImgObj.onerror = function(err) &#123; reject(err) &#125;\t&#125;)&#125;// 更改的事件$alert8.onclick = function() &#123;\tcheckImg($input.value).then(() =&gt; &#123; a.style.backgroundImage = `url($&#123;$input.value&#125;)`\t&#125;).catch(() =&gt; &#123; alert(&#x27;照片链接错误&#x27;)\t&#125;)&#125;al.appendChild($alert1)$alert1.appendChild($alert2)$alert2.appendChild($alert5)$alert2.appendChild($alert12)$alert2.appendChild($alert6)$alert2.appendChild($alert13)$alert2.appendChild($alert14)$alert2.appendChild($alert7)$alert2.appendChild($input)$alert2.appendChild($alert8)$alert5.appendChild($alert11)$alert11.appendChild($alert10)$alert11.appendChild($alert9)// 根据存放的照片数量创建img标签// 电脑背景for (let i = 0; i &lt; arrImg.length; i++) &#123;\tvar img = document.createElement(&#x27;img&#x27;)\timg.src = arrImg[i]\timg.onclick = function() &#123; a.style.backgroundImage = `url($&#123;arrImg[i]&#125;)`\t&#125;\t$alert6.appendChild(img)&#125;// 手机背景for (let i = 0; i &lt; arrImg_1.length; i++) &#123;\tvar img = document.createElement(&#x27;img&#x27;)\timg.src = arrImg_1[i]\timg.onclick = function() &#123; a.style.backgroundImage = `url($&#123;arrImg_1[i]&#125;)`\t&#125;\t$alert14.appendChild(img)&#125;// 适配黑夜模式var changeDark = document.querySelector(&#x27;#darkmode&#x27;)var win = document.querySelector(&#x27;html&#x27;)onscroll = function() &#123; //滚动条滚动就会触发\tif(win.dataset.theme==&#x27;dark&#x27;)&#123; odiv.style.color = &#x27;white&#x27;\t&#125;else&#123; if (window.document.documentElement.scrollTop &gt; 0) &#123; odiv.style.color = &#x27;black&#x27; &#125; else &#123; odiv.style.color = &#x27;white&#x27; &#125;\t&#125;&#125;changeDark.onclick=function()&#123;\t// console.log(win.dataset.theme)\tif(win.dataset.theme==&#x27;light&#x27;)&#123; odiv.style.color = &#x27;white&#x27; $alert2.style.backgroundColor=&#x27;#1c1a1a&#x27; $alert5.style.backgroundColor=&#x27;#283536&#x27; $input.style.backgroundColor=&#x27;black&#x27;\t&#125;else&#123; if (window.document.documentElement.scrollTop &gt; 0) &#123; odiv.style.color = &#x27;black&#x27; &#125; else &#123; odiv.style.color = &#x27;white&#x27; &#125; $alert2.style.backgroundColor=&#x27;white&#x27; $alert5.style.backgroundColor=&#x27;#a3e9eb&#x27; $input.style.backgroundColor=&#x27;white&#x27;\t&#125;&#125;if(win.dataset.theme==&#x27;dark&#x27;)&#123; odiv.style.color = &#x27;white&#x27; $alert2.style.backgroundColor=&#x27;#1c1a1a&#x27; $alert5.style.backgroundColor=&#x27;#283536&#x27; $input.style.backgroundColor=&#x27;black&#x27;\t&#125;else&#123; if (window.document.documentElement.scrollTop &gt; 0) &#123; odiv.style.color = &#x27;black&#x27; &#125; else &#123; odiv.style.color = &#x27;white&#x27; &#125;\t&#125; 更改后的css代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154 /* 背景更换 */ #custom&#123; display: flex; justify-content: space-between; align-items: center; position: absolute; width: 90px; height: 40px; right: 485px; top: 12px; font-size: 0.78em; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif; transition: all 1s; margin-right: 5px; color: white; &#125; #custom:hover&#123; transform: translateX(-0.5rem); &#125; @media screen and (max-width:768px) &#123; #custom&#123;\tright: 70px;&#125; &#125; @media screen and (min-width:768px) and (max-width:824px) &#123; #custom&#123;\tright: 90px;&#125; &#125; @media screen and (max-width:350px) &#123; #custom&#123;\tright: 10px;\ttop: 40px;&#125; &#125; .icon &#123; width: 1.5em; height: 1.5em; vertical-align: -0.45em; fill: currentColor; overflow: hidden; &#125; /* 更换背景的弹窗 */ #alert&#123; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; background-color: rgba(0, 0, 0, 0.8); z-index: 999; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif;; display: none; &#125; #alertcenter&#123; width: 70%; height: 70%; background-color: white; border-radius: 10px; overflow: auto; position: relative; margin: 10vh auto; &#125; #alertcenterHeader&#123; width:70%; height: 33px; background-color: #a3e9eb; line-height: 33px; font-size: 1.1rem; border-radius: 5px 5px 0 0; position: fixed; z-index: 100; &#125; @media screen and (max-width:521px) &#123; #alertcenter&#123; width: 100%; height: 90%; margin: 5vh 0; &#125; #alertcenterHeader&#123; width: 100%; &#125; &#125; #alertcenterContent&#123; width: 100%; display: flex; justify-content: center; flex-wrap: wrap; margin-top: 30px; &#125; #alertcenterContent img&#123; margin: 15px; width: 15%; border-radius: 5px; &#125; #alertcenterContent_1&#123; width: 100%; display: flex; justify-content: center; flex-wrap: wrap; &#125; #alertcenterContent_1 img&#123; margin: 15px; width: 20%; border-radius: 5px; &#125; @media screen and (max-width:780px) &#123; #alertcenterContent img&#123; width: 25%; &#125; &#125; @media screen and (max-width:400px) &#123; #alertcenterContent img&#123; width: 35%; &#125; &#125; #alertcenterContentInput&#123; width: 80%; height: 30px; font-size: 14px; border-radius: 10px; border: 1px solid deepskyblue; display: inline-block; margin-left: 20px; &#125; #aaa&#123; width: 3.875rem; height: 25px; line-height: 25px; text-align: center; font-size: 0.9rem; border: 1px solid black; display: inline-block; margin-left: 0.5rem; border-radius: 4px; &#125; #bbb&#123; height: 33px; display: flex; justify-content: space-between; align-items: center; &#125; #bbb div:nth-child(2)&#123; font-size: 25px; position: fixed; right: 10px; &#125; #alertcenter div:nth-child(2)&#123; position: relative; top: 34px; &#125; 这篇文章后续会持续修改的，请关注一下哦！！！","tags":["butterfly"],"categories":["魔改"]},{"title":"更换博客背景1.0版本（随机背景）","path":"/2024/02/01/10/","content":"提前声明要想完成这个功能你必须会前端三大件（html,css,js）的基础知识，不然你就只能照搬作者的代码，但是里面的内容你是看不懂的哦！！！ 自建与引入css与js文件相信大家应该已经学会了这个步骤了，如果不会的请先移步这篇文章自定义css与js js的代码123456789101112131415161718192021222324252627var arrImg=[&#x27;https://www.toopic.cn/public/uploads/small/1634204095151163420409592.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/163420343597163420343525.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642752073265164275207379.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751728155164275172815.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751487281164275148774.png&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751473324164275147339.png&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/164275143227816427514329.png&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751024946164275102446.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642750988739164275098839.jpg&#x27;]var a=document.querySelector(&#x27;.full_page&#x27;)var b=document.querySelector(&#x27;.menus_item&#x27;)var c=document.querySelector(&#x27;#menus&#x27;)var odiv=document.createElement(&#x27;div&#x27;) //创建一个div标签var suoying=parseInt(Math.random()*arrImg.length) //用来记录是第几张图片odiv.innerHTML=&#x27;&lt;svg t=&quot;1681093944846&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;4217&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M947.2 173.248c6.912 0 12.8 5.888 12.8 12.8v615.232c0 6.912-5.888 12.8-12.8 12.8H76.8c-6.912 0-12.8-5.888-12.8-12.8V186.048c0-6.912 5.888-12.8 12.8-12.8h870.4m0-64H76.8c-42.24 0-76.8 34.56-76.8 76.8v615.232c0 42.24 34.56 76.8 76.8 76.8h870.4c42.24 0 76.8-34.56 76.8-76.8V186.048c0-42.24-34.56-76.8-76.8-76.8z&quot; fill=&quot;blue&quot; p-id=&quot;4218&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M694.4 760.192H117.824l242.176-257.28c25.344-26.944 66.88-26.944 92.224 0l242.176 257.28z&quot; fill=&quot;aqua&quot; p-id=&quot;4219&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M906.176 760.192H519.296l87.552-92.992 59.84-63.552c25.28-26.944 66.816-26.944 92.16 0l147.328 156.544z&quot; fill=&quot;aqua&quot; p-id=&quot;4220&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M649.792 341.952m-62.976 0a62.976 62.976 0 1 0 125.952 0 62.976 62.976 0 1 0-125.952 0Z&quot; fill=&quot;aqua&quot; p-id=&quot;4221&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;span&gt;更换背景&lt;/span&gt;&#x27;odiv.id=&#x27;custom&#x27; //给自己创建的div标签挂一个id属性，方便对其样式进行修改odiv.onclick=function()&#123;\tsuoying++\tif(suoying===arrImg.length)&#123; suoying=0 a.style.backgroundImage=`url($&#123;arrImg[suoying]&#125;)`\t&#125;else&#123; a.style.backgroundImage=`url($&#123;arrImg[suoying]&#125;)`\t&#125;&#125;c.appendChild(odiv)onscroll=function()&#123; //滚动条滚动就会触发 if(window.document.documentElement.scrollTop&gt;0)&#123; odiv.style.color=&#x27;black&#x27; &#125;else&#123; odiv.style.color=&#x27;white&#x27; &#125; &#125;a.style.backgroundImage=`url($&#123;arrImg[suoying]&#125;)` 这里的arrImg数组用来存放照片的链接，可以自行添加照片的链接 css的代码123456789101112131415161718192021222324252627282930313233343536#custom&#123; display: flex; justify-content: space-between; align-items: center; position: absolute; width: 90px; height: 40px; right: 420px; /* 请根据自己的导航栏长度进行修改位置 */ top: 12px; font-size: 0.78em; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif; transition: all 1s; margin-right: 5px; color: white; &#125; #custom:hover&#123; transform: translateX(-0.5rem); &#125; @media screen and (max-width:768px) &#123; #custom&#123; right: 40px; /* 请根据自己的导航栏长度进行修改位置 */\t&#125; &#125; @media screen and (max-width:350px) &#123; #custom&#123; right: 10px; top: 40px;\t&#125; &#125; .icon &#123; width: 1.5em; height: 1.5em; vertical-align: -0.45em; fill: currentColor; overflow: hidden; &#125; 最后不要忘记引入了了哦，小伙伴们！！！ 部署后没有生效的原因如果刷新后没有生效，可以试着清除浏览器数据，再打开自己的博客网站","tags":["butterfly"],"categories":["魔改"]},{"title":"创建express项目","path":"/2024/02/01/9/","content":"安装express我这里是全局安装，去掉-g就不是全局了 1npm install -g express-generator 生成express项目1express myapp 默认生成的是jade的渲染模板更改渲染模板(ejs) 1express --view=ejs myapp 启动express项目在这之前请先执行（下载相关的依赖包）： 1npm i 启动： 1node ./bin/www 查看是否成功express项目默认占用的是3000端口所以去浏览器输入地址http://localhost:3000看看自己有没有成功吧！！","tags":["node"],"categories":["前端进阶"]},{"title":"vue-cli创建vue项目","path":"/2024/02/01/8/","content":"安装vue-cli1npm install -g @vue/cli 创建vue项目1vue create &lt;文件夹名字&gt; 出现： 可以选择默认的vue2项目或者vue3项目，也可以选择最后一条进行手动配置哦启动项目下载完成后尝试启动vue项目在终端执行： 1npm run serve 暂时关闭代码格式检测找到vue.config.js的文件（没有就自己创建） 12345const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave: false, // 暂时关闭代码格式检测&#125;)","tags":["vue"],"categories":["前端进阶"]},{"title":"利用css画图形","path":"/2024/02/01/7/","content":"利用border属性画一个三角形123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box&#123; width: 100px; height: 50px; background: blue; color: white; &#125; .box1&#123; width: 0; height: 0; border: 10px solid rgb(0,0,0,0); /* 将所有边框都透明显示 */ border-top: 10px solid red; /* 只显示上面的边框 */ display: inline-block; position: relative; top: 7px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;导航&lt;span class=&quot;box1&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 利用clip-path属性画一个三角形1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background-color: red; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 怎么样这种方法是不是很方便呢，clip-path属性可不仅仅是画一个简单的三角形，可以画的图形可比你想的还要多呢 clip-path绘制简单图形这里作者就提供一下网站http://tools.jb51.net/code/css3path","tags":["css"],"categories":["前端3大件"]},{"title":"自定义css与js","path":"/2024/02/01/6/","content":"找到butterfly下面的source文件夹（hexo目录下的source文件夹也一样）这是一个静态目录里面可以自定义自己的css与js文件，其实不光是css与js，你的图片与下载好的字体都可以放在这里面 尝试修改自己主题的样式吧如果你还不会css与js，建议前往学习哦！！这里站长就给你提供简单的一个例子在你自定义的css文件下添加一下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 侧边栏个人信息卡片动态渐变色 */#aside-content &gt; .card-widget.card-info &#123; background: linear-gradient( -45deg, #e8d8b9, #eccec5, #a3e9eb, #bdbdf0, #eec1ea ); box-shadow: 0 0 5px rgb(66, 68, 68); position: relative; background-size: 400% 400%; -webkit-animation: Gradient 10s ease infinite; -moz-animation: Gradient 10s ease infinite; animation: Gradient 10s ease infinite !important; &#125; @-webkit-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; @-moz-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; @keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; /* 黑夜模式适配 */ [data-theme=&quot;dark&quot;] #aside-content &gt; .card-widget.card-info &#123; background: #191919ee; &#125; /* 个人信息Follow me按钮 */ #aside-content &gt; .card-widget.card-info &gt; #card-info-btn &#123; background-color: #3eb8be; border-radius: 8px; &#125; 引入css文件 这里虽然是引入字体的地方，也是可以引入css文件的(最好字体的引入与主要的css文件分开)12blog_title_font: font_link: css/custom.css 主要在这里引入123inject: head: # - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/custom.css&quot;&gt; 赶快去试试看自己有没有成功吧！！！ 引入js文件提供一下js的简单代码，用于测试有没有成功引入 1console.log(&#x27;欢迎访问lazychild&#x27;) 开始引入: 123inject: bottom: - &lt;script src=&quot;js/custom.js&quot;&gt;&lt;/script&gt; 成功后重启服务器，打开页面后，按下F12打开console，看看有没有’欢迎访问lazychild’这句话吧，如果有，你就成功了 需要注意小伙伴有没有注意到我这里的引入都是本地引入呢，会出现许多的问题，比如我在引入本地css文件时，只有在首页才有效果，其他页面的没有生效，这就是相对路径引入的问题了，更换引入路径（外网）： 12345678910111213#这是我自己的字体的css文件@font-face &#123; /* 为载入的字体取名字(随意) */ font-family: &#x27;YSHST&#x27;; /* 字体文件地址(相对或者绝对路径都可以) */ src: url(https://xiao-zhe-is-not-lazy.gitee.io/hexo/font/%E9%9C%9E%E9%B6%A9%E6%96%87%E6%A5%B7TC%20Bold_mianfeiziti.com.woff2); /* 定义加粗样式(加粗多少) */ font-weight: normal; /* 定义字体样式(斜体/非斜体) */ font-style: normal; /* 定义显示样式 */ font-display: block; &#125; 然后在修改butterfly下的_config.yml 12blog_title_font: font_link: https://xiao-zhe-is-not-lazy.gitee.io/hexo/css/custom/font.css 12345inject: head: - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://xiao-zhe-is-not-lazy.gitee.io/hexo/css/custom/main.css&quot;&gt; bottom: - &lt;script src=&quot;https://xiao-zhe-is-not-lazy.gitee.io/hexo/js/custom.js&quot;&gt;&lt;/script&gt; 或者(省略掉前面的域名)： 12345inject: head: - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/hexo/css/custom/main.css&quot;&gt; bottom: - &lt;script src=&quot;/hexo/js/custom.js&quot;&gt;&lt;/script&gt; 在本地运行的问题主要就是同源策略的问题，关于什么是同源策略(不同域名，不同端口下就会发生)，就是一个约定，它是浏览器最核心也最基本的安全功能，注意同源策略只会发生在浏览器之间，如果没有同源策略，那么就可以请求任意网站的数据了,直接推送到远程就行，同源策略这个问题就会消失了哦！","tags":["butterfly"],"categories":["魔改"]},{"title":"开启文章封面","path":"/2024/02/01/5/","content":"默认封面的开启找到butterfly下面的_config.yml的文件 1234567891011cover: # display the cover or not (是否顯示文章封面) index_enable: true aside_enable: true archives_enable: true # the position of cover in home page (封面顯示的位置) # left/right/both position: both # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示) default_cover: - https://lskypro.acozycotage.net/Fomalhaut/img/default_cover_14.webp 在default_cover:添加默认封面的图片链接 文章自定义封面开启只要在文章开始添加一个属性 1cover: https://lskypro.acozycotage.net/Fomalhaut/img/default_cover_5.webp 图片来源 直接去别的网站寻找 建立一个远程仓库，将自己的图片放入 图片直接转链接，推荐网站：https://www.imgbed.link/ 重启服务器12$ hexo cl$ hexo s","tags":["butterfly"],"categories":["魔改"]},{"title":"butterfly关于logo图标与头像的增加","path":"/2024/02/01/4/","content":"准备好您的logo很多小伙伴可能对于设计logo这方面没有任何经验，但是又急缺logo，作者在这里推荐一个在线设计logo的网站https://www.logosc.cn/start 关于下载logo需要付费的问题作者这里提供给大家一个小妙招，直接截屏 去掉图片背景颜色大家直接在线去除就行https://www.easeconvert.com/image-remove-background/ 修改配置首先找到butterfly的_config.yml的文件 12345678910111213#修改主页的logonav: logo: img/logo.png display_title: true fixed: true # fixed navigation bar#修改网站标题的logofavicon: /img/favicon.ico#修改头像avatar: img: /img/tou.png effect: false","tags":["butterfly"],"categories":["魔改"]},{"title":"butterfly的安装使用与导航栏基础","path":"/2024/02/01/3/","content":"首先安装butterfly主题在你的根目录下执行 1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 应用butterfly主题找到你hexo的_config.yml文件，更改配置 1theme: butterfly 可能出现的问题(安装插件)如果你沒有 pug 以及 stylus 的渲染器，请下载安裝： 1npm install hexo-renderer-pug hexo-renderer-stylus --save butterfly导航栏的配置默认 12345678910Home: / || fas fa-homeArchives: /archives/ || fas fa-archiveTags: /tags/ || fas fa-tagsCategories: /categories/ || fas fa-folder-openList||fas fa-list: Music: /music/ || fas fa-music Movie: /movies/ || fas fa-videoLink: /link/ || fas fa-linkAbout: /about/ || fas fa-heart 生成新的页面默认安装完成后的butterfly缺少的许多页面，可以根据自己的需要生成举个例子，假如我要生成Tags页面 1hexo new page tags 注意新页面的配置增加一个类型 1type: tags","tags":["butterfly"],"categories":["魔改"]},{"title":"如何部署至Gitee","path":"/2024/02/01/2/","content":"网上也有许多教程，这里作者就是做了一个整理 创建一个Gitee仓库如果不会创建远程仓库的同学，可以先去学习一下哦 开启Gitee Pages先将远程仓库开源，然后在服务选项那里有一个Gitee Pages点进去开启就行(必须设置为开源哦) 一键部署的前提下载hexo-deployer-git 1$ npm install hexo-deployer-git 配置hexo下面的_config.yml1234deploy: type: git repo: (你自己仓库的地址) branch: master 可以在这里找到自己仓库的地址哦 12url: 开启Gitee Pages服务的地址root: 网站的根目录（/&lt;根目录的文件夹名字&gt;） 终端执行的命令12345hexo cl ##清除缓存hexo g ##生成网站静态文件到默认设置的 public 文件夹hexo d ##远程推送至仓库 更新记得更新您的Gitee Pages可能有延迟","tags":["hexo"],"categories":["魔改"]},{"title":"hexo的安装与使用","path":"/2024/02/01/1/","content":"为什么要使用hexo？hexo简单好用 下载node作者这里就只提供一下网站了，安装很简单，node 下载git不会git，建议先学习，这里推荐下载git的比较快的网站，git 查看版本1$ node -v 下载Hexo1$ npm install -g hexo-cli 安装Hexo在你的某个文件夹下，执行： 1$ hexo init 下一篇文章讲如何部署，很多细节哦","tags":["hexo"],"categories":["魔改"]},{"title":"动态","path":"/dynamic/index.html","content":"2024 年 3 月 8 日nginx配置反向代理示例：1234# 配置反向代理location /maoyan &#123; proxy_pass https://i.maoyan.com/api/mmdb/movie/v3/list/hot.json?ct=%E5%A8%84%E5%BA%95&amp;ci=274&amp;channelId=4;&#125;说明：当匹配到/maoyan路径请求时会进行反向代理2024 年 1 月 19 日css属性实现宽度自适应内容, width: fit-content;2024 年 1 月 7 日上天赐个我一位美丽的姑娘吧，我想谈恋爱了💓，哈哈哈哈"},{"title":"关于站长","path":"/about/index.html","content":"刘哲路漫漫其修远兮,吾将上下而求索. 技术栈 html css js vue node 微信小程序 uni-app hexo vant element echarts webpack 兴趣 代码 海贼 吉他 LoL 无畏契约 洛克王国 赚钱 照片墙 1234567"},{"title":"留言","path":"/comments/index.html","content":"Document new Valine({ el: '#vcomments', appId: '1Wgun0BNYRkq1uy13wzMTTlt-gzGzoHsz', appKey: 'LgkvFc6EjDZy8neCIKorXwET', placeholder: '欢迎大家来到lazychild,如果有什么想说的话，请留言给作者哦，作者会尽量快速回复大家的哦😜😜，注意邮箱一定不能写错哦，不然你就收不到作者的回复了', avatar: 'wavatar', pageSize: 4, requiredFields: ['mail'] })"},{"title":"友链","path":"/friends/index.html","content":"一蓑烟雨的博客Joker2YueMiKeyAkilar糖果屋Fomalhaut🥝"}]